 /*
* Copyright(C), 2007-2008, Red Hat Inc.	
* File name: 		funcgpio.c							
* Author:    		Frank Chelle  							
* Version:   		v1.0					
* Date: 			2013.06.14					
* Description:		This provid the gpio control.					
* 						
* History:    							
*/

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <termios.h>
#include <sys/ioctl.h>
#include  <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <time.h>
#include <sys/select.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <assert.h>
#include <pthread.h>  
#include <signal.h>

#include <linux/if.h>
#include <linux/mii.h>
#include <linux/sockios.h>

#include "temperctlmy.h"



#include "common.h"
#include "tpool.h"
#include "funcproc.h"
#include "temper_control.h"
#include "xmodem.h"
#include "mini_board.h"
#include "xmodem.h"
#include "mbcrc.h"
#include "crc16.h"
 #include "port.h"
 
#include "arm_ctl_cabin.h"
 
//#define __DEBUG__
//#define _PRT_PAR_


#define ASPIRATE_T 500000
#define ASPIRATE_AIR_T 500000
#define DISPENSE_T 800000
#define ARMSTABLE_T 300000

int MIX_WASH_DISTANCE;


int OFFSET_STEP,SHELF_OFFSET,MOV_ZH,ZSPEED_SLOW,ZWASH_STEP1,ZWASH_STEP2_1,ZWASH_STEP2_2,ZWASH_STEP2_ZX;
int ZWASH_STEP3,ZWASH_STEP4,ZWASH_STEP4_SLOW,ZDAB_STEP,LIQUID_ZMAX,DAB_ZMAX,POUR_LIQUID_ZMAX;
int OPEN_ARMZMAX,SCAN_DISTANC_MIXSTATION;
int PULL_DISTANC_INIT  ,PULL_DISTANC_LT,PULL_DISTANC_HALF,PULL_DISTANC_FULL;

volatile int  new_scaner = 0,new_temper = 0, honey_scaner = 0;
unsigned short reagent_cabin_zero[6];
unsigned short reagent_cabin_full[6];

int big_version = 0,self_icovert = 0,self_pump = 0,new_mixstation = 1,shelf_lock_new = 0,new_outwast_sen = 0;
int new_inwast_sen = 0,new_version=0;
//**方便校准变量**/
int reagent_distance = REAGENT_DISTANCE;
int slide_distance = SLIDE_DISTANCE;
int distance_scan = DISTANCE_SCAN;
int dispense_spd = 0;
stminibd_sendpacket mini_cmd;
int litst = 15;
/****/
//#include "em9280_drivers.h"

/****************量设置全局变量*******************/
/****************量设置全局变量*******************/
unsigned int zspeed_slow = 0;
unsigned int zwash_step1 = 0;
unsigned int zwash_step2_1 = 0;
unsigned int zwash_step2_2 = 0;
unsigned int zwash_step
unsigned int zwash_step4 = 0; 
unsigned int zDAB_step = 900;
unsigned int zwash_step2_waste = 20;//吸废液步数

unsigned int er2port = 0;
unsigned int er1port = 0;
unsigned int dewaxport = 0;
unsigned int alcoholport = 0;
unsigned int waterport = 0;	
unsigned int washport = 0;
unsigned int probeport = 0;
unsigned int liquid_speed = 0;
unsigned int liquid_step_glb = 2; 
unsigned int liquid_mstep = 0; 
unsigned int liquid_zmax = 1336;
unsigned int DAB_zmax = 900;
unsigned int pour_liquid_zmax = 0;
unsigned int dispense_stepA[3] = {0};//初始位置，150ul，100ul
unsigned int dispense_stepB[3] = {0};
unsigned int dispense_stepC[3] = {0};
unsigned int open_armstep = 13;//6ml透明管
unsigned int open_armstep2 = 9;//7ml开放试剂瓶
unsigned int open_armzmax = 1326;//16 为7ml试剂瓶  开放试剂插一次性试管，高度不一致
unsigned int wat_sypstep = 1000;
 int scanoffset = 0;

/*

#if SELF_PUMP

unsigned int syspeed = 0;
unsigned int syspeed_air = 0;
unsigned int syspeed_waste = 0;
unsigned int syspeed_liquid = 4;
unsigned int syspeed_liquid_remain = 60;
unsigned int syspeed_dispense = 15;
unsigned int syspeed_mixDAB = 0;
unsigned int systep = 0;
unsigned int sy45step = 0;
unsigned int syhstep = 0;
unsigned int symhstep = 6000;
unsigned int syliqtststep = 3720;
unsigned int syhhstep = 0;
unsigned int sy15step = 0;
unsigned int sy110step = 0;
unsigned int systep_air = 0;
unsigned int systep_waste = 288;
unsigned int systep_liquid = 288;
unsigned int systep_DAB = 0;
unsigned int systep_mulDAB = 0;

#else

unsigned int syspeed = 0;
unsigned int syspeed_air = 0;
unsigned int syspeed_waste = 0;
unsigned int syspeed_liquid = 16;
unsigned int syspeed_liquid_remain = 50;
unsigned int syspeed_dispense = 15;
unsigned int syspeed_mixDAB = 0;
unsigned int systep = 0;
unsigned int sy45step = 0;
unsigned int syhstep = 0;
unsigned int symhstep = 5000; 
unsigned int syliqtststep = 3100;
unsigned int syhhstep = 0;
unsigned int sy15step = 0;
unsigned int sy110step = 0;
unsigned int systep_air = 0;
unsigned int systep_waste = 240;
unsigned int systep_liquid = 240;
unsigned int systep_DAB = 0;
unsigned int systep_mulDAB = 0;
#endif
*/
/******************************************/
//-----------------------------static----------------------------------------------
//static TecanOEM_Buffer *in_buf;  // input buffer
static volatile unsigned char flg_armack = 0;//主臂接收到ack标志
static volatile unsigned char sr_armansercode = 0;//主臂接收到answer标志
static volatile unsigned char flg_scanerworking = 1;	//防止还没接收完全又发送命令
static volatile unsigned char flg_scannerrecivimage = FALSE;
static volatile unsigned char flg_scannerlastimage = FALSE;

volatile volatile char scanner_acknum = 0;
char Isinitscanban = 0;
	 
volatile volatile BOOL IMGSNP_ACK = FALSE;
static volatile unsigned char inwait_init_flag = 0;//在受阻后的再次初始化中
//static volatile unsigned char last_answer_flag = 0;//初始化受阻重复初始化会导致YZ控制板通信失败


//static volatile BOOL scan_recieved = FALSE;	//超时标志
//volatile unsigned char minib_flag = 0;
//char image_cmd[50] = {0};

volatile BOOL flg_mainproexit = FALSE;//程序终止标志
volatile BOOL stop_flag = FALSE;//程序暂停标志
volatile stbeep_state beep_state;	//
volatile BOOL CG1_SCAN = FALSE;//第一架玻片需扫描信号
volatile BOOL CG2_SCAN = FALSE;//第二架玻片需扫描信号
volatile BOOL CG3_SCAN = FALSE;//第三架玻片需扫描信号
volatile BOOL CG4_SCAN = FALSE;//第四架玻片需扫描信号
volatile BOOL get_temvale = FALSE;  //在温度维护界面向PC返回温度值标志
volatile BOOL inDischarge = FALSE; //防止吸液于排液储气罐充气动作冲突
volatile BOOL special_reagent_recieved = FALSE;//试剂扫描后通知流程继续运行
volatile BOOL need_check_reagent = FALSE;//试剂扫描后是否需要测试剂量
volatile BOOL flg_netdisconnect = FALSE;	//当失去连接时通知等待接收信息的操作退出等待

 int serail_hand[10];//串口句柄数据
int GPIO_fd=NULL;
static char *parminfo = NULL;//读取主臂信息指针
int remote_fd,local_fd;//网络远端和本机端句柄


stnet_reportlist* preport_head=NULL;//report链表头指针
sterrcode_list* perror_head=NULL;//错误链表头指针
sterrcode_list* perror_exist_head = NULL; //错误存在链表头指针

reagentoutside_list * reagentoutside_head = NULL;//移除过的试剂的试剂信息，可与试剂平台试剂信息重复

volatile ewkevent ewkevent = STOP_ALL;		//	全局工作状态

volatile BOOL NEED_PRINTF = TRUE;

volatile unsigned char scan_data[500000]={0};  //扫描器返回的数据
//unsigned char image_data[500000]={0};

volatile unsigned char image_cmd_len = 0;

volatile unsigned int scan_data_len=0;//扫描器返回数据长度
volatile unsigned char scan_OCR_data[50]={0};//扫描器OCR和条形码数据
volatile unsigned int scan_OCR_len=0;//扫描器OCR和条形码数据长度

extern unsigned int temp_value[];//全部30片玻片温度数据
volatile unsigned short need_perfusion_last[6] = {0};//WATER WASH DEW ALCHOLE ER1 ER2
volatile unsigned short need_perfusion[6] = {0};//当有拔出装入动作时 ++
static volatile char reagent_flag = NO_REAGENT; //试剂使 用全局变量
volatile char last_cabin_reagent = NO_REAGENT; //最后一次使用的大容量试剂
static volatile BOOL flg_cabinremovreagt_inport = FALSE; //确保在函数IsReagentInCabinRemoved中灌注是不进行递归调用
int res_shelf=0;//是否需要整根清洗

volatile unsigned char startmixworkid = 0;	//允许混合或清洗混合瓶操作标志 最高位表示A架 次高位表示B架  最低位表示有空闲时间
volatile unsigned char CriticalWork = 0;	//滴加试剂架上试剂和预处理ER的后一个步骤为critical 最高位表示A架 次高位表示B架
 BOOL first_dispense = TRUE;//滴加时是否为本次滴加的首次
volatile BOOL readfinished485 = FALSE;//485数据读取结束标识
volatile BOOL DOOR_OPENDED = FALSE;	//门打开标识
volatile BOOL OUT_WASTHIGH_H = FALSE; //外部废液桶
volatile BOOL OUT_WASTHIGH_L = FALSE; //外部废液桶

volatile BOOL door_open_action = FALSE;
volatile BOOL nor_wast_barrel = TRUE;
volatile BOOL dng_wast_barrel = TRUE;
volatile BOOL tem_over_load = TRUE;
volatile BOOL tem_over_loadA = FALSE;
volatile BOOL tem_over_loadB = FALSE;
volatile BOOL tem_over_loadC = FALSE;


BOOL setcabinzero = 0;

volatile int tem_limit = 1500;

#ifdef BIG_VERSION
volatile reagentdata_t reagentdata;
volatile unsigned short lightdata = 0;
unsigned short lightcleandata = 0;

#endif


volatile BOOL flg_cabinreved = FALSE;//大容量是否接收完毕标识
volatile BOOL flg_maintianrunning = FALSE;//正在调试标识
extern volatile char isWashWork;//清洗阀控制量
extern volatile char isHighConcentration;//高浓度清洗标识
volatile unsigned char replace_reagent = 0XFF;
volatile BOOL NeedDischarge = TRUE;//排废液标识
volatile BOOL flg_getedserailarr = FALSE;
volatile BOOL TRY_REAGENT_UNLOCK1 = TRUE; //主臂如有吸试剂架试剂操作 等操作结束置TRUE ，md_lockreagentshelf中判断流程中不需锁定则可结锁
volatile BOOL TRY_REAGENT_UNLOCK2 = TRUE;
volatile BOOL TRY_REAGENT_UNLOCK3 = TRUE;
volatile BOOL TRY_REAGENT_UNLOCK4 = TRUE;
volatile unsigned char reagent_lock_num1 = 0; //记录 多少加玻片要锁定 当值为0是说明可以TRY_UNLOCK
volatile unsigned char reagent_lock_num2 = 0; 					//最低位为 A架玻片需要锁状态 当A架滴加完成时将相应位置0 以此类推 
volatile unsigned char reagent_lock_num3 = 0;
volatile unsigned char reagent_lock_num4 = 0;
volatile stshelfstaut reagent_check[4] = {0};
volatile char reagent_lock[4][3];// 4个试剂架，每架有3架玻片架使用
volatile  short cabin_value[12]={0};//	6个short类型容量大小（1~6个容器） +　６个ｓｈｏｒｔ类型传感器状态（１～６个状态）
volatile  unsigned short bigcabin_value[18]={0};//	6个short类型容量大小（1~6个容器） +　６个ｓｈｏｒｔ类型传感器状态（１～６个状态）+6个容量增量
volatile  unsigned short bigcabin_value_init[18]={0};
volatile  char bigcabin_ledstate[6] = {0};

unsigned short bigcabin_reset[6] = {32950,32950,32950,32950,32950,32950};

volatile unsigned  char ReadBuffer485[21] = {0};//读取485串口缓存
 volatile unsigned  char ReadBufferweight[21] = {0};//读取485串口缓存

volatile unsigned char readindex485=0;//读取485串口数据位置值
volatile unsigned char readindexweight=0;//读取485串口数据位置值
 volatile unsigned	char ReadBufferMix[20] = {0};
volatile BOOL MixACK = FALSE, Mix_Res = FALSE;
volatile BOOL WGACK = FALSE, WG_Res = FALSE;

unsigned volatile char Readpump[21] = {0};

unsigned volatile char pump_readbuf[21] = {0};//读取PUMP
unsigned char readindexpump=0;//读取pump串口数据
BOOL flg_startrecvpump = FALSE;
BOOL flg_recvpump = FALSE;
char start_pump_index = 0;

volatile unsigned int serail_dataarr = 0;//主臂Z轴下降的高度
int CorrectDate[9] = {0};//第0 数值不变

unsigned int ReportArrayData[9] = {0};//向PC发送Z轴高度缓存

volatile char SHELF_LOCK_STATE[3] = {0};//置0不触发发送，1解锁状态，2锁定状态

char reagent_clr[3] = {0};
reagent_t reagent_code[36] = {0}; //试剂架上的试剂
//reagent_t reagent_outside_p;	// 
char flg_cabinhavereagent[6];//标记为空数组 DEW WATER ALCHOLE WASH ER1 ER2
mixstation_clear_state_t mixstation_clear_state[6];

short last_tmper[30] = {0};
parameter_t par;

// antibody[36];	//抗体坐标点由PC发来数据确定   用作清洗时标记
// ordArray_H2O2[8];		//H2O2坐标点由PC发来数据确定
// ordArray_DAB[4];		//DAB坐标点由PC发来数据确定
//FILE* scan_fp = NULL;

struct timeval begin_time;//程序开始运行时间

/*************锁和条件变量*************/
//pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t head_lock = PTHREAD_MUTEX_INITIALIZER;//操作数据结构锁
pthread_mutex_t error_lock = PTHREAD_MUTEX_INITIALIZER;//错误链表锁
pthread_mutex_t error_exist_lock = PTHREAD_MUTEX_INITIALIZER;//错误存在链表锁
pthread_mutex_t report_lock = PTHREAD_MUTEX_INITIALIZER;//大容量数据锁
pthread_mutex_t netsend_lock = PTHREAD_MUTEX_INITIALIZER;//发送网络数据锁
pthread_mutex_t pump_lock = PTHREAD_MUTEX_INITIALIZER;//调用压缩泵锁
pthread_mutex_t head_step_lock = PTHREAD_MUTEX_INITIALIZER;//步数数据锁

 pthread_mutex_t armlock_ack = PTHREAD_MUTEX_INITIALIZER;//主臂ack同步锁
 pthread_cond_t armcondtion_ack = PTHREAD_COND_INITIALIZER;//主臂ack条件变量
 pthread_mutex_t armlock_answer = PTHREAD_MUTEX_INITIALIZER;//主臂answer同步锁
 pthread_cond_t armcondtion_answer = PTHREAD_COND_INITIALIZER;//主臂answer条件变量

pthread_mutex_t minib_send_lock = PTHREAD_MUTEX_INITIALIZER;//minib板接收命令锁


/*************************/

/*********三架玻片运行数据状态 可改成结构体便于维护***********/
volatile unsigned char work_cnt=0;//  用于不定时初始化机械臂
volatile unsigned int workstep_state_a = 0X01110000;	//记录操作步数 最高字节置1表示温度加热完成，次高字节置1表示滴加动作完成 最低字节表示步数 第5个1表示时间到达
volatile unsigned int workstep_state_b = 0X01110000;
volatile unsigned int workstep_state_c = 0X01110000;
char report_reagentinfo[3] = {0};
	
volatile BOOL StartDispenseA = FALSE, StartDispenseB = FALSE, StartDispenseC = FALSE;

unsigned int head1_start_time = 0;
unsigned int head2_start_time = 0;
unsigned int head3_start_time = 0;
volatile operate_head_list* operate_pri = NULL;//最先开始架次

static int mulnum_glb[3]={0};
static int mulnum_glb2[3]={0};

volatile BOOL HEAD1_STEP_SENDED = TRUE;
volatile BOOL HEAD2_STEP_SENDED = TRUE;
volatile BOOL HEAD3_STEP_SENDED = TRUE;
volatile BOOL flg_opwork1ready = FALSE;	//玻片架1正在工作标识	用于结束时确定发给哪个minib stop命令
volatile BOOL flg_opwork2ready = FALSE;
volatile BOOL flg_opwork3ready = FALSE;

extern volatile BOOL flg_temperheating1; //A架正在加热标识
extern volatile BOOL flg_temperheating2;
extern volatile BOOL flg_temperheating3;
static BOOL DAB1Array_exchange = FALSE;//DAB瓶交换使用
static BOOL DAB2Array_exchange = FALSE;//DAB瓶交换使用
static BOOL DAB3Array_exchange = FALSE;//DAB瓶交换使用
volatile BOOL isDAB_mixedA = FALSE;//A架DAB是否混合标识
volatile BOOL isDAB_mixedB = FALSE;
volatile BOOL isDAB_mixedC = FALSE;
volatile BOOL isDAB_mixedA_next = FALSE;//A架DAB是否混合标识
volatile BOOL isDAB_mixedB_next = FALSE;
volatile BOOL isDAB_mixedC_next = FALSE;

extern volatile BOOL flg_checkreagentindex[]; //PC发送测试试剂位置
extern volatile char flg_sancmixstatioin;//PC发送混合站扫描

char aspirate_notenough[11];//第11为为能滴加的片数

//volatile BOOL isDAB_mixedACL = FALSE;//
//volatile BOOL isDAB_mixedBCL = FALSE;
//volatile BOOL isDAB_mixedCCL = FALSE;

unsigned int dispense_mixreagent_timeA = 0;	//流程中到滴加混合试剂那一步还有多少时间
unsigned int dispense_mixreagent_timeB = 0;
unsigned int dispense_mixreagent_timeC = 0;
unsigned int dispense_mixreagent_timeA_next = 0;	//流程中到滴加混合试剂那一步还有多少时间
unsigned int dispense_mixreagent_timeB_next = 0;
unsigned int dispense_mixreagent_timeC_next = 0;
char which_mix_kindA = 0, which_mix_kindB = 0, which_mix_kindC = 0;
unsigned char workstep_mix_a = 0;		//混合操作的步数
unsigned char workstep_mix_b = 0;
unsigned char workstep_mix_c = 0;
operate_head_list* operate_head1 = NULL;//A架操作头指针
operate_head_list* operate_head2 = NULL;//B架操作头指针
operate_head_list* operate_head3 = NULL;//C架操作头指针
extern volatile stminibd_cmdlist* pcmd_head;//A架自控臂命令头指针
extern volatile stminibd_cmdlist* pcmd_head2;//B架自控臂命令头指针
extern volatile stminibd_cmdlist* pcmd_head3;//C架自控臂命令头指针
ewkevent ewkeventA = FREE_WORK;	//A架玻片工作状态
ewkevent ewkeventB = FREE_WORK;//B架玻片工作状态
ewkevent ewkeventC = FREE_WORK;//C架玻片工作状态

unsigned int Array_mixed_DAB1[2] = {2504, 0}; //混合后DAB坐标		由于两个轮换使用需要从文件读取
unsigned int Array_mixed_DAB2[2] = {2640, 0};
unsigned int Array_mixed_DAB3[2] = {2768, 0};

unsigned int Array_mixed_RED1[2] = {2504, 0}; //混合后RED坐标	
unsigned int Array_mixed_RED2[2] = {2640, 0};
unsigned int Array_mixed_RED3[2] = {2768, 0};


					
volatile hydrate_t hydrateA;//A架玻片水合操作链表
volatile hydrate_t hydrateB;
volatile hydrate_t hydrateC;
volatile BOOL KEYENDA,KEYENDB,KEYENC;

extern volatile unsigned char    mini_recieve_codeACK;//A架接收的minib命令码
extern volatile unsigned char    mini_recieve_code2;
extern volatile unsigned char    mini_recieve_code3;
extern volatile BOOL mini_finished; 	//每次自控臂命令结束标志 用于自控臂动作的顺序性
extern volatile BOOL mini_finished2;
extern volatile BOOL mini_finished3;
extern BOOL flg_mianarmstop_a; //主臂所在架次的操作结束标志 用于不同架次主臂动作的顺序性
extern BOOL flg_mianarmstop_b;
extern BOOL flg_mianarmstop_c;
unsigned int liquid_valA = 0; //试剂的分配量 100 or 150
unsigned int liquid_valB = 0;
unsigned int liquid_valC = 0;
mix_t mix_DAB[3];//每架混合液信息  按玻片位置填入
mix_t mix_SECEND[3];

volatile unsigned char last_reagentA = NO_REAGENT;//A架玻片最近一次滴加的试剂
volatile unsigned char last_reagentB = NO_REAGENT;
volatile unsigned char last_reagentC = NO_REAGENT;
volatile char lastt_kind[3][9];
extern volatile char shelf_stirmode[];
extern 	volatile unsigned int shelf_stirtime[][3];


time_cal_t work_timeA,work_timeB,work_timeC;
volatile BOOL IsWashProbeStart = FALSE;


/*
BOOL stop_workA = FALSE; // 整架玻片结束标志 避免主板重复发送stop_work命令
BOOL stop_workB = FALSE;
BOOL stop_workC = FALSE;
*/
/*********************/
unsigned int ordArray_OW[2] = {6,46};


//清洗站坐标
unsigned int ordArray_wash[4][2]={
		{2325,32},{2360,32},{2395,32},{2430,32}
};
 int shelf_check[2][3] = {
		{2416,250,500},{2416,1110,500} };

//试剂架坐标
unsigned int ordArray_reagent[36][2] = {
		{2416,250},{2416,370},{2416,490},{2416,610},{2416,730},{2416,850},{2416,970},{2416,1090},{2416,1110},
		{2528,250},{2528,370},{2528,490},{2528,610},{2528,730},{2528,850},{2528,970},{2528,1090},{2528,1110},
		{2680,250},{2680,370},{2680,490},{2680,610},{2680,730},{2680,850},{2680,970},{2680,1090},{2680,1110},
		{2840,250},{2840,370},{2840,490},{2840,610},{2840,730},{2840,850},{2840,970},{2840,1090},{2840,1110}
};
//混合站坐标
unsigned int ordArray_mixed_DAB[6][2] = {
		{2512, 0},{2579, 0},{2646, 0},{2713, 0},{2800, 0},{2864, 0}
};
unsigned int ordArray_plate1[30][2] = {			//每个玻片初始位置
		{232,0},{232,239},{232,470},{232,702},{232,933},{232,1164},{232,1396},{232,1627},{232,1858},{232,2089},
		{1128,0},{1128,239},{1128,470},{1128,702},{1128,933},{1128,1164},{1128,1396},{1128,1627},{1128,1858},{1128,2089},
		{2008,0},{2008,239},{2008,470},{2008,702},{2008,933},{2008,1164},{2008,1396},{2008,1627},{2008,1858},{2008,2089}
		
}; 
 
unsigned int ordArray_plate2[30][2] = {			//每个玻片150ul
		{160,0},{160,239},{160,470},{160,702},{160,933},{160,1164},{160,1396},{160,1627},{160,1858},{160,2089},
		{1058,0},{1058,239},{1058,470},{1058,702},{1058,933},{1058,1164},{1058,1396},{1058,1627},{1058,1858},{1058,2089},
		{1936,0},{1936,239},{1936,470},{1936,702},{1936,933},{1936,1164},{1936,1396},{1936,1627},{1936,1858},{1936,2089}
};

unsigned int ordArray_plate3[30][2] = {			//每个玻片100ul位置
		{100,0},{100,239},{100,470},{100,702},{100,933},{100,1164},{100,1396},{100,1627},{100,1858},{100,2089},
		{998,0},{998,239},{998,470},{998,702},{998,933},{998,1164},{998,1396},{998,1627},{998,1858},{998,2089},
		{1864,0},{1864,239},{1864,470},{1864,702},{1864,933},{1864,1164},{1864,1396},{1864,1627},{1864,1858},{1864,2089}
			
};

unsigned int ordArray_plate4[30][2] = {			//每个玻片组织位置
		{100,0},{100,239},{100,470},{100,702},{100,933},{100,1164},{100,1396},{100,1627},{100,1858},{100,2089},
		{998,0},{998,239},{998,470},{998,702},{998,933},{998,1164},{998,1396},{998,1627},{998,1858},{998,2089},
		{1864,0},{1864,239},{1864,470},{1864,702},{1864,933},{1864,1164},{1864,1396},{1864,1627},{1864,1858},{1864,2089}
			 
};
/*
#if SELF_ICOVERT
 unsigned int load_motor[5] = {25000,60000,25000,43000,95000};//复位 装载 0 拉伸一半 拉伸全部
//unsigned int load_motor[5] = {25000,35000,18000,43000,95000};//复位 装载 0 拉伸一半 拉伸全部
unsigned int arm_motor[11] = {5050,0,1850,3700,5550,7400,9250,11100,12950,14800,16650};
unsigned int load_motor2[5] = {25000,60000,20000,43000,95000};
unsigned int arm_motor2[11] = {5050,0,1850,3700,5550,7400,9250,11100,12950,14800,16650};
unsigned int load_motor3[5] = {25000,60000,20000,43000,95000};
unsigned int arm_motor3[11] = {5050,0,1850,3700,5550,7400,9250,11100,12950,14800,16650};

#else
*/
#ifdef BIG_VERSION
#define INITPOS 2600
unsigned int load_motor[5] = {250,453,380,660,1550};//复位 装载 150 拉伸一半 拉伸全部
unsigned int arm_motor[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 900, INITPOS +1500};
unsigned int load_motor2[5] = {250,453,380,660,1550};
unsigned int arm_motor2[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 900, INITPOS +1500};
unsigned int load_motor3[5] = {250,453,380,660,1550};
unsigned int arm_motor3[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 900, INITPOS +1500};

#else
#define INITPOS 2600
unsigned int load_motor[5] = {16000,29000,35000,43000,95000};//复位 装载 150 拉伸一半 拉伸全部
unsigned int arm_motor[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 650, INITPOS +1000};
unsigned int load_motor2[5] = {16000,29000,27000,43000,100000};
unsigned int arm_motor2[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 650, INITPOS +1000};
unsigned int load_motor3[5] = {16000,29000,27000,43000,95000};
unsigned int arm_motor3[5] = {0,INITPOS, INITPOS + 300 , INITPOS + 650, INITPOS +1000};

#endif

/*

unsigned int temp_sensor_type[30]={22};	//22DPt100L
//unsigned int temp_SV_low[30]={0};		//程序里这个值必须为0
unsigned int temp_SV_High[30]={0};		//1000 100°
unsigned int temp_MV[30]={800};		//700 70%
unsigned int temp_Input_Bias[30]={0};	
unsigned int temp_Input_Filter[30]={1};
unsigned int temp_HeatingPro_Band[30]={100};	//10
unsigned int temp_HeatingInt_Time[30]={100};	//30
unsigned int temp_HeatingDer_Time[30]={5};		//5
unsigned int temp_Heatingctl_Time[30]={2};	// 20
*/
volatile BOOL IsGetImage=FALSE,InGetImage = FALSE;//IsGetImage要扫描标识，为了区别识别图像命令ACK

volatile BOOL IsGetCode = FALSE;

extern  double GetVal30(int step );
	

int sb_waitingframeaswer(sr_cmdstruct_t * CommandElemt);
/******************************************************************************
*
* Function Name  : mb_setreportval
* Description    : .向报告链表中插入值
* 					 
* Input		   : stnet_report
* Output		   : None
* Return		   :  None
*******************************************************************************/
void mb_setreportval(stnet_report report)
{
	stnet_reportlist * preport= preport_head;;

	if (preport_head->report.num == 0XFF)
		preport_head->report = report;
	else
	{
		while(preport->next != NULL)
			preport = preport->next;
		
		while(( preport->next = (stnet_reportlist*)malloc(sizeof(stnet_reportlist)) ) == NULL)
		{
			sleep(1);
			printf("malloc error stnet_reportlist\n");
		}
		preport->next->report = report;
		preport->next->next = NULL;
	}
}
/******************************************************************************
*
* Function Name  : mb_readreportval
* Description    : .向报告链表中读取值
* 					 
* Input		   : None
* Output		   : None
* Return		   :  stnet_report
*******************************************************************************/
stnet_report mb_readreportval(void)
{
	stnet_report report;
	stnet_reportlist* preport;
	
	if (preport_head->report.num == 0XFF)
		return preport_head->report;

	report = preport_head->report;
	
	if (preport_head->next == NULL)
	{	
		preport_head->report.num = 0XFF;
	}
	else
	{
		preport = preport_head;
		preport_head = preport_head->next;
		free(preport);
		preport = NULL;
	}

	return report;	
}

/******************************************************************************
*
* Function Name  : mb_geterrorcode
* Description    : .向错误链表中读取值
* 					 
* Input		   : None
* Output		   : None
* Return		   :  int
*******************************************************************************/

int mb_geterrorcode(void)
{
	int error_code;
	sterrcode_list* perror;
	
	if (perror_head->error_code == NO_ERROR)
		return NO_ERROR;

	error_code = perror_head->error_code;
	
	if (perror_head->next == NULL)
	{	
		perror_head->error_code = NO_ERROR;
	}
	else
	{
		perror = perror_head;
		perror_head = perror_head->next;
		free(perror);
		perror = NULL;
	}

	return error_code;	
}
/******************************************************************************
*
* Function Name  : mb_geterrorcode
* Description    : .向错误链表中插入值
* 					 
* Input		   : int
* Output		   : None
* Return		   :  None
*******************************************************************************/
void mb_seterrorcode(int error_code)
	{
		sterrcode_list * perror= perror_head;
		char netbuf_write[30];
		char i=0;
#if 1
	//	netbuf_write[0] = error_code;
		memcpy(netbuf_write, &error_code, 4);
		if (DOOR_OPEN == error_code || MIX_STATION_CLEARERROR == error_code ||
			(error_code != ASPIRATE_WRONG_NOT_ENOUGH && error_code >= WAST_LIUID_LOW && error_code <= POWER_ERROR) || 
			(error_code >= WATERPOUR_WRONG && error_code <= ER2POUR_WRONG) )
		{
			netbuf_write[4] = 0;
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
		}
		else if ( ( error_code >= TEMPER1_EM && error_code <= TEMPER10_EM && tem_over_load)
			|| MIXA_DILUENT_WRONG == error_code || MIXA_DAB_WRONG == error_code)
		{
			netbuf_write[4] = 'A';
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
		}
		else if ( ( error_code >= TEMPER11_EM && error_code <= TEMPER20_EM && tem_over_load)
			|| MIXB_DILUENT_WRONG == error_code || MIXB_DAB_WRONG == error_code)
		{
			netbuf_write[4] = 'B';
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
		}
		else  if ( ( error_code >= TEMPER21_EM && error_code <= TEMPER30_EM && tem_over_load)
			|| MIXC_DILUENT_WRONG == error_code || MIXC_DAB_WRONG == error_code)
		{
			netbuf_write[4] = 'C';
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
		}
		else if (error_code >= TEMPER1 && error_code <=  TEMPER30)
		{
			
			netbuf_write[4] =  error_code - TEMPER1 + 1 ;
			printf("netbuf_write[0]=%d netbuf_write[4]=%d\n", *(int*)(&netbuf_write[0]),netbuf_write[4]);
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
		}
		else if (error_code == ASPIRATE_WRONG )
		{
			if(aspirate_notenough[10] == 10)
			{
				if (!flg_mianarmstop_a)
					{
					netbuf_write[4] = 'A';
					nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
					}
				else if (!flg_mianarmstop_b)
					{
					netbuf_write[4] = 'B';
					nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
					}
				else if (!flg_mianarmstop_c)
					{
					netbuf_write[4] = 'C';
					nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 5);
					}
			}
			else
			{
				printf("aspirate_wrongaspirate_wrong\n");
			for(i=0;i<aspirate_notenough[10];i++)
			printf(" %d ", aspirate_notenough[i]);
			memcpy(&netbuf_write[4], aspirate_notenough, aspirate_notenough[10]);
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 4 + aspirate_notenough[10]);
			}
		}
		else if(error_code == ASPIRATE_WRONG_NOT_ENOUGH )
		{
			printf("aspirate_notenoughaspirate_notenough\n");
			for(i=0;i<aspirate_notenough[10];i++)
			printf(" %d ", aspirate_notenough[i]);
			memcpy(&netbuf_write[4], aspirate_notenough, aspirate_notenough[10]);
			nt_sendpacketdata(AddBatchErrorLog, netbuf_write, 4 + aspirate_notenough[10]);
			
		}
#endif
		pthread_mutex_lock(&error_lock);
		if (perror_head->error_code == NO_ERROR)
			perror_head->error_code = error_code;
		else
		{
			while(perror->next != NULL)
				perror = perror->next;
			
			while((perror->next = (sterrcode_list*)malloc(sizeof(sterrcode_list))) == NULL)
			{
				sleep(1);
				printf("malloc error sterrcode_list\n");
			}
			perror->next->error_code = error_code;
			perror->next->next = NULL;
		}
		if (pthread_mutex_unlock(&error_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error error_lock");
	}

/******************************************************************************
*
* Function Name  : set_exist_error
* Description    : .向错误存在链表中插入值
* 					 
* Input		   : int
* Output		   : None
* Return		   :  None
*******************************************************************************/
void set_exist_error(int error_code)
{
	sterrcode_list * perror = perror_exist_head;

	//pthread_mutex_lock(&error_exist_lock);
	if (perror_exist_head->error_code == NO_ERROR)
		perror_exist_head->error_code = error_code;
	else
	{
		while(perror->next != NULL)
			perror = perror->next;
		
		while((perror->next = (sterrcode_list*)malloc(sizeof(sterrcode_list))) == NULL)
		{
			sleep(1);
			printf("malloc error sterrcode_list\n");
		}
		perror->next->error_code = error_code;
		perror->next->next = NULL;
	}
	//pthread_mutex_unlock(&error_exist_lock);
}
/******************************************************************************
*
* Function Name  : mb_finderrorcodeinlist
* Description    : .在错误存在链表中查找值，error_code为需要寻找的值，ISDELETE为TRUE时 找到后删除
* 					 
* Input		   : int BOOL
* Output		   : None
* Return		   :  找到TRUE 没找到FALSE
*******************************************************************************/

BOOL mb_finderrorcodeinlist(int error_code, BOOL ISDELETE)
{
	sterrcode_list * perror = perror_exist_head;
	sterrcode_list * last_perror = perror_exist_head;

	printf("[mb_finderrorcodeinlist] error_code=%x\n", error_code);
	printf("errorcode_exist=");
	while(perror != NULL)
	{
		printf(" %d ", perror->error_code);
		perror = perror->next;
	}

	error_code = error_code & 0X00FFFFFF;
	perror = perror_exist_head;
	while(perror != NULL)
	{
		if (perror->error_code == error_code)
		{
			if (ISDELETE)
			{
				if (perror == perror_exist_head)
				{
					if (perror->next == NULL)
					{
						perror->error_code = NO_ERROR;	
					}
					else
					{
						perror_exist_head = perror_exist_head->next;
						free(last_perror);
						last_perror = NULL;
					}
				}
				else
				{
					last_perror->next = perror->next;
					free(perror);
					perror = NULL;
				}
			}
			
			return TRUE;
		}

		last_perror = perror;
		perror = perror->next;
	}
	
	return FALSE;
}

BOOL nt_createsocket( )
{

#if 0 //as service
	struct sockaddr_in local_addr,remote_addr;
	int local_fd = 0;
	int remote_len = 0;
	unsigned char eenetevent=0;
	
	bzero(&local_addr, sizeof (struct sockaddr_in));
	local_addr.sin_family = AF_INET;
	local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	local_addr.sin_port = htons(LOCAL_PORT);

	if ((local_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		perror("nt_createsocket[] socket error\n");
		return FALSE;
	}
		
	if (bind(local_fd, (struct sockaddr*)(&local_addr), sizeof(struct sockaddr)) < 0)
	{
		perror("nt_createsocket[] bind error\n");
		return FALSE;
	}

	if (listen(local_fd, 5) < 0)
	{
		perror("nt_createsocket[] listen error\n");
		return FALSE;
	}

	printf("nt_createsocket finished wait for connect\n");
	remote_len = sizeof(struct sockaddr_in);
	if ((remote_fd = accept(local_fd, (struct sockaddr*)&remote_addr, &remote_len)) < 0);
	{
		perror("nt_createsocket[] accept error\n");
		//return FALSE;
	}
	
	fcntl(local_fd,F_SETFL,O_NONBLOCK);//设置非阻塞方式
/*
	eenetevent = 0X11;
	netbuf_write[0]=eenetevent;
	netbuf_write[1]=1;
	netbuf_write[2]=35;
	netbuf_write[3]=NO_REAGENT;
	if (write(remote_fd, netbuf_write, sizeof(eenetevent) + 3) < 0)
		perror("write net\n");
	*/
	sleep(1);
/*
	int n=0;
	socklen_t len;
	getsockopt(local_fd,SOL_SOCKET,SO_RCVBUF,&n,&len);

	printf("len=%d n=%d+++++++++++++++\n",len,n);
*/

#endif

#if 1 //as client

    int  res;   
    struct hostent *he;  
    struct sockaddr_in serv_addr;  

// if ((he = gethostbyname("192.168.12.121")) == NULL)  
 //	if ((he = gethostbyname("192.168.12.105")) == NULL)  
	if ((he = gethostbyname("192.168.12.100")) == NULL)  
//	if ((he = gethostbyname("192.168.12.100")) == NULL)  
    {  
        fprintf(stderr, "gethostbyname error!\n");  
       return 0;
    }  
    if ((local_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)  
    {  
        fprintf(stderr, "socket error!\n");  
       return 0;  
    }  
    serv_addr.sin_family = AF_INET;  
    serv_addr.sin_port = htons(10000);  
    serv_addr.sin_addr = *((struct in_addr *)he->h_addr);  
    bzero(&(serv_addr.sin_zero), 8);  
	
	fcntl(local_fd,F_SETFL,O_NONBLOCK);//设置非阻塞方式
	
	while(1)
	{
	    if ((res = connect(local_fd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) ) == -1)  
	    {  
	        //fprintf(stderr, "connect error!\n");  
	        printf ("%s", inet_ntoa( serv_addr.sin_addr));
	        printf( "connect net error try again! errorcode=%d\n", res); 
			printf("\n");
	    }  
		else
		{
			 printf( "connect net sucess rescode=%d\n", res); 
			 lprintf(log_my, INFO, "connect net sucess rescode=%d\n", res);
			break;
		}
		sleep(1);
	}
 
	
	flg_netdisconnect = FALSE;

#endif

//memcpy(netbuf_write,"4.0.2.0609",10);
//	memcpy(netbuf_write,"4.0.2.0724",10);
//	memcpy(netbuf_write,"4.0.3.1118",10);
	

//	
//	memcpy(netbuf_write,"5.0.0.0719",10);
//	memcpy(netbuf_write,"5.0.1.0908",10);
//	memcpy(netbuf_write,"5.0.2.0218",10);
//	memcpy(netbuf_write,"5.0.2.0705",10);
	memcpy(netbuf_write,"5.0.2.1122",10);

	
	netbuf_write[10]= needinitialize;
printf("netbuf_write[10]=%d\n",netbuf_write[10]);

	nt_sendpacketdata(INIT_START, netbuf_write, 11);
	needinitialize = FALSE;

	if(initialize_finished)
		nt_sendpacketdata(INIT_END, netbuf_write, 0);

printf("***********nt_createsocket finished*************\n");
return TRUE;
}	/******************************************************************************
* Function Name  : sb_serailcreat
* Description    : GPIO initialization, configuration GPIO 0~19 output, 20~31 input mode.
*                      
* Input          : None
* Output         : None
* Return         :  error return -1, success return 0
*******************************************************************************/
int sb_serailcreat(emb_comid comPort,int Baud, enum emcom_bytesize DataLength, enum emcom_parity Partery)
	{
		int fd = 0;
		 char			 szDevice[16];	
	//	int 	DeviceMax = 0;
		struct termios new_opt;
		int baud_rate;
	//	char test = 0x34;
		/*
		//Com1 17171717е171517170617
		int HS1;				//Com2 00171717171717170617
		int HS2;				//port_arm 17171705171707191717171717170617
		int HS3;				//port_scanner 09171705
		int HS4;				//Com5 171717170204171317170617
		int HS5;				//Com6 1707171717001717
		*/
		
	
	
		sprintf( szDevice,	"/dev/ttyS%d", comPort );
	
		
		
		if( ( fd = open( szDevice, O_RDWR | O_NOCTTY | O_NONBLOCK) ) < 0 )
		{
			printf("can't open szDevice %s\n", szDevice);
			return -1;
		}
		
		else
		{
		  //get the current config -> new_opt
		tcgetattr(fd,&new_opt);
		bzero( &new_opt, sizeof(new_opt));
	
		switch ( Baud )
			{
			case 4800:
				 baud_rate = B4800;
	
			case 9600:
				baud_rate = B9600;
				break;
			case 19200:
				baud_rate = B19200;
				break;
			case 38400:
				baud_rate = B38400;
				break;
			case 57600:
				baud_rate = B57600;
				break;
			case 115200:
				baud_rate = B115200;
				break;
			default:
				baud_rate = 0;
			}
	
		tcflush(fd, TCIOFLUSH);
		//setup input/output baudrate
		cfsetispeed(&new_opt,baud_rate);
		//printf("cfsetispeed::c_cflag = %x\r\n", new_opt.c_cflag);
		cfsetospeed(&new_opt,baud_rate);
		//printf("cfsetospeed::c_cflag = %x\r\n", new_opt.c_cflag);
	
		if (tcsetattr(fd, TCSANOW, &new_opt) != 0)
		{
			perror("tcsetattr::set baud rate failed\n");
			return -1;
		}
	
		//17100717171700041717171708171717971708170017171317
		new_opt.c_cflag |= CLOCAL;
		//printf("c_cflag |= CLOCAL => %x\r\n", new_opt.c_cflag);
	
		//17100717171700041717001717171317170217171217001717171717171717
		new_opt.c_cflag |= CREAD;
		//printf("c_cflag |= CREAD => %x\r\n", new_opt.c_cflag);
	
		new_opt.c_cflag |= HUPCL;
		//setup control flow
		
			//no control-flow
			new_opt.c_cflag &=~CRTSCTS;
			
		//printf("c_cflag(no ctl-flow) = %x\r\n", new_opt.c_cflag);
	
		//setup bit size
		new_opt.c_cflag &=~CSIZE;
		switch(DataLength)
		{
		case '5':
			new_opt.c_cflag |=CS5;
			break;
		case '6':
			new_opt.c_cflag |=CS6;
			break;
		case '7':
			new_opt.c_cflag |=CS7;
			break;
		case '8':
			new_opt.c_cflag |=CS8;
			break;
		default:
			new_opt.c_cflag |=CS8;
		}
	//	printf("c_cflag |= CS8 => %x\r\n", new_opt.c_cflag);
	
		//setup parity
		switch(Partery)
		{
		
		case MYPARITY_NONE:
			new_opt.c_cflag &= ~PARENB;   /* Clear parity enable */
			new_opt.c_iflag &= ~INPCK;	   /* Enable parity checking */
			break;
	
		case MYPARITY_ODD:
			new_opt.c_cflag |= (PARODD | PARENB);	/* 17171717021717Ч1717*/
			new_opt.c_iflag |= INPCK;				/* Disable parity checking */
			break;
	
		case MYPARITY_EVEN:
			new_opt.c_cflag |= PARENB;		/* Enable parity */
			new_opt.c_cflag &= ~PARODD; 	/* 0817170204Ч1717*/
			new_opt.c_iflag |= INPCK;		/* Disable parity checking */
			break;
	
		default:
			fprintf(stderr,"Unsupported parity\n");
			return -1;
		}
		//printf("c_cflag &=~PARENB => %x\r\n", new_opt.c_cflag);
	
	
		//setup stop-bit 1bit
		new_opt.c_cflag &=~CSTOPB;
		
		//setup stop-bit 2bit
		//new_opt.c_cflag |=CSTOPB;
		
		//printf("c_cflag &=~CSTOPB => %x\r\n", new_opt.c_cflag);
	
		/* Set input parity option */
		if ((Partery != PARITY_NONE))
		{
			new_opt.c_iflag |= INPCK;
		}
	
		//17101717171700041717090317171717171717(raw 0004)
		new_opt.c_lflag &= ~(ICANON | ECHO | ISIG); 			/*Input*/
		new_opt.c_oflag &= ~OPOST;								/*Output*/
	
		//1710071717171707171717171700170717171717171710171717021 171717171717
		new_opt.c_cc[VMIN]=1;
	
		//17100717171717071717171717001717051717170717170517020217170211717100ms
		new_opt.c_cc[VTIME]=1;
	
		//17170004171717191717170217171717170117'\n'17091717131717171717
		//1717171717171717031117
		//new_opt.c_iflag |= IGNCR;
		//new_opt.c_iflag &= ~(IXON|IXOFF|IXANY);
	
		//17171717171717171717171717171717171717171717171517171717041717181700
		tcflush(fd,TCIFLUSH);
	
		
		if(tcsetattr(fd,TCSANOW,&new_opt) != 0)
		{
			perror("Cannot set the serial port parameters");
			return -1;
		}
		}
		printf("COM%i 1717031717171717 171717171717 :%i,171717豸δ17171704171717 fd = %d\n",comPort+1 ,Baud, fd);
	
		serail_hand[comPort] = fd; 
		
	/*	while(!flg_mainproexit)
		{
			usleep(800);
		if (write(fd, &test, 1) < 0)
			{
			tcflush( fd,TCOFLUSH);
			printf("write error\n");
		//	return -1;
			}
		//	printf("write com sucess\n");
		}
	
	*/
		return 1;
	}
	
	
	void mb_printfoperatelist(operate_head_list* operate_head)
		{
			operate_t* operate_p = NULL;
			operate_head_list* operate_head_p = NULL;
			printf("data in list\n");
			operate_head_p = operate_head;
		int first_plate_num[200] = {0};
		int i = 0,shelf_num;
		
		char isfirst = 1;
		
		if (operate_head == operate_head1)
			shelf_num = 0;
		else if (operate_head == operate_head2)
			shelf_num = 1;
		else
			shelf_num = 2;
		
			while(operate_head_p != NULL)
			{
				operate_p = &(operate_head_p->operate);
		
				i = 0;
				while(operate_p != NULL)
				{
					if (isfirst)
						{
					first_plate_num[i] = operate_p->plate_num;
					
						}
					else
					{
					//printf("first_plate_num[i]=%d %d", first_plate_num[i],operate_p->plate_num);
					if(first_plate_num[i]>operate_p->plate_num && (first_plate_num[i]) > (operate_p->plate_num + 20))
						mb_seterrorcode( ARM_COLLISION_AVOIDED);
					if(first_plate_num[i]< operate_p->plate_num && (first_plate_num[i] + 20) < operate_p->plate_num)
						mb_seterrorcode( ARM_COLLISION_AVOIDED);
					}
					i++;
					printf(" %d %d %d %d", operate_p->reagent,operate_p->time,
										operate_p->temp, operate_p->plate_num);
					
					printf("--%s",operate_p->reagent_info.code);
					printf("--%s",operate_p->reagent_info.reagent_kind);	
					printf("--%d *",operate_p->reagent_info.special_num);
					
					operate_p = operate_p->next;
				}
				isfirst = 0;
				printf("\n\n");
				operate_head_p = operate_head_p->next_head;
			}
			printf("mix_dab=\n");
			for(i = 0; i < 10; i++)
			{
			
				printf(" %d ", mix_DAB[shelf_num].ordArrayA[i]);
				
				printf("reagentA code=%s kind=%s \n", mix_DAB[shelf_num].reagentA[i].code, mix_DAB[shelf_num].reagentA[i].reagent_kind);
				printf(" %d ", mix_DAB[shelf_num].ordArrayB[i]);
				printf("reagentB code=%s kind=%s \n", mix_DAB[shelf_num].reagentB[i].code, mix_DAB[shelf_num].reagentB[i].reagent_kind);
			
					
			}
				printf("mix_second=\n");
			for(i = 0; i < 10; i++)
			{
			
				printf(" %d ", mix_SECEND[shelf_num].ordArrayA[i]);
				printf(" %d ", mix_SECEND[shelf_num].ordArrayB[i]);
				
					
			}
			printf("\n");
		}

/******************************************************************************
*
* Function Name  : ct_addtabtime
* Description    : .给操作加上时间戳在pc发送operate结束后调用
* 					 
* Input		   : operate_head_list* 
* Output		   : None
* Return		   :  None
*******************************************************************************/
void ct_addtabtime(operate_head_list* new_head, int time)	//需要pc端先把时间叠加,上位机已经吧时间加在operatetime 无需再加
{
	struct timeval now;
	int add_time = 0;
	operate_t* operate_p = NULL;
	operate_head_list* operate_head_p = new_head;

	//assert(new_head);
	if (!new_head)
		return;
	
		gettimeofday(&now, NULL);	
	add_time = now.tv_sec - begin_time.tv_sec;

	printf("in ct_addtabtime time=%d add_time=%d\n",time, add_time);
	while(operate_head_p != NULL)
	{
		operate_p = &(operate_head_p->operate);
		while(operate_p != NULL)
		{
			operate_p->time += add_time;
			operate_p = operate_p->next;
		}
		operate_head_p = operate_head_p->next_head;
	}
	//mb_printfoperatelist(new_head);
}
/******************************************************************************
*
* Function Name  : rf_read2minidata
* Description    : .从字符串读取坐标值 一维坐标
* 					 
* Input		   :char * 字符串，unsigned int 坐标个数
* Output		   :unsigned int ordArray[]读取后的值填入数组
* Return		   :  None
*******************************************************************************/
void rf_read2minidata( unsigned int ordArray[],char * read_buffer, unsigned int num)
{
	char pstring[1000] = {0};
	unsigned int x=0,i;
	char *ptr = NULL;
	for (i = 0;i < num;i++)
	{
	//	printf("read_buffer=%s\n",read_buffer);
		strcpy(pstring, read_buffer);
		x = ordArray[i] = atoi(strtok_r(pstring, "|",&ptr));
	//	printf("x =%d read_buffer=%s\n", x,read_buffer);
		
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	//	printf("read_buffer=%s",read_buffer);
	//	printf("i=%d\n",i);
	}
	//printf("rf_read2minidata finished\n");
	//printf("\n");
}
/******************************************************************************
*
* Function Name  : rf_read2array
* Description    : .从字符串读取坐标值三维坐标
* 					 
* Input		   :char * 字符串，unsigned int 坐标个数
* Output		   :unsigned int ordArray[][2]读取后的值填入数组
* Return		   :  None
*******************************************************************************/
void rf_read2array( unsigned int ordArray[][3],char * read_buffer, unsigned int num)
{
	char pstring[100] = {0};//截取 " "
	char ppstring[100] = {0};//截取 "|"
	unsigned int x=0,y=0,z=0,i = 0,len = 0;
	char *ptr = NULL;
	for (i = 0;i < num;i++)
	{
	//	printf("read_buffer=%s\n",read_buffer);
		strcpy(ppstring,read_buffer);
		strtok_r(ppstring, "|",&ptr);
		len = strlen(ppstring);
		strcpy(pstring, ppstring);
		x = ordArray[i][0] = atoi(strtok_r(pstring, " ",&ptr));
	//	printf("x =%d ppstring=%s\n", x,ppstring);

		strcpy(ppstring, &ppstring[strlen(pstring) + 1]);
		strcpy(pstring, ppstring);	
		y = ordArray[i][1] = atoi(strtok_r(pstring, " ",&ptr));
	//	printf("y =%d ppstring=%s\n",y ,ppstring);
		
		strcpy(ppstring, &ppstring[strlen(pstring) + 1]);
		strcpy(pstring, ppstring);	
		z = ordArray[i][2] = atoi(strtok_r(pstring, "|",&ptr));
	//	printf("z =%d ppstring=%s\n",z ,ppstring);

	
	
		//strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[len + 1]);
	//	printf("read_buffer=%s",read_buffer);
//		printf("i=%d\n",i);
	}
//	printf("rf_read2array finished\n");
//	printf("\n");
}

void mb_setallpara(void)
{
	

	
	if (SELF_ICOVERT)
	{
	load_motor[2] = 25000;
	load_motor[3] = 43000;
	load_motor[4] = 100000;
	load_motor2[2] = 25000;
	load_motor2[3] = 43000; 	
	load_motor2[4] = 100000;
	load_motor3[2] = 25000;
	load_motor3[3] = 43000;
	load_motor3[4] = 100000;
	PULL_DISTANC_INIT = 5 + TULUN_MISTAKE;
		PULL_DISTANC_LT = 32 - TULUN_MISTAKE*2;//初始位置网左走   拉伸位置网右走
		PULL_DISTANC_HALF = 80 - TULUN_MISTAKE*2;
		PULL_DISTANC_FULL = 155 - TULUN_MISTAKE*2;
	
	
	}
	else
	{
	#ifndef BIG_VERSION
			#if NEW_STRECH
			load_motor[2] = 27000;
			load_motor[3] = 40000;
			load_motor[4] = 103000;
			load_motor2[2] = 27000;
			load_motor2[3] = 40000;
			load_motor2[4] = 103000;
			load_motor3[2] = 27000;
			load_motor3[3] = 40000;
			load_motor3[4] = 103000;
			#else
			load_motor[2] = 27000;
			load_motor[3] = 40000;
			load_motor[4] = 98000;
			load_motor2[2] = 27000;
			load_motor2[3] = 40000;
			load_motor2[4] = 98000;
			load_motor3[2] = 27000;
			load_motor3[3] = 40000;
			load_motor3[4] = 98000;
			#endif
			#ifdef LAIYUE
			load_motor[4] = 98000;
			load_motor2[4] = 98000;
			load_motor3[4] = 98000;
			#endif
	#endif
	//load_motor3[4] = 103000;
	
	PULL_DISTANC_INIT = TULUN_MISTAKE;
		PULL_DISTANC_LT = 32 - TULUN_MISTAKE*2;
		PULL_DISTANC_HALF = 76 - TULUN_MISTAKE*2;
	//	PULL_DISTANC_HALF = 76 - TULUN_MISTAKE*2 + 40;//tst
		PULL_DISTANC_FULL = 175 - TULUN_MISTAKE*2;
	
	}
		

SCAN_DISTANC_MIXSTATION = 30;

if (NEW_MIXSTATION)
{
	#ifdef BIG_VERSION//53.9
		MIX_WASH_DISTANCE = 241;//0.22345
	#else
		MIX_WASH_DISTANCE = 292;
	#endif
	//SCAN_DISTANC_MIXSTATION = 55; //65
}
else
{
	MIX_WASH_DISTANCE = 185;
	//SCAN_DISTANC_MIXSTATION = 30;
}
//0.098 mm per step
#ifdef BIG_VERSION//19.85
{
// OFFSET_STEP = 210;
  OFFSET_STEP = 202;//理论值202
  SHELF_OFFSET = 97;
 MOV_ZH = 0;
}
#else
{
	MOV_ZH = 300;
	SHELF_OFFSET = 0;

OFFSET_STEP = 0;
}
#endif
 ZSPEED_SLOW =4000;
 ZWASH_STEP1 =650	 - OFFSET_STEP; // 1号口的最深位置
 ZWASH_STEP2_1 =543  - OFFSET_STEP; 	// 2号的状态1
 ZWASH_STEP2_2 =450  - OFFSET_STEP; // 2号的状态2
 ZWASH_STEP2_ZX =520  - OFFSET_STEP;
 ZWASH_STEP3 =565  - OFFSET_STEP;
 ZWASH_STEP4 =1000	+200 - OFFSET_STEP;
 ZWASH_STEP4_SLOW =600	- OFFSET_STEP;
 ZDAB_STEP =zDAB_step - OFFSET_STEP;
 DAB_ZMAX =DAB_zmax  - OFFSET_STEP;

#ifdef BIG_VERSION

//试剂仓降低了9.5mm 
 LIQUID_ZMAX =liquid_zmax  - OFFSET_STEP + SHELF_OFFSET;
// POUR_LIQUID_ZMAX =pour_liquid_zmax - OFFSET_STEP;
 OPEN_ARMZMAX =open_armzmax - OFFSET_STEP+ SHELF_OFFSET;
#else
 LIQUID_ZMAX =liquid_zmax;
// POUR_LIQUID_ZMAX =pour_liquid_zmax - OFFSET_STEP;
 OPEN_ARMZMAX =open_armzmax;

#endif

if (SELF_PUMP)
{
#if 0
 PORT_OFFSET= 1;
 PORT_OFFSET_POOL = 7;

 SYSPEED_TST= 4;
 SYSPEED =30;
 SYSPEED_CLEAN =20;
 SYSPEED_AIR =4;
 SYSPEED_WASTE =4;
	
 SYSPEED_LIQUID =4;
// SYSPEED_DISPENSE =12;//the dospense speed should be fast但是太快可能会将气泡滴加进去
 SYSPEED_DISPENSE =20;
 SYSPEED_DISPENSEFUL = 18;
 SYSPEED_ALCHOLE = 20;

 START_DISPENSE = 30;
 SYSSTARTSPD = 20;
 SYSCUTOFF_SPEED = 500;//2000

 SYSPEED_MIXDAB =10;
 SYDELAY =800;
 SYFSTEP =5660;
 SY45STEP =4528	;// 4/5
 SYHSTEP =2830;
 SYMHSTEP =3773;	//一半多点
 SYLIQTSTSTEP =2824 ;
 SYHHSTEP =1415	;	//一半的一半
 SY15STEP =1132	;// 1/5
 SY110STEP =566;// 1/10
 SYSTEP_AIR =24;  //5ul   travel空气柱						、、SYSTEP_AIR_LAG必须要大于 SYSTEP_AIR5ul
 SYSTEP_AIR_LAG=23 ; //10ul  吸试剂架试剂前吸的空气柱  越小空气柱越稳定
	//#define SYSTEP_AIR_STAG 36  //15ul
 SYSTEP_WASTE =453;
 SYSTEP_LIQTSTAIR =94;
 SYSTEP_LIQUID =226;//吸一张玻片液PUMP走的步数 (分配量为100ul) //测得量为43  额定为240步
 SYSTEP_LIQUID_REMAIN =47 ;
#else if
PORT_OFFSET= 1;
 PORT_OFFSET_POOL = 7;

 SYSPEED_TST= 10;
 SYSPEED =40;
 SYSPEED_CLEAN =40;
 SYSPEED_AIR =8;
 SYSPEED_WASTE =8;
	
 SYSPEED_LIQUID =8;
 SYSPEED_LIQUIDEBER = 6;
// SYSPEED_DISPENSE =12;//the dospense speed should be fast但是太快可能会将气泡滴加进去
 SYSPEED_DISPENSE =40;
 SYSPEED_DISPENSE_SHELF = 20;
 SYSPEED_ALCHOLE = 44;

 START_DISPENSE = 50;
 SYSSTARTSPD = 400;
 SYSCUTOFF_SPEED = 1500;//2000;
// SYSCUTOFF_SPEED = 3000;//2000;

 SYSPEED_MIXDAB = 35;
 SYDELAY =800;
 SYFSTEP =9056;//6804
 SY45STEP =7252	;// 4/5
 SYHSTEP =4532;
 SYMHSTEP =6032;	//一半多点
 SYLIQTSTSTEP =4648 ;
 SYHHSTEP =2266	;	//一半的一半
 SY15STEP =1813	;// 1/5
 SY110STEP =906;// 1/10
 SYSTEP_AIR =37;  //5ul   travel空气柱						、、SYSTEP_AIR_LAG必须要大于 SYSTEP_AIR5ul
 SYSTEP_AIR_LAG=55 ; //10ul  吸试剂架试剂前吸的空气柱  越小空气柱越稳定
	//#define SYSTEP_AIR_STAG 36  //15ul
 SYSTEP_WASTE =725;
 SYSTEP_LIQTSTAIR =150;
 SYSTEP_LIQUID =362;//吸一张玻片液PUMP走的步数 (分配量为100ul) //测得量为43  额定为240步
 SYSTEP_LIQUID_REMAIN =75;
 

#endif
}	
else
{
 PORT_OFFSET =0;
	
 SYSPEED_TST= 16;
 SYSPEED =6;	//32K //5
 SYSPEED_CLEAN= 8;
 SYSPEED_AIR= 20;
 SYSPEED_WASTE =16;
 SYSPEED_ALCHOLE = 12;

	//#define SYSPEED_LIQUID 16
	//#define SYSPEED_LIQUID 10
 SYSPEED_LIQUID =16;
 SYSPEED_LIQUIDEBER = 20;
 SYSPEED_DISPENSE =12;// 12//the dospense speed should be fast但是太快可能会将气泡滴加进去
 SYSPEED_DISPENSE_SHELF = 15;
 SYSPEED_DISPENSEFUL = 15;
// START_DISPENSE = 15;
 SYSSTARTSPD = 900;
 SYSCUTOFF_SPEED = 2000;
 SYSPEED_MIXDAB= 7;
 SYDELAY =800;
 SYFSTEP= 6000;
 SY45STEP =4800;	// 4/5
 SYHSTEP= 3000;
 SYMHSTEP =4000;	//一半多点
 SYLIQTSTSTEP =3100 ;
 SYHHSTEP =1500	;	//一半的一半
 SY15STEP= 1200;	// 1/5
 SY110STEP =600;// 1/10
 SYSTEP_AIR =12;  //5ul   travel空气柱						、、SYSTEP_AIR_LAG必须要大于 SYSTEP_AIR5ul
 SYSTEP_AIR_LAG= 18 ; //5ul  吸试剂架试剂前吸的空气柱  越小空气柱越稳定
	//#define SYSTEP_AIR_STAG 36  //15ul
 SYSTEP_WASTE= 480;
 SYSTEP_LIQTSTAIR= 100;
 SYSTEP_LIQUID= 240;//吸一张玻片液PUMP走的步数 (分配量为100ul) //测得量为43  额定为240步
 SYSTEP_LIQUID_REMAIN= 50 ;
}
	

}
/*************从文件读取配置信息**************/
void mb_readconfparatinfo(char IsDef)
{
	char read_buffer[1000]={0};
	char pstring[1000] = {0};
	unsigned int x=0,y=0,i=0,j=0,buffer_counter=0,ocnt = 0;
	char *ptr = NULL;
	char *ppath = NULL;
	char buf[10] = "abcdef";
	char data_tmp[10];
int X_coordinate,cal_tmp=0;
int res = 0;

	if (IsDef)
		ppath = MeasureConfigDefPath;
	else
		ppath = MeasureConfigPath;
	
			X_coordinate = rf_readintfromeprofile("mb_readconfparatinfo", "LIQUID_SPEED", -1, (const char *)ppath);

			if (X_coordinate <= 100)
				X_coordinate = 350;
			scanoffset =(X_coordinate - 350) ;
			printf("scanoffset=%d\n\n", scanoffset);

new_temper = new_version = rf_readstringfromeprofile("ReadtemperInfo","temp_Input_Bias[60]",read_buffer,1000,NULL,(const char *)ppath);

	mb_readrunparainfo();
#ifdef BIG_VERSION
	big_version = 1;
	 lightcleandata = rf_readintfromeprofile("mb_readconfparatinfo", "lightcleandata", -1, (const char *)MeasureConfigPath);


	//发送命令给大容量控制板自己归零
	 
	  rf_readstringfromeprofile("mb_readconfparatinfo","reagent_cabin_zero[6]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 6;i++)
	{
		strcpy(pstring, read_buffer);
		reagent_cabin_zero[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}
	printf("reagent_cabin_zero=");
	for(i=0;i<6;i++)		
		printf(" %d ",reagent_cabin_zero[i]);

	rf_readstringfromeprofile("mb_readconfparatinfo","reagent_cabin_full[6]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 6;i++)
	{
		strcpy(pstring, read_buffer);
		reagent_cabin_full[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}
	printf("reagent_cabin_full=");
	for(i=0;i<6;i++)		
		printf(" %d ",reagent_cabin_full[i]);
	
	
#else
big_version = 0;

#endif
//	while(1) sleep(1);
/*
	FILE *F = NULL;
	F = fopen("/mnt/nandflash/ta","w=");
	fwrite(buf,1,5,F);
	fclose(F);
while(1) sleep(1);
*/

//	 zspeed_slow = rf_readintfromeprofile("mb_readconfparatinfo", "ZSPEED_SLOW", -1, (const char *)MeasureConfigPath);
	// zwash_step1 = rf_readintfromeprofile("mb_readconfparatinfo", "ZWASH_STEP1", -1, (const char *)MeasureConfigPath);
//	zwash_step2_1 = rf_readintfromeprofile("mb_readconfparatinfo", "ZWASH_STEP2_1", -1, (const char *)MeasureConfigPath);
//	zwash_step2_2 = rf_readintfromeprofile("mb_readconfparatinfo", "ZWASH_STEP2_2", -1, (const char *)MeasureConfigPath);
//	zwash_step3 = rf_readintfromeprofile("mb_readconfparatinfo", "ZWASH_STEP3", -1, (const char *)MeasureConfigPath);
//	zwash_step4 = rf_readintfromeprofile("mb_readconfparatinfo", "ZWASH_STEP4", -1, (const char *)MeasureConfigPath);
/*
//	zDAB_step = rf_readintfromeprofile("mb_readconfparatinfo", "ZDAB_STEP", -1, (const char *)MeasureConfigPath);
	syspeed = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED", -1, (const char *)MeasureConfigPath);
	syspeed_air = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED_AIR", -1, (const char *)MeasureConfigPath);
	syspeed_waste = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED_WASTE", -1, (const char *)MeasureConfigPath);
//	syspeed_liquid = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED_LIQUID", -1, (const char *)MeasureConfigPath);
	syspeed_dispense = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED_DISPENSE", -1, (const char *)MeasureConfigPath);
	syspeed_mixDAB = rf_readintfromeprofile("mb_readconfparatinfo", "SYSPEED_MIXDAB", -1, (const char *)MeasureConfigPath);
	systep = rf_readintfromeprofile("mb_readconfparatinfo", "SYFSTEP", -1, (const char *)MeasureConfigPath);
	sy45step = rf_readintfromeprofile("mb_readconfparatinfo", "SY45STEP", -1, (const char *)MeasureConfigPath);
	syhstep = rf_readintfromeprofile("mb_readconfparatinfo", "SYHSTEP", -1, (const char *)MeasureConfigPath);
	symhstep = rf_readintfromeprofile("mb_readconfparatinfo", "SYMHSTEP", -1, (const char *)MeasureConfigPath);
	syhhstep = rf_readintfromeprofile("mb_readconfparatinfo", "SYHHSTEP", -1, (const char *)MeasureConfigPath);
	sy15step = rf_readintfromeprofile("mb_readconfparatinfo", "SY15STEP", -1, (const char *)MeasureConfigPath);
	sy110step = rf_readintfromeprofile("mb_readconfparatinfo", "SY110STEP", -1, (const char *)MeasureConfigPath);
	systep_air = rf_readintfromeprofile("mb_readconfparatinfo", "SYSTEP_AIR", -1, (const char *)MeasureConfigPath);
	systep_waste = rf_readintfromeprofile("mb_readconfparatinfo", "SYSTEP_WASTE", -1, (const char *)MeasureConfigPath);
//	systep_liquid = rf_readintfromeprofile("mb_readconfparatinfo", "SYSTEP_LIQUID", -1, (const char *)MeasureConfigPath);
	systep_DAB = rf_readintfromeprofile("mb_readconfparatinfo", "SYSTEP_DAB", -1, (const char *)MeasureConfigPath);
	systep_mulDAB = rf_readintfromeprofile("mb_readconfparatinfo", "SYSTEP_MULDAB", -1, (const char *)MeasureConfigPath);
*/
//	er2port = rf_readintfromeprofile("mb_readconfparatinfo", "ER2PORT", -1, (const char *)MeasureConfigPath);
//	er1port = rf_readintfromeprofile("mb_readconfparatinfo", "ER1PORT", -1, (const char *)MeasureConfigPath);
//	dewaxport = rf_readintfromeprofile("mb_readconfparatinfo", "DEWAXPORT", -1, (const char *)MeasureConfigPath);
//	alcoholport = rf_readintfromeprofile("mb_readconfparatinfo", "ALCOHOLPORT", -1, (const char *)MeasureConfigPath);
//	waterport = rf_readintfromeprofile("mb_readconfparatinfo", "WATERPORT", -1, (const char *)MeasureConfigPath);
//	washport = rf_readintfromeprofile("mb_readconfparatinfo", "WASHPORT", -1, (const char *)MeasureConfigPath);
//	probeport = rf_readintfromeprofile("mb_readconfparatinfo", "PROBEPORT", -1, (const char *)MeasureConfigPath);
	//scanoffset = rf_readintfromeprofile("mb_readconfparatinfo", "LIQUID_SPEED", -1, (const char *)MeasureConfigPath);
//	liquid_mstep = rf_readintfromeprofile("mb_readconfparatinfo", "LIQUID_MSTEP", -1, (const char *)MeasureConfigPath);
//	dispense_step = rf_readintfromeprofile("mb_readconfparatinfo", "DISPENSE_STEP", -1, (const char *)MeasureConfigPath);

#if 1
	self_icovert = rf_readintfromeprofile("mb_readconfparatinfo", "SELF_ICOVERT", -1, (const char *)ppath);
	self_pump = rf_readintfromeprofile("mb_readconfparatinfo", "SELF_PUMP", -1, (const char *)ppath);
	new_mixstation = rf_readintfromeprofile("mb_readconfparatinfo", "NEW_MIXSTATION", -1, (const char *)ppath);
	shelf_lock_new = rf_readintfromeprofile("mb_readconfparatinfo", "SHELF_LOCK_NEW", -1, (const char *)ppath);
	new_outwast_sen = rf_readintfromeprofile("mb_readconfparatinfo", "NEW_OUTWAST_SEN", -1, (const char *)ppath);
#if NEW_BARREL
	new_inwast_sen = rf_readintfromeprofile("mb_readconfparatinfo", "NOR_WAST_BARREL", -1, (const char *)ppath);
#endif

#endif



	if (PRINTF)
		{
	/*
	printf("zspeed_slow=%d zwash_step1=%d zwash_step2_1=%d zwash_step2_2=%d zwash_step3=%d\n",zspeed_slow,zwash_step1,zwash_step2_1,zwash_step2_2,zwash_step3);
	printf("zwash_step4=%d zDAB_step=%d syspeed=%d syspeed_air=%d syspeed_waste=%d syspeed_liquid=%d\n",zwash_step4,zDAB_step,syspeed,syspeed_air,syspeed_waste,syspeed_liquid);
	printf("syspeed_dispense=%d syspeed_mixDAB=%d systep=%d sy45step=%d syhstep=%d syhhstep=%d\n",syspeed_dispense,syspeed_mixDAB,systep,sy45step,syhstep,syhhstep);
	printf("sy15step=%d sy110step=%d systep_air=%d systep_waste=%d systep_DAB=%d\n",sy15step,sy110step,systep_air,systep_waste,systep_DAB);
	printf("systep_mulDAB=%d er2port=%d er1port=%d dewaxport=%d alcoholport=%d waterport=%d\n",systep_mulDAB,er2port,er1port,dewaxport,alcoholport,waterport);
	printf("washport=%d probeport=%d liquid_speed=%d liquid_mstep=%d liquid_zmax=%d\n",washport,probeport,liquid_speed,liquid_mstep,liquid_zmax);
	printf("pour_liquid_zmax=%d\n",pour_liquid_zmax);
	*/
	printf("big_version=%d self_icovert=%d,self_pump=%d,new_mixstation=%d,shelf_lock_new=%d,new_outwast_sen=%d\n",
		big_version,self_icovert,self_pump,new_mixstation,shelf_lock_new,new_outwast_sen);
		}

	pour_liquid_zmax = rf_readintfromeprofile("mb_readconfparatinfo", "POUR_LIQUID_ZMAX", -1, (const char *)ppath);

	if(pour_liquid_zmax >= 2000)
		honey_scaner = 1;
	else
	{
		honey_scaner = 0;
	
	if (pour_liquid_zmax >= 1000)
		new_scaner = 1;
	else
		new_scaner = 0;
	}
	printf("honey_scaner=%d new_scaner=%d\n", honey_scaner, new_scaner);
	DAB_zmax = rf_readintfromeprofile("mb_readconfparatinfo", "DAB_ZMAX", -1, (const char *)ppath);
//	liquid_zmax = rf_readintfromeprofile("mb_readconfparatinfo", "LIQUID_ZMAX", -1, (const char *)MeasureConfigPath);
//	open_armstep = rf_readintfromeprofile("mb_readconfparatinfo", "OPEN_ARMSTEP", -1, (const char *)MeasureConfigPath);

//	printf("dispense_stepA=%d\n",dispense_stepA);
	

	rf_readstringfromeprofile("mb_readconfparatinfo","isREAGENT_IN_CABIN_AVAILABLE[6]",read_buffer,1000,NULL,(const char *)ppath);




	for (i = 0;i < 6;i++)
	{
		strcpy(pstring, read_buffer);
		flg_cabinhavereagent[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

	rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_wash[3]",read_buffer,100,NULL,(const char *)ppath);
	rf_read2array(par.ordArray_wash,read_buffer,1);
	rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_reagent[4][3]",read_buffer,100,NULL,(const char *)ppath);
	rf_read2array(par.ordArray_reagent,read_buffer,4);
//	rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_mixed_DAB[3]",read_buffer,100,NULL,(const char *)MeasureConfigPath);
//	rf_read2array(par.ordArray_mixed_DAB,read_buffer,1);
	
//	rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_plate[3][3]",read_buffer,100,NULL,(const char *)MeasureConfigPath);
//	rf_read2array(par.ordArray_plate,read_buffer,3);
		rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_plate[9][3]",read_buffer,200,NULL,(const char *)ppath);
	rf_read2array(par.ordArray_plate,read_buffer,9);
printf(" par.ordArray_plate[i*3+2][2]; =%d", par.ordArray_plate[6+2][2]);
	rf_readstringfromeprofile("ReadCoordinateInfo","shelf_check[2][3]",read_buffer,100,NULL,(const char *)ppath);
	rf_read2array(par.shelf_check,read_buffer,2);
	rf_readstringfromeprofile("ReadCoordinateInfo","ordArray_OW[3]",read_buffer,100,NULL,(const char *)ppath);
	rf_read2array(par.ordArray_OW,read_buffer,1);
		rf_readstringfromeprofile("ReadMiniboardInfo","load_motor1",read_buffer,100,NULL,(const char *)ppath);

#ifdef BIG_VERSION
	rf_read2minidata(par.load_motor1,read_buffer,2);
	rf_readstringfromeprofile("ReadMiniboardInfo","arm_motor1",read_buffer,100,NULL,(const char *)ppath);
	rf_read2minidata(par.arm_motor1,read_buffer,3);

	rf_readstringfromeprofile("ReadMiniboardInfo","load_motor2",read_buffer,100,NULL,(const char *)ppath);
	rf_read2minidata(par.load_motor2,read_buffer,2);
	rf_readstringfromeprofile("ReadMiniboardInfo","arm_motor2",read_buffer,100,NULL,(const char *)ppath);
	rf_read2minidata(par.arm_motor2,read_buffer,3);

	rf_readstringfromeprofile("ReadMiniboardInfo","load_motor3",read_buffer,100,NULL,(const char *)ppath);
	rf_read2minidata(par.load_motor3,read_buffer,2);
	rf_readstringfromeprofile("ReadMiniboardInfo","arm_motor3",read_buffer,100,NULL,(const char *)ppath);
	rf_read2minidata(par.arm_motor3,read_buffer,3);

	for(i = 0; i < 3;i++)//3个位置
	{
		arm_motor[1+i] = par.arm_motor1[i];
		arm_motor2[1+i] = par.arm_motor2[i];
		arm_motor3[1+i] = par.arm_motor3[i];
	}
#endif


	/*
	par.ordArray_wash[0] = 2047;
	par.ordArray_wash[1] = 50;

//	par.ordArray_reagent[0][2] = 1200;
	par.ordArray_reagent[0][2] = 300;
	par.ordArray_reagent[0][0] = 2120;
	par.ordArray_reagent[0][1] = 264;
	par.ordArray_reagent[1][0] = 2270;
	par.ordArray_reagent[1][1] = 264;
	par.ordArray_reagent[2][0] = 2420;
	par.ordArray_reagent[2][1] = 264;
	par.ordArray_reagent[3][0] = 2570;
	par.ordArray_reagent[3][1] = 264;	
	
	par.ordArray_plate[0][0] = 302;
	par.ordArray_plate[0][1] = 32;
	par.ordArray_plate[1][0] = 1078;
	par.ordArray_plate[1][1] = 32;
	par.ordArray_plate[2][0] = 1786;
	par.ordArray_plate[2][1] = 32;
	*/	
	ordArray_OW[0] = par.ordArray_OW[0];
	ordArray_OW[1] = par.ordArray_OW[1];
	zwash_step4 = par.ordArray_wash[2];

		 par.load_motor1[0] = load_motor[0];
	 par.load_motor1[1] = load_motor[1] ;
	  par.load_motor2[0] = load_motor2[0];
	 par.load_motor2[1] = load_motor2[1];
	 par.load_motor3[0] = load_motor3[0];
	 par.load_motor3[1] = load_motor3[1];
	liquid_zmax = par.ordArray_reagent[0][2];


mb_setallpara();
	for(i = 0; i < 4;i++)
	{
		ordArray_wash[i][0] = par.ordArray_wash[0]  + i * WASH_DISTANCE;
		ordArray_wash[i][1] = par.ordArray_wash[1]; 
	}
	
	ordArray_mixed_DAB[0][0] = ordArray_wash[0][0] + MIX_WASH_DISTANCE;
//	ordArray_mixed_DAB[0][1] = ordArray_wash[0][1] - MIX_WASH_Y;
	ordArray_mixed_DAB[0][1] = 0;//初始化位置

	for(i = 0; i < 6;i++)
	{
		ordArray_mixed_DAB[i][0] = ordArray_mixed_DAB[0][0] + i * MIX_DISTANCE;
		ordArray_mixed_DAB[i][1] = ordArray_mixed_DAB[0][1];
	}
	
	
	
	for(i = 0; i < 9;i++)
	{
		ordArray_reagent[i][0] = par.ordArray_reagent[0][0];
		ordArray_reagent[i][1] = par.ordArray_reagent[0][1] + i * reagent_distance;

		ordArray_reagent[i + 9][0] = par.ordArray_reagent[1][0];
		ordArray_reagent[i + 9][1] = par.ordArray_reagent[1][1] + i * reagent_distance;
		
		ordArray_reagent[i + 18][0] = par.ordArray_reagent[2][0];
		ordArray_reagent[i + 18][1] = par.ordArray_reagent[2][1] + i * reagent_distance;

		ordArray_reagent[i + 27][0] = par.ordArray_reagent[3][0]; 
		ordArray_reagent[i + 27][1] = par.ordArray_reagent[3][1] + i * reagent_distance; 
	} 
	
	for(i = 0; i < 3;i++)
	{
		dispense_stepA[i] = par.ordArray_plate[i*3][2];	
		dispense_stepB[i]= par.ordArray_plate[i*3+1][2]; 
		dispense_stepC[i] = par.ordArray_plate[i*3+2][2];   
	}
	printf("dispense_stepA[0]=%d dispense_stepA[1]=%d dispense_stepA[2]=%d\n",
		dispense_stepA[0],dispense_stepA[1],dispense_stepA[2]);
	
		printf("dispense_stepC[0]=%d dispense_stepC[1]=%d dispense_stepC[2]=%d\n",
			dispense_stepC[0],dispense_stepC[1],dispense_stepC[2]);
#if 0
	ordArray_plate1[0][0] = par.ordArray_plate[0][0] - PULL_DISTANC_INIT;
		ordArray_plate1[10][0] = par.ordArray_plate[1][0] - PULL_DISTANC_INIT;
		ordArray_plate1[20][0] = par.ordArray_plate[2][0] - PULL_DISTANC_INIT;
		
		ordArray_plate1[0][1] = par.ordArray_plate[0][1];
		ordArray_plate1[10][1] = par.ordArray_plate[1][1];
		ordArray_plate1[20][1] = par.ordArray_plate[2][1];
			int stp_patch = 0;
	for (i = 1; i < 10; i++) 
	{
		if (i%3 == 0)
			stp_patch = 1;
		else
			stp_patch = 0;
		
		ordArray_plate1[i][0] = par.ordArray_plate[0][0] - PULL_DISTANC_INIT;
		ordArray_plate1[i][1] = ordArray_plate1[i-1][1] + slide_distance + stp_patch;
		printf("ordArray_plate1[%d][1]=%d\n",i,ordArray_plate1[i][1]);
		ordArray_plate1[i + 10][0] = par.ordArray_plate[1][0]  - PULL_DISTANC_INIT ;
		ordArray_plate1[i + 10][1] = ordArray_plate1[10 + i-1][1] +  slide_distance + stp_patch;

		ordArray_plate1[i + 20][0] = par.ordArray_plate[2][0]  - PULL_DISTANC_INIT ;
		ordArray_plate1[i + 20][1] = ordArray_plate1[20 + i-1][1] + slide_distance + stp_patch;
	}
	for(i = 0;i < 30;i++)	//拉伸位置
	{
		 
		ordArray_plate2[i][0] = ordArray_plate1[i][0] - PULL_DISTANC_LT;
		ordArray_plate3[i][0] = ordArray_plate1[i][0] - PULL_DISTANC_HALF;
		ordArray_plate4[i][0] = ordArray_plate1[i][0] - PULL_DISTANC_FULL;

		ordArray_plate2[i][1] = ordArray_plate1[i][1];
		ordArray_plate3[i][1] = ordArray_plate1[i][1];
		ordArray_plate4[i][1] = ordArray_plate1[i][1];
		 
	}
		
#else
	if (shelf_check[0][2] > 600)
		shelf_check[0][2] = 500;
	if (shelf_check[1][2] > 600)
		shelf_check[1][2] = 500;
		memcpy(shelf_check, par.shelf_check, 24);
		printf("shelf_check[0][2]=%d, shelf_check[1][2]=%d",shelf_check[0][2],shelf_check[1][2]);

		
		int correc_dec = (shelf_check[0][2] - shelf_check[1][2]) % 8;
		int correc_base = (shelf_check[0][2] - shelf_check[1][2]) / 8;
	{
		
		int correc_index1[8] = {3,1,5,2,4,0,6,7};// 余数为奇数分布
		int correc_index2[8] = {2,5,1,6,3,4,0,7};// 余数为偶数
		int correc_c[8] = {0};
		int *correc_p = NULL;
		int index = 0;
		if ((correc_dec % 2) == 1 || (correc_dec % 2) == -1)
			correc_p = correc_index1;
		else
			correc_p = correc_index2;
		
		for (index = 0; index < abs(correc_dec); index++)
		{
			if (correc_dec > 0)
				correc_c[ correc_p[index] ] = 1;
			else
				correc_c[ correc_p[index] ] = -1;
		}
	
		printf("correc_base=%d, correc_dec=%d\n", correc_base,correc_dec);
		CorrectDate[0] = correc_base;
		for (index = 0; index < 8; index++)
		{
			 CorrectDate[index + 1] = correc_base +correc_c[index] +  CorrectDate[index];
			
			 printf(" %d ",  CorrectDate[index]);
		}
	}

//	ordArray_plate1[9][0] = par.ordArray_plate[0][0] ;
//	ordArray_plate1[19][0] = par.ordArray_plate[1][0] ;
//	ordArray_plate1[29][0] = par.ordArray_plate[2][0] ;
	

	ordArray_plate1[0][0] = par.ordArray_plate[0][0] ;
	ordArray_plate1[10][0] = par.ordArray_plate[1][0] ;
	ordArray_plate1[20][0] = par.ordArray_plate[2][0] ;
	
 	ordArray_plate1[0][1] = par.ordArray_plate[0][1];
	ordArray_plate1[10][1] = par.ordArray_plate[1][1];
	ordArray_plate1[20][1] = par.ordArray_plate[2][1];

	ordArray_plate2[0][0] = par.ordArray_plate[3][0] ;
	ordArray_plate2[10][0] = par.ordArray_plate[4][0] ;
	ordArray_plate2[20][0] = par.ordArray_plate[5][0] ;
	
 	ordArray_plate2[0][1] = par.ordArray_plate[3][1];
	ordArray_plate2[10][1] = par.ordArray_plate[4][1];
	ordArray_plate2[20][1] = par.ordArray_plate[5][1];

	
	ordArray_plate3[0][0] = par.ordArray_plate[6][0] ;
	ordArray_plate3[10][0] = par.ordArray_plate[7][0] ;
	ordArray_plate3[20][0] = par.ordArray_plate[8][0] ;
	
 	ordArray_plate3[0][1] = par.ordArray_plate[6][1];
	ordArray_plate3[10][1] = par.ordArray_plate[7][1];
	ordArray_plate3[20][1] = par.ordArray_plate[8][1];
	
	ordArray_plate4[0][0] = par.ordArray_plate[0][0]  - PULL_DISTANC_FULL;
	ordArray_plate4[10][0] = par.ordArray_plate[1][0]  - PULL_DISTANC_FULL;
	ordArray_plate4[20][0] = par.ordArray_plate[2][0]  - PULL_DISTANC_FULL;
	
 	ordArray_plate4[0][1] = par.ordArray_plate[0][1];
	ordArray_plate4[10][1] = par.ordArray_plate[1][1];
	ordArray_plate4[20][1] = par.ordArray_plate[2][1];

printf("!!!!!!!!!!!!!!!!1ordArray_plate2[10][0]=%d ordArray_plate3[10][0]=%d\n\n",&ordArray_plate2[10][0],&ordArray_plate3[10][0]);
	int stp_patch = 0;
	for (i = 1; i < 10; i++) 
	{
		if (i%3 == 0)
			stp_patch = 1;
		else if (i%2 == 0)
			stp_patch = 1;
		else
			stp_patch = 0;
		
		ordArray_plate1[i][0] = par.ordArray_plate[0][0];
		ordArray_plate1[i][1] = ordArray_plate1[i-1][1] + slide_distance + stp_patch;
		
		ordArray_plate1[i + 10][0] = par.ordArray_plate[1][0] ;
		ordArray_plate1[i + 10][1] = ordArray_plate1[10 + i-1][1] +  slide_distance + stp_patch;

		ordArray_plate1[i + 20][0] = par.ordArray_plate[2][0] ;
		ordArray_plate1[i + 20][1] = ordArray_plate1[20 + i-1][1] + slide_distance + stp_patch;

		
		ordArray_plate2[i][0] = par.ordArray_plate[3][0];
		ordArray_plate2[i][1] = ordArray_plate2[i-1][1] + slide_distance + stp_patch;
		
		ordArray_plate2[i + 10][0] = par.ordArray_plate[4][0] ;
		ordArray_plate2[i + 10][1] = ordArray_plate2[10 + i-1][1] +  slide_distance + stp_patch;

		ordArray_plate2[i + 20][0] = par.ordArray_plate[5][0] ;
		ordArray_plate2[i + 20][1] = ordArray_plate2[20 + i-1][1] + slide_distance + stp_patch;

		ordArray_plate3[i][0] = par.ordArray_plate[6][0];
		ordArray_plate3[i][1] = ordArray_plate3[i-1][1] + slide_distance + stp_patch;
		
		ordArray_plate3[i + 10][0] = par.ordArray_plate[7][0] ;
		ordArray_plate3[i + 10][1] = ordArray_plate3[10 + i-1][1] +  slide_distance + stp_patch;

		ordArray_plate3[i + 20][0] = par.ordArray_plate[8][0] ;
		ordArray_plate3[i + 20][1] = ordArray_plate3[20 + i-1][1] + slide_distance + stp_patch;

		
		ordArray_plate4[i][0] = par.ordArray_plate[0][0] - PULL_DISTANC_FULL;
			ordArray_plate4[i][1] =ordArray_plate1[i][1];
			
			ordArray_plate4[i + 10][0] = par.ordArray_plate[1][0]  - PULL_DISTANC_FULL;
			ordArray_plate4[i + 10][1] = ordArray_plate1[i + 10][1];
		
			ordArray_plate4[i + 20][0] = par.ordArray_plate[2][0]  - PULL_DISTANC_FULL;
			ordArray_plate4[i + 20][1] =ordArray_plate1[i + 20][1];
	}

#endif

if (PRINTF)
{
	printf("shelf_check\n");
	for(i = 0; i < 2;i++)
		printf(" *%d %d %d* ", shelf_check[i][0],shelf_check[i][1],shelf_check[i][2]);
		printf("\nordArray_wash zwash_step4 = %d\n",zwash_step4);
		for(i = 0; i < 4;i++)
			printf(" *%d %d* ",ordArray_wash[i][0],ordArray_wash[i][1]);
		printf("(sizeof(ordArray_reagent)) / 4 = %d\n", (sizeof(ordArray_reagent)) / 4);
		printf("\nordArray_reagent liquid_zmax=%d\n",liquid_zmax);
		for (i = 0; i < 36; i++)
			printf(" *%d %d* ",ordArray_reagent[i][0],ordArray_reagent[i][1]);
	
		printf("\nordArray_plate1 dispense_stepA=%d,dispense_stepB=%d,dispense_stepC=%d\n",
			dispense_stepA,dispense_stepB,dispense_stepC);
		printf("ordArray_plate1\n");
		for (i = 0; i < 30; i++)
			printf(" *%d %d* ",ordArray_plate1[i][0],ordArray_plate1[i][1]);
			printf("ordArray_plate2\n");
		for (i = 0; i < 30; i++)
			printf(" *%d %d* ",ordArray_plate2[i][0],ordArray_plate2[i][1]);
		
		printf("ordArray_plate3\n");
		for (i = 0; i < 30; i++)	
			printf(" *%d %d* ",ordArray_plate3[i][0],ordArray_plate3[i][1]);
		
		printf("ordArray_plate4\n");
		for (i = 0; i < 30; i++)	
			printf(" *%d %d* ",ordArray_plate4[i][0],ordArray_plate4[i][1]);
		
	printf("load_motor[0]=%d load_motor[1]=%d load_motor2[0]=%d load_motor2[1]=%d load_motor3[0]=%d load_motor3[1]=%d\n" ,
		load_motor[0],load_motor[1],load_motor2[0],load_motor2[1],load_motor3[0],load_motor3[1]);
}
//	while(1);
	/*
	//如为miniboard的配置信息则发送给miniboard
	memset(minicmd_buffer,0,50);
	minicmd_buffer[3] = (unsigned char)MINI_CONFIG;//下面整型赋值要覆盖所以从3开始
	buffer_counter = 4;
	while(buffer_counter < 68)
	{	
		if (buffer_counter < 24)
			{
			*((int *)&minicmd_buffer[buffer_counter])=(load_motor[i]);
			i++;
			}
		else
			{
			*((int *)&minicmd_buffer[buffer_counter])=(arm_motor[j]);
			j++;
			}
		buffer_counter += 4;
		
		
	}
		
	minicmd_num = buffer_counter - 4 + 1;
	printf("minicmd_buffer=send_num=%d",minicmd_num);
	for (i = 0;i < 50; i++)
    	{
			printf(" %x " ,minicmd_buffer[i]);
		}
	printf("\n");
	mini_recieve_code = 0;
	pthread_mutex_lock(&mutex_mlock);
	set_minicmd(MINI_CONFIG);
	pthread_mutex_unlock(&mutex_mlock);
	*/
	
	rf_readstringfromeprofile("ReadtemperInfo","temp_sensor_type[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
	//	temp_sensor_type[i] = atoi(strtok_r(pstring, "|",&ptr));
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}
	rf_readstringfromeprofile("ReadtemperInfo","temp_SV_High[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_SV_High[i] = atoi(strtok_r(pstring, "|",&ptr));
		//temp_SV_High[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

	rf_readstringfromeprofile("ReadtemperInfo","temp_MV[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_MV[i] = atoi(strtok_r(pstring, "|",&ptr));	
	//	temp_MV[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}
	
	
	if(new_temper)
	{
	#if 1
		rf_readstringfromeprofile("ReadtemperInfo","temp_Input_Bias[60]",read_buffer,1000,NULL,(const char *)ppath);
		for (i = 0;i < 30;i++)
		{
			
			strcpy(pstring, read_buffer);
			temp_Dvalmy[i][72] = par.temp_Input_Bias[i] = atoi(strtok_r(pstring, "|",&ptr));	//参数中只存72°的修正值
			//temp_Dvalmy[i][72] = atoi(strtok_r(pstring, "|",&ptr));	
			
			for(j = 36;j < 72;j++)
			{
				if(temp_Dvalmy[i][72] < 0)
					{
				temp_Dvalmy[i][j] = (~temp_Dvalmy[i][72] + 1) *(j - 35) / 37;
				temp_Dvalmy[i][j] = ~temp_Dvalmy[i][j] + 1;
					}
				else
					temp_Dvalmy[i][j] = temp_Dvalmy[i][72] *(j - 35) / 37;
			}
			strcpy(pstring, read_buffer);
			strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
		}
		for (i = 0;i < 30;i++)
		{
			
			strcpy(pstring, read_buffer);
			temp_Dvalmy[i][100] =   par.temp_Input_Bias[i+30] = atoi(strtok_r(pstring, "|",&ptr));
		//	temp_Dvalmy[i][100] = atoi(strtok_r(pstring, "|",&ptr));

			for(ocnt=1;ocnt<5;ocnt++)
				temp_Dvalmy[i][100 + ocnt] = temp_Dvalmy[i][100];
			
			printf(" hh%d ",temp_Dvalmy[i][100] );
			cal_tmp = temp_Dvalmy[i][100] - temp_Dvalmy[i][72];
			printf("73cal_tmp = %d\n", cal_tmp);
			for(j = 73;j < 100;j++)
			{
			
			if(cal_tmp < 0)
				{
				temp_Dvalmy[i][j] =  (j - 72) * (~cal_tmp + 1) / 28;
				temp_Dvalmy[i][j] = ~temp_Dvalmy[i][j] + 1 + temp_Dvalmy[i][72];
				temp_setval[i][j + temp_Dvalmy[i][j]/10] = temp_Dvalmy[i][j];
				}
			else
				{
				temp_Dvalmy[i][j] = temp_Dvalmy[i][72] + (j - 72) * (cal_tmp) / 28;
				temp_setval[i][j - temp_Dvalmy[i][j]/10] = temp_Dvalmy[i][j];
				}
			
			
			}
			
			for(ocnt=1;ocnt<5;ocnt++)
				temp_setval[i][100 +ocnt] = temp_Dvalmy[i][100];
			
			strcpy(pstring, read_buffer);
			strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);

		}
	#endif	

	for(i = 35;i<105;i++)
	{
		printf(" %d-",temp_Dvalmy[20][i]);
		printf("%d ",temp_setval[20][i]);
	}
	}
	else
	{
		rf_readstringfromeprofile("ReadtemperInfo","temp_Input_Bias[30]",read_buffer,1000,NULL,(const char *)ppath);
		for (i = 0;i < 30;i++)
		{
			
			strcpy(pstring, read_buffer);
			par.temp_Input_Bias[i] = atoi(strtok_r(pstring, "|",&ptr));	
			
			//temp_Input_Bias[i] = atoi(strtok_r(pstring, "|",&ptr));	
			strcpy(pstring, read_buffer);
			strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
		}
	}
	rf_readstringfromeprofile("ReadtemperInfo","temp_Input_Filter[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_Input_Filter[i] = atoi(strtok_r(pstring, "|",&ptr));	
	//	temp_Input_Filter[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

	rf_readstringfromeprofile("ReadtemperInfo","temp_HeatingPro_Band[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_HeatingPro_Band[i] = atoi(strtok_r(pstring, "|",&ptr));	
		//temp_HeatingPro_Band[i] = atoi(strtok_r(pstring, "|",&ptr));			
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

	rf_readstringfromeprofile("ReadtemperInfo","temp_HeatingInt_Time[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_HeatingInt_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
	//	temp_HeatingInt_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

	rf_readstringfromeprofile("ReadtemperInfo","temp_HeatingDer_Time[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_HeatingDer_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
		//temp_HeatingDer_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}
	rf_readstringfromeprofile("ReadtemperInfo","temp_Heatingctl_Time[30]",read_buffer,1000,NULL,(const char *)ppath);
	for (i = 0;i < 30;i++)
	{
		strcpy(pstring, read_buffer);
		par.temp_Heatingctl_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
		//temp_Heatingctl_Time[i] = atoi(strtok_r(pstring, "|",&ptr));	
		strcpy(pstring, read_buffer);
		strcpy(read_buffer,&read_buffer[strlen(strtok_r(pstring, "|",&ptr)) + 1]);
	}

//	printf("sizeof(par) %d",sizeof(par));
//	for (i = 0 ; i < sizeof(par) / 4;i++)
//		printf(" %d ",*((int *)&par + i));


	
	printf("mb_readconfparatinfo finished \n");
	printf("\n");
}


void mb_readrunparainfo(void)
{
char a = 0, b= 0;
	door_open_action = rf_readintfromeprofile("mb_readconfparatinfo", "DOOR_OPEN_ACTION", -1, (const char *)MeasureConfigPath);
	printf("DOOR_OPEN_ACTION = %d\n",door_open_action);
	/***感应方式
	nor_wast_barrel = rf_readintfromeprofile("mb_readconfparatinfo", "NOR_WAST_BARREL", -1, (const char *)MeasureConfigPath);
	printf("NOR_WAST_BARREL = %d\n",nor_wast_barrel);
	*/
	a = rf_readintfromeprofile("mb_readconfparatinfo", "DNG_WAST_BARREL", -1, (const char *)MeasureConfigPath);
	nor_wast_barrel = a %2;
	dng_wast_barrel = a / 2;
	printf("NOR_WAST_BARREL= %d DNG_WAST_BARREL = %d\n",nor_wast_barrel, dng_wast_barrel);
	tem_over_load = rf_readintfromeprofile("mb_readconfparatinfo", "TEM_OVER_LOAD", -1, (const char *)MeasureConfigPath);
	printf("TEM_OVER_LOAD = %d\n",tem_over_load);
	tem_limit = rf_readintfromeprofile("mb_readconfparatinfo", "TEM_LIMIT", -1, (const char *)MeasureConfigPath);

	
	tem_limit *= 10;
	printf("TEM_LIMIT = %d\n",tem_limit);

}
void bs_writeconfiginfo(char* data)
	{
			printf("data= %d %d %d %d %d",data[0],data[1],data[2],data[3],data[4]);
			char data_tmp0[3],data_tmp1[3],data_tmp2[3],data_tmp3[3],data_tmp4[5];
	
			data[2] = data[2] * 2 + data[1];
				
			sprintf(data_tmp0, "%d",data[0]);
		//	sprintf(data_tmp1, "%d",data[1]);
			sprintf(data_tmp2, "%d",data[2]);
			sprintf(data_tmp3, "%d",data[3]);
			sprintf(data_tmp4, "%d",data[4]);
			rf_writeintforprofile("mb_readconfparatinfo", "DOOR_OPEN_ACTION",data_tmp0, (const char *)MeasureConfigPath, 0);
			
			//rf_writeintforprofile("mb_readconfparatinfo", "NOR_WAST_BARREL",data_tmp1, (const char *)MeasureConfigPath, 0);
			rf_writeintforprofile("mb_readconfparatinfo", "DNG_WAST_BARREL",data_tmp2, (const char *)MeasureConfigPath, 0);
			rf_writeintforprofile("mb_readconfparatinfo", "TEM_OVER_LOAD",data_tmp3, (const char *)MeasureConfigPath, 0);
			rf_writeintforprofile("mb_readconfparatinfo", "TEM_LIMIT",data_tmp4, (const char *)MeasureConfigPath, 0);
		
		}


/*************从PC端接受配置信息并写入文件**************/
/*
void bs_writeconfiginfo(void)
{

	char pstring[1000] = {0};
	char cmp_string[50] = {0};
	char fread_buffer[50]={0};
	BOOL ENDFILE = FALSE;
	char pchar;
	unsigned int x=0,y=0,i;
	int netread_len;
//	FILE * fp=NULL;
	int fp;

//	remove(MeasureConfigPath);
	if ((fp = open(MeasureConfigPath, O_RDWR|O_CREAT|O_TRUNC)) < 0)
				perror("open file error\n");
	while(!flg_mainproexit)						//读取网口命令
	{	
		memset(netbuf_read, 0, 10000);

		while(1)
		{
			if ((netread_len = read(local_fd, netbuf_read, 10000)) < 0)//要求pc端一个包不大于1000字节，一次为一张玻片的操作
			
			{
			//	perror("[bs_writeconfiginfo]read netdata error\n");
			}
			else if (netread_len == 1 && netbuf_read[0] == 0) //心跳数据
			{
			}
			else
				break;
			usleep(1000);
		}
		
		//else
		{
			printf("[bs_writeconfiginfo]netdata recieved\n");	//配置信息需使用字符串形式收发			
			printf("netread_len=%d netbuf_read=  \n", netread_len); 
			printf("\n");

			
			

			
		//	printf("fgetc(fp)=%c\n",fgetc(fp));
			for (i = 0; i < netread_len; i++)
			{
				printf("%c",netbuf_read[i]);
				
			}
			printf("fp=%d*************\n",fp);
			if (write(fp, netbuf_read,netread_len) < 0)	
					perror("write error\n");
				
			for (i = 10; i > 0 ;i--)			{
				if (netbuf_read[netread_len - i] == 'E' && 
					netbuf_read[netread_len - i + 1] == 'N' &&
					netbuf_read[netread_len - i + 2] == 'D')
				ENDFILE = TRUE;
			}
			
			printf(" END-%c %c %c",netbuf_read[netread_len - 5],
			netbuf_read[netread_len - 4],netbuf_read[netread_len - 3]);
		
			//if (strcmp(&netbuf_read[netread_len - 5],"END" ) != 0)	//end of the file
		//	if ( (netbuf_read[netread_len - 5] =='E') && (netbuf_read[netread_len - 4] =='N') 
		//		&& (netbuf_read[netread_len - 3] =='D') )	//end of the file
			if (ENDFILE)
			{
				close(fp);
				break;
			}
			else
				continue;

			printf("\n");
		}
			
	}
	printf("bs_writeconfiginfo finished\n");
}
*/
void bs_stanbywork(void)
{

	char commend_buffer[30][50] = {0};
		unsigned int commandNumbers = 0;
	unsigned int i = 0,cnt = 0;
	char string[64];
	char str[64];
	char last_perfusion_port = 0; //主臂
	char last_perfusion_port1 = 0;//自控臂1
	char last_perfusion_port2 = 0;
	char last_perfusion_port3 = 0;
	stminibd_cmdlist* pcmd_head_p = NULL;
	stminibd_sendpacket cmd;

	printf("in ReadStanbyInfo\n");
	commandNumbers = rf_readintfromeprofile("stanby device", "COMMAND_NUMBERS", -1, (const char *)g_szConfigPath);
	memset(string, '\0', sizeof(string));
	rf_readstringfromeprofile("stanby device", (const char *) "COMMAND_STRING", string, 64, NULL, (const char *) g_szConfigPath);
		assert(string != NULL);

		printf("commandNumbers=%d\n",commandNumbers);
		printf("\n");
	for (i = 0; i < commandNumbers; i++)
		{
			memset(commend_buffer, '\0', sizeof(commend_buffer));
			memset(str, '\0', sizeof(str));
			
			sprintf(str, "%s%d", string, i+1);
			if (!rf_readstringfromeprofile("stanby device", 
				(const char *)str, &commend_buffer[i][0], 50, NULL, (const char *)g_szConfigPath)) {
				continue;
			}
		
			printf("str=%s\n",str);
			printf("&commend_buffer[i][0]=%s\n",&commend_buffer[i][0]);		
			memset(str, '\0', sizeof(str));
			
		}
	printf("ReadStanbyInfo finished\n");
	printf("\n");

	
	while( cnt < commandNumbers )
	{
		if (cnt < 6)	//区分自控臂的灌注操作
				pcmd_head_p = pcmd_head;
			else if (cnt >= 6 && cnt < 12)
				pcmd_head_p = pcmd_head2;
			else if (cnt >= 12 && cnt < 18)
				pcmd_head_p = pcmd_head3;
			
			if (strcmp("PERFUSIONDEWAX", commend_buffer[cnt]) == 0){

				printf("***************in PERFUSIONDEWAX**************\n");
					last_perfusion_port = DEWAXPORT;
			}
	
			if (strcmp("PERFUSIONALCOHOL", commend_buffer[cnt]) == 0){

				printf("***************in PERFUSIONALCOHOL**************\n");
					last_perfusion_port = ALCOHOLPORT;
			}
			if (strcmp("PERFUSIONER1", commend_buffer[cnt]) == 0){

				printf("***************in PERFUSIONER1**************\n");
					last_perfusion_port = ER1PORT;	
			}
			if (strcmp("PERFUSIONER2", commend_buffer[cnt]) == 0){

				printf("***************in PERFUSIONER2**************\n");
					last_perfusion_port = ER2PORT;
			}
			if (strcmp("PERFUSIONWASH", commend_buffer[cnt]) == 0){
				printf("***************in PERFUSIONWASH**************\n");
					last_perfusion_port = WASHPORT;		
			}
			if (strcmp("PERFUSIONWATER", commend_buffer[cnt]) == 0){
			//	break;
				printf("***************in PERFUSIONWATER**************\n");
					last_perfusion_port = WATERPORT;
			}
			if (strcmp("ASPIRATELIQUID", commend_buffer[cnt]) == 0){
				 printf("***************in ASPIRATELIQUID**************\n");
		//		mb_dischargeshelfwateliquid(1);
		//		mb_dischargeshelfwateliquid(2);
		//		mb_dischargeshelfwateliquid(3);
		//		mb_dischargeshelfwateliquid(4);
			
			}

		commend_buffer[cnt][9] = '\0';
		if (strcmp("PERFUSION", commend_buffer[cnt]) == 0)
		{
				if (cnt >= 18)
				{	
					tp_washchange(TRUE);
					last_perfusion_port = WATERPORT;
					if (last_perfusion_port == WATERPORT || last_perfusion_port == WASHPORT)
					{
						if (!mb_waterwashreagentpour(last_perfusion_port))
						{
							if (last_perfusion_port == WATERPORT)
								mb_seterrorcode(WATERPOUR_WRONG);
							else if (last_perfusion_port == WASHPORT)
								mb_seterrorcode(WASHPOUR_WRONG);
						}
					}
		
					else
					{
						if (!mb_muiltreagentpour(last_perfusion_port))
						{
							if (last_perfusion_port == ALCOHOLPORT)
								mb_seterrorcode(ALCOHOLPOUR_WRONG);
							else if (last_perfusion_port == DEWAXPORT)
								mb_seterrorcode(DEWAXPOUR_WRONG);	
							else if (last_perfusion_port == ER1PORT)
								mb_seterrorcode(ER1POUR_WRONG);
							else if (last_perfusion_port == ER2PORT)
								mb_seterrorcode(ER2POUR_WRONG);
						}
					}
					tp_washchange(FALSE);
				}
				else
				{
				
				}
		}
		
		
		
		
		cnt++;
	}
					
	//	mb_dischargwateliquid_lo();
	//	mb_dischwasteliquid_hi();

	printf("out of bs_stanbywork********************\n");
}

int mb_mainarmcmd2(const char * cmp_str)
{
	ejobid secend_cmd = cmp_str[0], last_secend_cmd = 0;
	sr_cmdstruct_t CommandElemt;

	static  int X_coordinate, Y_coordinate, Z_coordinate;
	static unsigned char station_num = 0;
	static unsigned int* ordArray_p = NULL;
	unsigned int (*postion_p)[2];
	static unsigned int* Z_ordArray_p = NULL;
	char str[20] = {0};
	static char save_ps = 0;
	unsigned int offset = 0;
	char data_tmp[10];
	unsigned int* dispense_step_p = dispense_stepA;
	
	const char ps_str[6][30] = {"ordArray_wash[3]","ordArray_reagent[4][3]",
								"ordArray_plate[9][3]","ordArray_OW[3]","shelf_check[2][3]","LIQUID_SPEED"};  

	printf("cmp_str[1] = %d ordArray_plate1[][]=%d\n", cmp_str[1],ordArray_plate1[0][0]);
	
	printf("dispense_step_p = %d %d\n", dispense_step_p[1],dispense_step_p[2]);
	switch (secend_cmd)
	{
		case SHELF:
		{
		
			if (cmp_str[1]%30 < 10)
				Z_ordArray_p  = &dispense_stepA[cmp_str[1]/30];
			else if (cmp_str[1]%30 < 20)
				Z_ordArray_p  = &dispense_stepB[cmp_str[1]/30];
			else if (cmp_str[1]%30 < 30)
				Z_ordArray_p  = &dispense_stepC[cmp_str[1]/30];

			CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

			if (cmp_str[1] < 30)		
				postion_p = ordArray_plate1;
			else if (cmp_str[1] < 60)		
				postion_p = ordArray_plate2;
			else if (cmp_str[1] < 90)		
				postion_p = ordArray_plate3;

			ordArray_p = &postion_p[cmp_str[1]][0];	//save the pointer for MIAN_SAVE cmd
			printf("befor ordArray_p=%d\n",ordArray_p);
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",postion_p[cmp_str[1]%30][0],
					postion_p[cmp_str[1]%30][1] + 2082, 0);
			X_coordinate = postion_p[cmp_str[1]%30][0];	//save the last coordinate 
			Y_coordinate = postion_p[cmp_str[1]%30][1] + 2082;
			Z_coordinate = *Z_ordArray_p;
			station_num = cmp_str[1] / 10;
			printf("original X=%d Y=%d Z=%d\n",X_coordinate, Y_coordinate,Z_coordinate);
			save_ps = 2;
			break;
		}
		case REAGENT_STAION:
		{
			CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
			Z_ordArray_p = &liquid_zmax;
			ordArray_p = &ordArray_reagent[cmp_str[1]][0];
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_reagent[cmp_str[1]][0],
					ordArray_reagent[cmp_str[1]][1], 0);
			X_coordinate = ordArray_reagent[cmp_str[1]][0];	//save the last coordinate 
			Y_coordinate = ordArray_reagent[cmp_str[1]][1];
			Z_coordinate = *Z_ordArray_p;
			station_num = cmp_str[1] / 9;
			save_ps = 1;
			break;
		}
		case MIX_STATION:
		{
			break;
			Z_ordArray_p = &DAB_zmax;
			ordArray_p = &ordArray_mixed_DAB[cmp_str[1]][0];
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_mixed_DAB[cmp_str[1]][0],
					ordArray_mixed_DAB[cmp_str[1]][1], 0);
			X_coordinate = ordArray_mixed_DAB[cmp_str[1]][0];	//save the last coordinate 
			Y_coordinate = ordArray_mixed_DAB[cmp_str[1]][1];
			Z_coordinate = *Z_ordArray_p;
			station_num = cmp_str[1];
			break;
		}
		case CLEAR_STATION:
		{
			CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
			Z_ordArray_p = &zwash_step4;//take NO.4 clearstation as standard
			ordArray_p = &ordArray_wash[WASH4][0];
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_wash[WASH4][0],
					ordArray_wash[WASH4][1], 0);
			X_coordinate = ordArray_wash[WASH4][0];	//save the last coordinate 
			Y_coordinate = ordArray_wash[WASH4][1];
			Z_coordinate = *Z_ordArray_p;
			station_num = 0;
			save_ps = 0;
			break;
		}		
		case MAIN_X:
		{
			if (cmp_str[1] == 0)
				X_coordinate -= MAINTIAN_MAIN_INCREMENT;
			else
				X_coordinate += MAINTIAN_MAIN_INCREMENT;
			sprintf(CommandElemt.cmdbuf, "XA %d",X_coordinate);
			break;
		}
		case MAIN_Y:
		{
			if (cmp_str[1] == 0)
				Y_coordinate -= MAINTIAN_MAIN_INCREMENT;
			else
				Y_coordinate += MAINTIAN_MAIN_INCREMENT;
			
			sprintf(CommandElemt.cmdbuf, "YA %d",Y_coordinate);
			break;
		}
		case MAIN_Z:
		{
			if (cmp_str[1] == 0)
				Z_coordinate -= MAINTIAN_MAIN_INCREMENT;
			else
				Z_coordinate += MAINTIAN_MAIN_INCREMENT;

			sprintf(CommandElemt.cmdbuf, "ZA %d",Z_coordinate);
			break;
		}
		case RELEASE:
		{
			CommandElemt.srdevaddr = ARM_ADDR;	
				sprintf(CommandElemt.cmdbuf, "ZD");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			break;
		}
		case MAIN_INIT:
		{
			sprintf(CommandElemt.cmdbuf, "PI");
		//	station_num = 0;
			break;
		}		
		case INIT_SET:
		{
			X_coordinate = cmp_str[1];
			Y_coordinate = cmp_str[2];
				CommandElemt.srdevaddr = ARM_ADDR;	
				sprintf(CommandElemt.cmdbuf, "OX %d", X_coordinate);
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
				sb_waitingframeaswer(&CommandElemt);

				sprintf(CommandElemt.cmdbuf, "OY %d", Y_coordinate);
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
				sb_waitingframeaswer(&CommandElemt);

				sprintf(CommandElemt.cmdbuf, "OZ %d", Z_OFFSET);
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
				sb_waitingframeaswer(&CommandElemt);
				
				sprintf(CommandElemt.cmdbuf, "OW");
				printf("cmdbuf=%s\n", CommandElemt.cmdbuf);
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
				printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
				sb_waitingframeaswer(&CommandElemt);
				save_ps = 3;
				station_num = 0;
				sprintf(str, "%d %d %d",X_coordinate, Y_coordinate, 0);
				rf_writeintforprofile("ReadCoordinateInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,station_num);
				
 
				return 0;			
		}
		case MIAN_SAVE: 
		{
		printf("last_secend_cmd=%d, save_ps=%d\n", last_secend_cmd, save_ps);
		
			 if( last_secend_cmd == MAIN_INIT)
				break;

			 if (save_ps == 5)
			{

		
			sprintf(data_tmp, "%d",X_coordinate);	
			rf_writeintforprofile("mb_readconfparatinfo", "LIQUID_SPEED",data_tmp, (const char *)MeasureConfigPath, 0);
				
				scanoffset = X_coordinate - 350;
				
			break;
			}

			 
			if ((save_ps == 0 && ordArray_p == 0) || (save_ps == 3))	//直接点保存
				break;

	if (save_ps == 2)
			Y_coordinate -= 2082;
			
			printf("MIAN_SAVE station_num=%d\n",station_num);
			if (X_coordinate < 0) X_coordinate = 0;			if (Y_coordinate < 0) Y_coordinate = 0;			if (Z_coordinate < 0) Z_coordinate = 0;			
			//	*ordArray_p = X_coordinate;
			//	*(ordArray_p + 1) = Y_coordinate;
			//	*Z_ordArray_p = Z_coordinate;
			
			sprintf(str, "%d %d %d",X_coordinate, Y_coordinate, Z_coordinate);
			rf_writeintforprofile("ReadCoordinateInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,station_num);			
			break;
		}
		case SCANER:
		{
			sc_getscode(0XFF,FALSE);
			break;
		}
		case SHELF_CHECK:
		{
			
			printf("cmp_str[1]=%d\n",cmp_str[1]);
			CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			printf("$%d %d %d$",shelf_check[0][0],shelf_check[0][1],shelf_check[0][2]);
			printf("$%d %d %d$",shelf_check[1][0],shelf_check[1][1],shelf_check[1][2]);
			Z_ordArray_p = &shelf_check[cmp_str[1]][2];
			ordArray_p = &shelf_check[cmp_str[1]][0];
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",shelf_check[cmp_str[1]][0],
					shelf_check[cmp_str[1]][1], shelf_check[cmp_str[1]][2]);
			X_coordinate = shelf_check[cmp_str[1]][0];	//save the last coordinate 
			Y_coordinate = shelf_check[cmp_str[1]][1];
			Z_coordinate = *Z_ordArray_p;
			station_num = cmp_str[1];
			save_ps = 4;
			
				
			break;
		}
		case SHELF_SCAN:
		{
			if (new_scaner)
				offset = SCAN_OFFSET;
			
			
				CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

		X_coordinate = 350 + scanoffset ;
		save_ps = 5;
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d",X_coordinate,
					ordArray_plate1[0][1] + 2082, MOV_ZH);
			
			break;
		}

		case Z_DOWN:
		{
			sprintf(CommandElemt.cmdbuf, "ZA %d",Z_coordinate);
			break;
		}
		
		default:break;
	}

	last_secend_cmd = secend_cmd;
#if 1
			if (secend_cmd != MIAN_SAVE && secend_cmd != RELEASE && secend_cmd != SCANER )
				{
				CommandElemt.srdevaddr = ARM_ADDR;	
				printf("cmdbuf=%s\n", CommandElemt.cmdbuf);

						if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
						printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					
					sb_waitingframeaswer(&CommandElemt);
			}
#endif		
	return 0;
}

int mb_actionmainarm(const char * cmp_str)
{
	eselfact secend_cmd = cmp_str[0];
	static  short X_coordinate, Y_coordinate, Z_coordinate;
	static unsigned char station_num = 0, lastarmsel=0;
	static unsigned int* ordArray_p = NULL;
	char str[20] = {0};
	
	printf("cmp_str[0]=%d cmp_str[1]=%d\n",cmp_str[0],cmp_str[1]);

	//部件校准自控臂必须初始化完成
	if(cmp_str[0] <= SELFC)
	{
		
		
			if(cmp_str[0] == 0)
				{
			ordArray_p = &arm_motor[cmp_str[1]];
			Y_coordinate = arm_motor[cmp_str[1]];
				}
			else if(cmp_str[0] == 1)
				{
			ordArray_p = &arm_motor2[cmp_str[1]];
			Y_coordinate = arm_motor2[cmp_str[1]];
				}
			else if(cmp_str[0] == 2)
				{
			ordArray_p = &arm_motor2[cmp_str[1]];
			Y_coordinate = arm_motor2[cmp_str[1]];
				}

			station_num = cmp_str[1] - 1;//保存的是后3个位置
			lastarmsel = cmp_str[0];
			
			ArmCabinCmdList[cmp_str[0]].dispense_pos = 20;//固定值
			ArmCabinCmdList[cmp_str[0]].pos_datalo = Y_coordinate&0XFF;
			ArmCabinCmdList[cmp_str[0]].pos_datahi = Y_coordinate>>8;
			ArmCabinCmdList[cmp_str[0]].cmd = ArmCabinArm;
		
		
		
	}
	else if(cmp_str[0] <= SELFCY)
	{
		if(cmp_str[1] == 1)
			Y_coordinate += 10;  
		else
			Y_coordinate -= 10;  
		
		ArmCabinCmdList[cmp_str[0] - 3].dispense_pos = 20;//固定值
			ArmCabinCmdList[cmp_str[0] - 3].pos_datalo = Y_coordinate&0XFF;
			ArmCabinCmdList[cmp_str[0] - 3].pos_datahi = Y_coordinate>>8;
			ArmCabinCmdList[cmp_str[0] - 3].cmd = ArmCabinArm;
	}
	else if(SELF_SAVE == secend_cmd)
	{
		*ordArray_p = Y_coordinate;
		sprintf(str, "%d", Y_coordinate);
		if(lastarmsel == SELFA)
			rf_writeintforprofile("ReadMiniboardInfo", "arm_motor1", str, (const char *)MeasureConfigPath, station_num);
		else if(lastarmsel == SELFB)
			rf_writeintforprofile("ReadMiniboardInfo", "arm_motor2", str, (const char *)MeasureConfigPath, station_num);
		else if(lastarmsel == SELFC)
			rf_writeintforprofile("ReadMiniboardInfo", "arm_motor3", str, (const char *)MeasureConfigPath, station_num);
	}
	
			
	return 0;
}

int mb_actionstrech(const char * cmp_str)
#ifdef BIG_VERSION
{
	printf("cmp_str[0]=%d cmp_str[1]=%d\n",cmp_str[0],cmp_str[1]);
	if(cmp_str[1] == 0)
		{
	ArmCabinCmdList[cmp_str[0]].cmd = ArmCabinKey;
		}
	else
	{
		ArmCabinCmdList[cmp_str[0]].dispense_pos = cmp_str[1] - 1;
		ArmCabinCmdList[cmp_str[0]].cmd = ArmCabinLoadMotor;
	}
	
	
	return 0;
}

#else
{
	estrechid secend_cmd = cmp_str[0];
	stminibd_sendpacket em_minicmd;
	unsigned int value;;
	char str[20] = {0};
	void* lock = NULL;
	stminibd_cmdlist* p_head = NULL;
	static char save_ps = 0;
	const char ps_str[3][30] = {"load_motor1","load_motor2","load_motor3"};  
	sr_cmdstruct_t CommandElemt;

	memset(&em_minicmd,0,sizeof(em_minicmd));

	if (cmp_str[1] < 1)
	{
		
		em_minicmd.cmd = RELOAD;
		em_minicmd.minicmd_buffer[3] = (unsigned char)RELOAD;
		em_minicmd.minicmd_num=2;

			
	}
	else
	{	
		em_minicmd.cmd = STRETCH;
		em_minicmd.minicmd_buffer[3] = (unsigned char)STRETCH;	
		em_minicmd.minicmd_buffer[5] = cmp_str[1] - 1;	
//if (cmp_str[1] == 1)
//	em_minicmd.minicmd_buffer[5] = 0;
		em_minicmd.minicmd_num=3;
/*
	if (cmp_str[1] == 1)
		em_minicmd.minicmd_buffer[5] = 2;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_plate3[secend_cmd * 10][0],
					ordArray_plate3[secend_cmd * 10][1], 0);
	
	CommandElemt.srdevaddr = ARM_ADDR;	
				printf("cmdbuf=%s\n", CommandElemt.cmdbuf);

						if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
						printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					
					sb_waitingframeaswer(&CommandElemt);
	*/
	}


	em_minicmd.minicmd_buffer[4] = secend_cmd + 1;
	
	pthread_mutex_lock(&mutex_mlock);
	set_minicmd(pcmd_head,em_minicmd);
	pthread_mutex_unlock(&mutex_mlock);
				
	return 0;
}
#endif

/*
void SetCabinValueZero()
{
char i=0;
for(i=0;i<6;i++)
{
	sprintf(str, "%d", bigcabin_value[i]);
	rf_writeintforprofile("ReadCoordinateInfo", "reagent_cabin_zero[6]",str, (const char *)MeasureConfigPath,i);			
}

}
*/

int mb_actionpump(const char * cmp_str)
{
	PUMP_T secend_cmd = cmp_str[0];
	sr_cmdstruct_t CommandElemt;
	char str[20] = {0};
	stminibd_sendpacket em_minicmd;
	 int value = 0;
	static int lastvalue = 0;
	static char last_portsel=0;
	static PUMP_T last_secend_cmd = 0;
	int spd = 0;
	char sendbuf[5] = {0};
	memset(&em_minicmd,0,sizeof(em_minicmd));
	em_minicmd.cmd = PUMP_TEST;
	em_minicmd.minicmd_buffer[3] = (unsigned char)PUMP_TEST;
	em_minicmd.minicmd_num=11;
	printf("cmp_str[0]=%d cmp_str[2]=%d cmp_str[3]=%d cmp_str[4]=%d cmp_str[5]=%d",cmp_str[0], cmp_str[2],cmp_str[3],cmp_str[4],cmp_str[5]);
	memcpy(&value, &cmp_str[2], 4);
if (SELF_PUMP)
{
	value = value * SYFSTEP / 1000;
	if(secend_cmd == PUMPA)
		CutoffSpeedChange(SYSCUTOFF_SPEED);

//value = value * 6805 / 1000;
}
else
	value *= 6;  
//CutoffSpeedChange(SYSCUTOFF_SPEED);


//	CutoffSpeedChange(2000);
	//		DispenseSpeedChange(200);
			

		
		if(secend_cmd == PUMPA)
		{
			CommandElemt.srdevaddr = PUMP_ADDR;
		//	printf("enter spd\n");
		//	scanf("%d",&spd);
if (SELF_PUMP)
		sprintf(str, "S%dO%dA%dR", SYSPEED,cmp_str[1], value);
else
			sprintf(str, "S%dO%dA%dR", SYSPEED,cmp_str[1] + 1, value);

				strcpy(CommandElemt.cmdbuf, str);
				printf("cmdbuf=%s\n", CommandElemt.cmdbuf);
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
			
		}
		else if(secend_cmd <= PUMPD)
			{
			printf("last_secend_cmd=%d secend_cmd=%d last_portsel=%d cmp_str[1]=%d ",
				last_secend_cmd, secend_cmd, last_portsel,cmp_str[1]);
				if (!(last_secend_cmd == secend_cmd && last_portsel == cmp_str[1]))
				{
					ArmCabinCmdList[cmp_str[0] -1].reagent_sel = cmp_str[1];
					ArmCabinCmdList[cmp_str[0] -1].cmd = ArmCabinPumpValve;
				}	
				else//一次肯定控制阀或者控制注射器，二选一
				{
					if (!(last_secend_cmd == secend_cmd && lastvalue == value))
					ArmCabinCmdList[cmp_str[0] -1].pos_datalo = value&0XFF;
					ArmCabinCmdList[cmp_str[0] -1].pos_datahi = value>>8;
					ArmCabinCmdList[cmp_str[0] -1].cmd = ArmCabinPumpSy;
				}
				sleep(1);
			while(!ArmCabinWork_finished[cmp_str[0] -1])
				usleep(100000);
				lastvalue = value;
				last_portsel = cmp_str[1];
				last_secend_cmd =  cmp_str[0];
			}
	
		else if(secend_cmd == PUMP_INITA) 
		{
			CommandElemt.srdevaddr = PUMP_ADDR;
			strcpy(CommandElemt.cmdbuf,"ZR");
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		}
		else if(secend_cmd <= PUMP_INITD) 
		{
			ArmCabinCmdList[cmp_str[0] -PUMP_INITA - 1].reagent_sel = 20;
				ArmCabinCmdList[cmp_str[0] -PUMP_INITA - 1].cmd = ArmCabinPumpValve;

				sleep(1);
			while(!ArmCabinWork_finished[cmp_str[0] -PUMP_INITA - 1])
				usleep(100000);
						
		}
	sendbuf[0] = 4;
		sendbuf[1] = 1;
		nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);


	return 0;
}

int mb_actionother(const char * cmp_str)
{
	OTHER_T secend_cmd = cmp_str[0];
	int (*GPIO_work)(unsigned int);
	stminibd_sendpacket em_minicmd;
	char tstchar[20] = {0};
	char str[20] = {0};

	printf("cmp_str[1]=%d\n", cmp_str[1]);
	
	if(secend_cmd == MAINTAIN_SETZERO)
	//	if (secend_cmd == MAINTIAN_V1)
	{
		sprintf(str, "%d", bigcabin_value_init[cmp_str[1]]);
		rf_writeintforprofile("mb_readconfparatinfo", "reagent_cabin_zero[6]", str, (const char *)MeasureConfigPath, cmp_str[1]);
		reagent_cabin_zero[cmp_str[1]] = bigcabin_value_init[cmp_str[1]];
	}
	else if(secend_cmd == MAINTAIN_SETFULL)
	//else	if (secend_cmd == MAINTIAN_V2)
	{
		sprintf(str, "%d", bigcabin_value_init[cmp_str[1]]);
		rf_writeintforprofile("mb_readconfparatinfo", "reagent_cabin_full[6]", str, (const char *)MeasureConfigPath, cmp_str[1]);
		reagent_cabin_full[cmp_str[1]] = bigcabin_value_init[cmp_str[1]];
	}
	
	if (secend_cmd <= MAINTIAN_VP1 || secend_cmd == MAINTIAN_BEEP)
	{
		if (cmp_str[1] == 0)
			GPIO_work = GPIO_OutClear;
		else
			GPIO_work = GPIO_OutSet;		

		if (secend_cmd == MAINTIAN_V1) GPIO_work(V1);
		else if (secend_cmd == MAINTIAN_V2) GPIO_work(V2);
		else if (secend_cmd == MAINTIAN_V3) GPIO_work(V3);
		else if (secend_cmd == MAINTIAN_V4) GPIO_work(V4);
		else if (secend_cmd == MAINTIAN_V5) GPIO_work(V5);
		else if (secend_cmd == MAINTIAN_V6) GPIO_work(V6);
		else if (secend_cmd == MAINTIAN_V7) GPIO_work(V7);
		else if (secend_cmd == MAINTIAN_V8) GPIO_work(V8);
		else if (secend_cmd == MAINTIAN_V9) GPIO_work(V9);
		#ifdef BIG_VERSION
		else if (secend_cmd == MAINTIAN_V10) GPIO_work(V10);
		#endif
		
		else if (secend_cmd == MAINTIAN_VP1) GPIO_work(VP1);
		else if (secend_cmd == MAINTIAN_BEEP) GPIO_work(BEEPER);
		
	}
/*	else if (secend_cmd == MAINTIAN_P10)
	{
		pthread_mutex_lock(&mutex_tempotherlock);
		if (cmp_str[1]  == 0)
			mb_waterctrl(port_pump,WATER_PUMP_STOP);
		else
			mb_waterctrl(port_pump,WATER_PUMP_WORK);
		pthread_mutex_unlock(&mutex_tempotherlock);
	}
	else if (secend_cmd == MAINTIAN_P11)
	{
		
		pthread_mutex_lock(&mutex_tempotherlock);
		if (cmp_str[1] == 0)
			mb_waterctrl(port_pump,WATER_V_STOP);
		else
			mb_waterctrl(port_pump,WATER_V_WORK);
		pthread_mutex_unlock(&mutex_tempotherlock);
	}
*/	else if (secend_cmd <= MAINTIAN_FANC)
	{
	
		#ifdef BIG_VERSION
		/*
		tstchar[0] = PUMP;
		tstchar[1] =PUMPB;
		tstchar[2] =5;
		tstchar[3] = 100;
		mb_menualwork(tstchar);
		return 0;
		*/
		if(cmp_str[1])
			ArmCabinCmdList[secend_cmd - MAINTIAN_FANA].cmd = ArmCabinFANON ;
		else
			ArmCabinCmdList[secend_cmd - MAINTIAN_FANA].cmd = ArmCabinFANOFF ;
		#else
		memset(&em_minicmd,0,sizeof(em_minicmd));
		em_minicmd.cmd = MAINTAIN_FAN_WORK;
		em_minicmd.minicmd_buffer[3] = (unsigned char)MAINTAIN_FAN_WORK;
		if (cmp_str[1] == 1)
		em_minicmd.minicmd_buffer[4] = 0;// ON
		else
		em_minicmd.minicmd_buffer[4] = 3; //OFF
		
		em_minicmd.minicmd_num=2;
		if (secend_cmd == MAINTIAN_FANA)
		{
			em_minicmd.minicmd_buffer[4] += 1;
		}
		else if (secend_cmd == MAINTIAN_FANB)
		{
			em_minicmd.minicmd_buffer[4] += 2;
		}
		else if (secend_cmd == MAINTIAN_FANC)
		{
			em_minicmd.minicmd_buffer[4] += 3;
		}
		pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,em_minicmd);	
			pthread_mutex_unlock(&mutex_mlock);
		#endif
	}
	
	return 0;
}

int mb_actionotemper(const char * cmp_str)
{
	sttemper_frame temcmd;
	unsigned int plate_num,i,j;
	int cal_tmp = 0;
	unsigned int tem_cmd_counter=0;
	emtc_opcmds cmd_type;
	unsigned int interval=0;
	char str[20] = {0};
	static char save_ps = 0;
	const char ps_str[8][30] = {"temp_SV_High[30]","temp_MV[30]","temp_Input_Bias[30]","temp_Input_Filter[30]",
								"temp_HeatingPro_Band[30]","temp_HeatingInt_Time[30]","temp_HeatingDer_Time[30]",
								"temp_Heatingctl_Time[30]"};  
	short wtemvalue = 0,rtemvalue;
	emTermper_cmdtype cmdmy = 0;
	
				plate_num = cmp_str[0];

				cmd_type = cmp_str[1];
				if (CH1_SV_High == cmd_type)
					save_ps = 0;
				else if (CH1_MV_High == cmd_type)
					save_ps = 1;
				else if (CH1_Input_Bias == cmd_type)
					save_ps = 2;
				else if (CH1_Input_Filter == cmd_type)
					save_ps = 3;
				else if (CH1_HeatingPro_Band == cmd_type)
					save_ps = 4;
				else if (CH1_HeatingInt_Time == cmd_type)
					save_ps = 5;
				else if (CH1_HeatingDer_Time == cmd_type)
					save_ps = 6;
				else if (CH1_Heatingctl_Time == cmd_type)
					save_ps = 7;
				//自己温控器校准方式，默认35°温差为0，校准72和100°输入温差值，35到72，72到100做线性插补
	if (new_temper)
	{
	strcpy( &ps_str[2][0],"temp_Input_Bias[60]");
		wtemvalue = *((int*)&cmp_str[2]);
		
		switch(cmd_type)
		{
			case CH1_SV:
			{
				cmdmy = SET;
				break;
			}
			case CH1_Present_Value:
			{
				cmdmy = CUR1;
				break;
			}
			case CH1_HeatingPro_Band:
			{
				cmdmy = KP;
				break;
			}
			case CH1_HeatingInt_Time:
			{
				cmdmy = TI;
				break;
			}
			case CH1_HeatingDer_Time:
			{
				cmdmy = TD;
				break;
			}
			case CH1_Input_Bias:
			{
				cmdmy = BIAS;
				break;
			}
			case CH1_Heatingctl_Time:
			{
				cmdmy = Tsam;
				break;
			}
			 default:break;
		}
		

	printf("cmd_type = %d value = %d, last_tmper=%d\n",cmd_type,wtemvalue,last_tmper[plate_num]);
			if ((cmd_type != CH1_SV))
			{				
				sprintf(str, "%d",wtemvalue);
				
					if(cmd_type == CH1_Input_Bias)
					{
						if( last_tmper[plate_num] == 720)
						{
							temp_Dvalmy[plate_num][72] = (int)wtemvalue;
							for(j = 36;j < 72;j++)
							{
								if(temp_Dvalmy[plate_num][72] < 0)
									{
								temp_Dvalmy[plate_num][j] = (~temp_Dvalmy[plate_num][72] + 1) *(j - 35) / 37;
								temp_Dvalmy[plate_num][j] = ~temp_Dvalmy[plate_num][j] + 1;
									}
								else
									temp_Dvalmy[plate_num][j] = temp_Dvalmy[plate_num][72] *(j - 35) / 37;
								printf(" %d ",temp_Dvalmy[plate_num][j]);
							}
							cal_tmp = temp_Dvalmy[plate_num][100] - temp_Dvalmy[plate_num][72];
							printf("73cal_tmp = %d\n", cal_tmp);
							for(j = 73;j < 100;j++)
							{
							
							if(cal_tmp < 0)
								{
								temp_Dvalmy[plate_num][j] =  (j - 72) * (~cal_tmp + 1) / 28;
								temp_Dvalmy[plate_num][j] = ~temp_Dvalmy[plate_num][j] + 1 + temp_Dvalmy[plate_num][72];
								}
							else
								temp_Dvalmy[plate_num][j] = temp_Dvalmy[plate_num][72] + (j - 72) * (cal_tmp) / 28;
							printf(" %d ",temp_Dvalmy[plate_num][j]);
							}
							printf("temp_Dvalmy[%d][72]=%d\n",plate_num,  temp_Dvalmy[plate_num][72]);		
							printf("temp_Dvalmy[plate_num][100]=%d\n",  temp_Dvalmy[plate_num][100]);
							tp_sendtemperframe(plate_num, SET, 1,720 + temp_Dvalmy[plate_num][72],&rtemvalue);
							rf_writeintforprofile("ReadtemperInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,plate_num);
						}
						else if( last_tmper[plate_num] == 1000)
						{
							temp_Dvalmy[plate_num][100] = wtemvalue;
							for(j = 36;j < 72;j++)
							{
								if(temp_Dvalmy[plate_num][72] < 0)
									{
								temp_Dvalmy[plate_num][j] = (~temp_Dvalmy[plate_num][72] + 1) *(j - 35) / 37;
								temp_Dvalmy[plate_num][j] = ~temp_Dvalmy[plate_num][j] + 1;
									}
								else
									temp_Dvalmy[plate_num][j] = temp_Dvalmy[plate_num][72] *(j - 35) / 37;
								printf(" %d ",temp_Dvalmy[plate_num][j]);
							}
							cal_tmp = temp_Dvalmy[plate_num][100] - temp_Dvalmy[plate_num][72];
							printf("100cal_tmp = %d\n", cal_tmp);
							for(j = 73;j < 100;j++)
							{
							
							
							if(cal_tmp < 0)
								{
								temp_Dvalmy[plate_num][j] = (j - 72) * (~cal_tmp + 1) / 28;
								temp_Dvalmy[plate_num][j] = ~temp_Dvalmy[plate_num][j] + 1 + temp_Dvalmy[plate_num][72];
								}
							else
								temp_Dvalmy[plate_num][j] = temp_Dvalmy[plate_num][72]+(j - 72) * (cal_tmp) / 28;
							printf(" %d ",temp_Dvalmy[plate_num][j]);
							}
							printf("temp_Dvalmy[%d][72]=%d\n",plate_num,  temp_Dvalmy[plate_num][72]);	
							printf("temp_Dvalmy[plate_num][100]=%d\n",  temp_Dvalmy[plate_num][100]);
							tp_sendtemperframe(plate_num, SET, 1,1000 + temp_Dvalmy[plate_num][100],&rtemvalue);
							rf_writeintforprofile("ReadtemperInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,plate_num+30);
						}

						
						
					}
					else
						rf_writeintforprofile("ReadtemperInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,plate_num);
			}
			else if (cmdmy == SET)
			{
			
				last_tmper[plate_num] = wtemvalue;

				wtemvalue += temp_Dvalmy[plate_num][wtemvalue/10];
				printf("temp_Dvalmy[plate_num][%d]=%d\n",wtemvalue,temp_Dvalmy[plate_num][wtemvalue/10]);
			}
			if(cmd_type != CH1_Input_Bias)
			{
				tp_sendtemperframe(plate_num, cmdmy, 1,wtemvalue,&rtemvalue);//娴璇磋??
			}
			return 0;
			temcmd.cmdmy = cmdmy;
			temcmd.plate_num = plate_num;
			temcmd.wdata = wtemvalue;
			pthread_mutex_lock(&mutex_miantianlock);
			tc_testpacketcmdtemp(temcmd);
			pthread_mutex_unlock(&mutex_miantianlock);			
		return 0;
	}
				temcmd.temvalue = *((unsigned int*)&cmp_str[2]);
					
				
					if (plate_num < 4)
						temcmd.devaddr = 1;
					else if (plate_num < 8)
						temcmd.devaddr = 2;
					else if (plate_num < 12)
						temcmd.devaddr = 3;
					else if (plate_num < 16)
						temcmd.devaddr = 4;
					else if (plate_num < 20)
						temcmd.devaddr = 5;
					else if (plate_num < 24)
						temcmd.devaddr = 6;
					else if (plate_num < 28)
						temcmd.devaddr = 7;
					else if (plate_num < 32)
						temcmd.devaddr = 8;


				if ((cmd_type == CH1_RUN_STOP) || (cmd_type == CH1_Multi_SV_No) || (cmd_type == CH1_SV))
			interval = 3;
		else if ((cmd_type == CH1_AUTO_Tuning) || (cmd_type == CH1__MV_Low) || (cmd_type == CH1_MV_High)
				 || (cmd_type == CH1_Ramp_Up) || (cmd_type == CH1_Ramp_Down) || (cmd_type == CH1_Ramp_Unit)
				 || (cmd_type == CH1_HeatingPro_Band)|| (cmd_type == CH1_HeatingInt_Time)|| (cmd_type == CH1_HeatingDer_Time))
			interval = 9;
		else if ((cmd_type == CH1_Present_Value))
			interval = 1;
		else if ((cmd_type == CH1_Input_Type) || (cmd_type == CH1_Input_Bias)|| (cmd_type == CH1_Input_Filter)
				 || (cmd_type == CH1_SV_Low) || (cmd_type == CH1_SV_High) || (cmd_type == CH1_Tuning_Type) || (cmd_type == CH1_Heatingctl_Time))
			interval = 7;

			switch (plate_num%4)
			{
				case 0:
					temcmd.temcmd = cmd_type ;
					break;
				case 1:
					temcmd.temcmd = cmd_type + interval;
					break;
				case 2:
					temcmd.temcmd = cmd_type + interval * 2;
					break;
				case 3:
					temcmd.temcmd = cmd_type + interval * 3;
					break;
				default:break;
			}
			printf("cmd_type = %d value = %d\n",cmd_type,temcmd.temvalue);
			if ((cmd_type != CH1_SV) && (cmd_type != CH1_Input_Type))
			{				
				sprintf(str, "%d",temcmd.temvalue);
				
				rf_writeintforprofile("ReadtemperInfo", &ps_str[save_ps][0], str, (const char *)MeasureConfigPath,plate_num);
			}
			else if (temcmd.temvalue >= 200)
			{
				temcmd.temvalue +=  temp_goalval[temcmd.temvalue / 10];//加速温度差值  
			}
	//		printf("plate_num %d cmd %d value %d\n",plate_num,temcmd.temcmd,temcmd.temvalue);
	//				printf("\n");

	if (cmd_type == CH1_Input_Bias)//
	{
			printf("temcmd.temvalue=%d\n\n\n",temcmd.temvalue);
		//	return 0;
	}
			//emcmd.temvalue = temcmd.temvalue  ;
	
			if (cmd_type == CH1_SV_High)
			{
				temcmd.temvalue += 300;	//	CH1_SV_High 的值
			}

			pthread_mutex_lock(&mutex_miantianlock);
			tc_testpacketcmdtemp(temcmd);
			pthread_mutex_unlock(&mutex_miantianlock);
			
			if (cmd_type == CH1_Input_Type && plate_num == 29)//第30个传感器配置时，将后两个配置
			{
				temcmd.temcmd = CH3_Input_Type;
				pthread_mutex_lock(&mutex_miantianlock);
				tc_testpacketcmdtemp(temcmd);
				pthread_mutex_unlock(&mutex_miantianlock);	
				temcmd.temcmd = CH4_Input_Type;
				pthread_mutex_lock(&mutex_miantianlock);
				tc_testpacketcmdtemp(temcmd);
				pthread_mutex_unlock(&mutex_miantianlock);
			}
			
			
	return 0;
}

int mb_setdefaulconfpara(const char * cmp_str)
{
	
	sr_cmdstruct_t CommandElemt;
	sttemper_frame temcmd;
	int i = 0;
	static unsigned int X_coordinate, Y_coordinate, Z_coordinate;
	static unsigned char station_num = 0;
	static unsigned int* ordArray_p = NULL;
	static unsigned int* Z_ordArray_p = NULL;
	char str[20] = {0};
	static char save_ps = 0;
	const char ps_str[3][30] = {"ordArray_wash[3]","ordArray_reagent[4][3]","ordArray_plate[9][3]"}; 

	mb_readconfparatinfo(1);
	
	if(*cmp_str == 1)//mainarm
	{
		CommandElemt.srdevaddr = ARM_ADDR;	
		sprintf(CommandElemt.cmdbuf, "OX %d", par.ordArray_OW[0]);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
		CommandElemt.srdevaddr , 1, 0, 1) > 0)
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
	
		sb_waitingframeaswer(&CommandElemt);

		sprintf(CommandElemt.cmdbuf, "OY %d", par.ordArray_OW[1]);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
		CommandElemt.srdevaddr , 1, 0, 1) > 0)
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
	
		sb_waitingframeaswer(&CommandElemt);
		
		sprintf(CommandElemt.cmdbuf, "OZ %d" ,par.ordArray_OW[2]);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
		CommandElemt.srdevaddr , 1, 0, 1) > 0)
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
	
		sb_waitingframeaswer(&CommandElemt);
		
		sprintf(CommandElemt.cmdbuf, "OW");
		printf("cmdbuf=%s\n", CommandElemt.cmdbuf);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
		CommandElemt.srdevaddr , 1, 0, 1) > 0)
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
		printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
	
		sb_waitingframeaswer(&CommandElemt);
		
		sprintf(str, "%d %d %d",par.ordArray_OW[0], par.ordArray_OW[1], par.ordArray_OW[2]);
		rf_writeintforprofile("ReadCoordinateInfo", "ordArray_OW[3]", str, (const char *)MeasureConfigPath,0);	
					
				sprintf(str, "%d %d %d",par.ordArray_wash[0], par.ordArray_wash[1], par.ordArray_wash[2]);
				rf_writeintforprofile("ReadCoordinateInfo", "ordArray_wash[3]", str, (const char *)MeasureConfigPath,0);
				
		//	{"ordArray_wash[3]","ordArray_reagent[4][3]",
			//					"ordArray_plate[9][3]","ordArray_OW[3]","shelf_check[2][3]","LIQUID_SPEED"}		

		for(i = 0; i < 4;i++)
			{
		sprintf(str, "%d %d %d",par.ordArray_reagent[i][0], par.ordArray_reagent[i][1], par.ordArray_reagent[i][2]);
		rf_writeintforprofile("ReadCoordinateInfo", "ordArray_reagent[4][3]", str, (const char *)MeasureConfigPath,i);
			}
	
		for(i = 0; i < 3;i++)
			{
		sprintf(str, "%d %d %d",par.shelf_check[i][0], par.shelf_check[i][1], par.shelf_check[i][2]);
		rf_writeintforprofile("ReadCoordinateInfo", "shelf_check[2][3]", str, (const char *)MeasureConfigPath,i);
			}
		
		for(i = 0; i < 9;i++)
		{
			sprintf(str, "%d %d %d",par.ordArray_plate[i][0], par.ordArray_plate[i][1], par.ordArray_plate[i][2]);
			rf_writeintforprofile("ReadCoordinateInfo", "ordArray_plate[9][3]", str, (const char *)MeasureConfigPath,i);

		}

		}
	else if(*cmp_str == 2)//Selfarm
	{
		
	}
	else if(*cmp_str == 3)//Temp
	{
	printf("adgfetgh*******************");
		temcmd.devaddr = 9;//设置全部默认
		temcmd.temcmd = CONFIG_TEMPER;
		pthread_mutex_lock(&mutex_miantianlock);
		tc_testpacketcmdtemp(temcmd);
		pthread_mutex_unlock(&mutex_miantianlock);
	while(!TEM_init_setting_finished)		
		sleep(1);
	TEM_init_setting_finished = FALSE;
	
		
	}
	return 0;
}

void mb_menualwork(const char * cmp_string)
{
	emianid cmd = cmp_string[0];
	static char last_cmd = 0XFF,last_sec = 0XFF;
	int (*maintianfun[7])(const char * ) = {mb_mainarmcmd2, mb_actionmainarm, 
										mb_actionstrech, mb_actionpump, mb_actionother, mb_actionotemper,mb_setdefaulconfpara};
	sr_cmdstruct_t CommandElemt;


	assert(cmp_string > 5);
	#if 0
		GPIO_OutClear(V1);
	GPIO_OutClear(V2);
	GPIO_OutClear(V3);
	GPIO_OutClear(V4);
	GPIO_OutClear(V5); 
	GPIO_OutClear(V6);
	GPIO_OutClear(V7);
	GPIO_OutClear(V8);
	GPIO_OutClear(V9);
	GPIO_OutClear(VP1);
	#endif
	printf("last_cmd = %d last_sec=%d cmp_string[0]=%d,",last_cmd,last_sec,cmp_string[0]);
	if (last_cmd == MAIN_ARM && last_sec == Z_DOWN  &&  cmp_string[0] == STRECH)//防止撞针
		{
		CommandElemt.srdevaddr = ARM_ADDR;	
			sprintf(CommandElemt.cmdbuf, "ZI");
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
			printf("[mb_mainarmcmd2]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		}
	maintianfun[cmp_string[0]](cmp_string + 1);
	last_cmd = cmp_string[0];
	last_sec =  cmp_string[1];
}
/******************************************************************************
*
* Function Name  : Nt_recreagentpara
* Description    : .把网络数据转化成操作数据填入数据结构中
* 					 
* Input		   :operate_head_list*	operate_head 链表头, char *netbuf_read,int netread_len
* Output		   :None
* Return		   :  int 成功0 错误-1
*******************************************************************************/
	
int Nt_recreagentpara(operate_head_list*	operate_head,const char *netbuf_read,int netread_len,char shelf_num)	//一个tcp包为一片玻片的操作玻片最后操作需为停止操作
{
	int i = 0,j=0,res = 0,Dilute_cnt = 0;
	operate_t * operate_p = NULL;
	operate_head_list* operate_head_p = NULL;
	operate_head_list* last_head = NULL;
	unsigned char last_head_flage = 0;	//operate头链表尾是否就是其链表头
	char have_mix_reagent1st= 0, have_mix_reagent2scd= 0;
	char TCP_Buffer[24] ={0};

	//if (NEED_PRINTF)
		
	printf("in Nt_recreagentpara\n\n");
	lprintf(log_my, INFO,"in Nt_recreagentpara\n\n");
	/*
	for (i = 0; i < netread_len; i++)
		{
					printf(" %d ", netbuf_read[i]); 
				//	lprintf(log_my, INFO," %d ", netbuf_read[i]);
		}
				printf("\n");
	//	lprintf(log_my, INFO,"\n");
		*/
	operate_head_p = operate_head; 
	
	while(operate_head_p->next_head!= NULL)			//operate头链表尾
		{
	last_head = operate_head_p;
	operate_head_p = operate_head_p->next_head;
		}
	
	{	
		
		{

			
			if (netread_len < 10)	//一个结束包小于10说明pc发来操作data结束标志 这个值为滴加一次
			 {
				printf("[ReadOperate]netdata recieve finished\n");
				if (netbuf_read[1] != -1)
						mulnum_glb[shelf_num]=netbuf_read[1];
				mulnum_glb2[shelf_num] = netbuf_read[2];
				
				if (operate_head == operate_head1)
					liquid_valA = netbuf_read[0];
				else if (operate_head == operate_head2)
					liquid_valB = netbuf_read[0];
				
				else if (operate_head == operate_head3)
					liquid_valC = netbuf_read[0];
				
				
				
				
					ct_addtabtime(operate_head,*(int*)&netbuf_read[3]);	//加延时启动时间
				
				
				mb_printfoperatelist(operate_head);
			 	operate_p = &(operate_head->operate);
				while (operate_p != NULL)		//找出滴加混合试剂的时间
				{
					
					if (operate_p->reagent == REAGENT_DAB)
					{
						if (operate_head == operate_head1)
							dispense_mixreagent_timeA = operate_p->time;
						if (operate_head == operate_head2)
							dispense_mixreagent_timeB = operate_p->time;
						if (operate_head == operate_head3)
							dispense_mixreagent_timeC = operate_p->time;

						have_mix_reagent1st = 1;
					//	break;
					}
					
					if (operate_p->reagent == REAGENT_SECEND)
					{
						if (operate_head == operate_head1)
							dispense_mixreagent_timeA_next = operate_p->time;
						if (operate_head == operate_head2)
							dispense_mixreagent_timeB_next = operate_p->time;
						if (operate_head == operate_head3)
							dispense_mixreagent_timeC_next = operate_p->time;
						have_mix_reagent2scd = 1;
					//	break;
					}
					
					
					operate_p = operate_p->next;
				}
				if(have_mix_reagent1st == 0)//没有混合试剂
				{
					if (operate_head == operate_head1 )
							dispense_mixreagent_timeA = 0;
					if (operate_head == operate_head2 )
							dispense_mixreagent_timeB = 0;
					if (operate_head == operate_head3 )
							dispense_mixreagent_timeC = 0;
				}
				if(have_mix_reagent2scd == 0)//没有混合试剂
				{
					if (operate_head == operate_head1 )
							dispense_mixreagent_timeA_next = 0;
					if (operate_head == operate_head2 )
							dispense_mixreagent_timeB_next = 0;
					if (operate_head == operate_head3 )
							dispense_mixreagent_timeC_next = 0;
				}
				
				return 0;
			}
			else
			{
				printf("recieve operate data\n");
				if (operate_head->operate.reagent == STOP_OPERATE)	//operate头链表头空
				{	printf("in head\n");
					last_head_flage = 1;
					operate_p = &(operate_head->operate);	
				}
				else
				{
					printf("not in head\n");
					operate_head_p = operate_head;
					printf("operate_head_p->next_head = %doperate_head = %d\n", operate_head_p->next_head, operate_head->next_head);
					while (operate_head_p->next_head != NULL)	//寻址到operate头链表尾
						operate_head_p = operate_head_p->next_head;
					printf("head end find\n");
					while((operate_head_p->next_head = (operate_head_list*)malloc(sizeof(operate_head_list))) == NULL)
					{
						sleep(1);
						printf("malloc error operate_head_list\n");
					}
					operate_head_p = operate_head_p->next_head;
					operate_head_p->next_head = NULL;
						
					operate_p = &(operate_head_p->operate);
				}
				i = 0;
				while(!flg_mainproexit)
				{
					if(netbuf_read[i] < REAGENT_CASE)
					{
						if (reagent_code[netbuf_read[i]].special_num == H2O2 	)// 稀释液
						{
							mix_DAB[shelf_num].ordArrayB[netbuf_read[i + 6] % 10] = netbuf_read[i];	
							memcpy(&mix_DAB[shelf_num].reagentB[netbuf_read[i + 6] % 10],
									&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
							i += 7; 
						}
						
						 if(reagent_code[netbuf_read[i]].special_num == RED2 ||
							reagent_code[netbuf_read[i]].special_num == FR2 ||
							reagent_code[netbuf_read[i]].special_num == GREEN2||
							reagent_code[netbuf_read[i]].special_num == AP2)
						{
							mix_SECEND[shelf_num].ordArrayB[netbuf_read[i + 6] % 10] = netbuf_read[i];	
							memcpy(&mix_SECEND[shelf_num].reagentB[netbuf_read[i + 6] % 10],
									&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
							i += 7;
						}
					}

							memset(&(operate_p->reagent_info), 0, sizeof(reagent_t));				
						operate_p->reagent = netbuf_read[i];
						
					if (netbuf_read[i] < REAGENT_CASE)	
					{
					
						 if (reagent_code[netbuf_read[i]].special_num == DAB)	
					 	{
							mix_DAB[shelf_num].ordArrayA[netbuf_read[i + 6] % 10] = netbuf_read[i];
							memcpy(&mix_DAB[shelf_num].reagentA[netbuf_read[i + 6] % 10],
								&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
							operate_p->reagent = REAGENT_DAB;
							mix_DAB[shelf_num].tep_num++;
					 	}
						if (reagent_code[netbuf_read[i]].special_num == RED1 ||
						reagent_code[netbuf_read[i]].special_num == FR1 ||
						reagent_code[netbuf_read[i]].special_num == GREEN1||
						reagent_code[netbuf_read[i]].special_num == AP1)
						{
						mix_SECEND[shelf_num].ordArrayA[netbuf_read[i + 6] % 10] = netbuf_read[i];
						memcpy(&mix_SECEND[shelf_num].reagentA[netbuf_read[i + 6] % 10],
							&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
						operate_p->reagent = REAGENT_SECEND;
						mix_SECEND[shelf_num].tep_num++;
						}
						
						if (strlen(reagent_code[ netbuf_read[i]].reagent_kind) != 0)//接收时试剂被拿掉
							memcpy(&(operate_p->reagent_info),&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
						else
						{
							printf("reagent shelf removed reagent num=%d\n",netbuf_read[i]);
							lprintf(log_my, INFO,"reagent shelf removed reagent num=%d\n",netbuf_read[i]);
							TCP_Buffer[0] = 0;
							memcpy(&TCP_Buffer[1],operate_p->reagent_info.code,sizeof(operate_p->reagent_info.code));
							nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
							res = -1;
						}
					}

					memcpy(&operate_p->time,&netbuf_read[i + 1],4);
				//	operate_p->time = ntohl(operate_p->time);
					operate_p->time = operate_p->time;
					operate_p->temp = netbuf_read[i + 5];
					operate_p->plate_num = netbuf_read[i + 6];
					
					if ((i += 7) < netread_len && (netread_len - i) >= 6)
					{
						while((operate_p->next = (operate_t*)malloc(sizeof(operate_t))) == NULL)
						{
							sleep(1);
							printf("malloc error operate_t\n");
						}
						operate_p = operate_p->next;
					}
					else
					{
						operate_p->next = NULL;
						
						break;
					}
				}
					
					
				
				
				
			}
		}
		usleep(1000);
	}

return res;	
}


void mb_reagentchecking(unsigned char plate_num)
{
	sr_cmdstruct_t CommandElemt;
	int i=0,ZX_res = 0;
	CommandElemt.srdevaddr = ARM_ADDR;
	unsigned int eenetevent=REAGENT_SEND, Array_data_tmp = 0;
	unsigned char TCP_Buffer[50] = {0};
	unsigned int dwPinState;
	BOOL washall = 0;
		
	assert(plate_num < 36);
	pthread_mutex_lock(&tp_threadmarm);
		memset(ReportArrayData,0,sizeof(ReportArrayData));
		

		dwPinState = reagent_check[plate_num / 9].sen;
		reagent_check[plate_num / 9].NEED_CHECK = TRUE;
	GPIO_PinState(&dwPinState);
	if ((dwPinState & reagent_check[plate_num / 9].sen) == 1)//已经拿掉
	{
		if (SHELF_LOCK_WAY_NEW)
				 GPIO_OutClear(reagent_check[plate_num / 9].lock);//锁住进行扫描
			else
				GPIO_OutSet(reagent_check[plate_num / 9].lock);//锁住进行扫描
				
		reagent_check[plate_num / 9].NEED_CHECK = FALSE;
		if (pthread_mutex_unlock(&tp_threadmarm) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error tp_threadmarm");
		return;
	}	

	if (SHELF_LOCK_WAY_NEW)
		GPIO_OutSet(reagent_check[plate_num / 9].lock);//锁住进行扫描
	else
		GPIO_OutClear(reagent_check[plate_num / 9].lock);//锁住进行扫描
	
	mb_monitdoorstate();
#if 1	
	if (last_cabin_reagent != REAGENT_WATER || last_cabin_reagent != REAGENT_WASH)
		mb_procwashprobe(REAGENT_WATER);
	else
	{	
		tp_washchange(TRUE);
		if (last_cabin_reagent == REAGENT_WATER)
			mb_probewash_c(WATERPORT);
		else if (last_cabin_reagent == REAGENT_WASH )
			mb_probewash_c(WASHPORT);
		tp_washchange(FALSE);
	}
#endif
CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_reagent[plate_num][0], ordArray_reagent[plate_num][1], MOV_ZH);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

	sprintf(CommandElemt.cmdbuf, "ZA %d", 350 - OFFSET_STEP + SHELF_OFFSET);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		
usleep(300000);			
		
		flg_getedserailarr = TRUE;
		sprintf(CommandElemt.cmdbuf, "ZX 0 0 %d", LIQUID_ZMAX);////	sprintf(CommandElemt.cmdbuf, "ZA 500");
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		if ((ZX_res = sb_waitingframeaswer(&CommandElemt)) < 0)
		{
			if (ZX_res == -3)
			{
				sprintf(CommandElemt.cmdbuf, "ZI");
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);

				return;
			}
			else if (ZX_res == -9 || ZX_res == -11)
			{
				flg_getedserailarr = TRUE;
				washall = 1;
				sprintf(CommandElemt.cmdbuf, "ZX 0 0 %d", LIQUID_ZMAX);//测液体
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				if (sb_waitingframeaswer(&CommandElemt) < 0)
				{
					
					ReportArrayData[plate_num % 9] = 0XFFFFFFFF;//没测到		
				}
				else
					ReportArrayData[plate_num % 9] = serail_dataarr;
			}
			else
				ReportArrayData[plate_num % 9] = 0XFFFFFFFF;//没测到
		}
		else
			ReportArrayData[plate_num % 9] = serail_dataarr;
			
		printf("Arraydata=%d\n",serail_dataarr);
		CommandElemt.srdevaddr = ARM_ADDR;
		if (ReportArrayData[plate_num % 9] != 0XFFFFFFFF)
		{	
		sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			}
		sprintf(CommandElemt.cmdbuf, "ZA 0");
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
#if 1		
		tp_washchange(TRUE);
		if (last_cabin_reagent == REAGENT_WATER)
			{
			if(washall)
				mb_probewash_a(WATERPORT);
				else
			mb_probewash_c(WATERPORT);
			}
		else if (last_cabin_reagent == REAGENT_WASH )
		{
			if(washall)
				mb_probewash_a(WASHPORT);
				else
			mb_probewash_c(WASHPORT);
			}
			
		tp_washchange(FALSE);
#endif
	if (SHELF_LOCK_WAY_NEW)
				 GPIO_OutClear(reagent_check[plate_num / 9].lock);//锁住进行扫描
			else
				GPIO_OutSet(reagent_check[plate_num / 9].lock);//锁住进行扫描
			
	reagent_check[plate_num / 9].NEED_CHECK = FALSE;

	if(ReportArrayData[plate_num % 9] >= LIQUID_ZMAX || ReportArrayData[plate_num % 9] ==  0XFFFFFFFF)
		ReportArrayData[plate_num % 9] = 0XFFFFFFFF;
	else
	{
		for (i = 0; i < 9;i++)
		{
		
			ReportArrayData[i] += CorrectDate[i];
			printf("ReportArrayData[%d]=%x ",i,ReportArrayData[i]);
		}
	}

	TCP_Buffer[0] = plate_num;
	
	//memcpy(&TCP_Buffer[1],ReportArrayData,sizeof(ReportArrayData));
//	nt_sendpacketdata(REAGENT_SEND, TCP_Buffer, sizeof(ReportArrayData) + 1);

	#ifdef BIG_VERSION
	if(ReportArrayData[plate_num % 9] != 0XFFFFFFFF)
		ReportArrayData[plate_num % 9] = ReportArrayData[plate_num % 9] + OFFSET_STEP  - SHELF_OFFSET;
	#endif
	memcpy(&TCP_Buffer[1],&ReportArrayData[plate_num % 9],4);
	nt_sendpacketdata(REAGENT_SEND, TCP_Buffer, 4 + 1);

	
	if (pthread_mutex_unlock(&tp_threadmarm) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error tp_threadmarm");
	
	lprintf(log_my, INFO,"out of mb_reagentchecking\n");

	printf("out of mb_reagentchecking\n");

}

//read reagent's information from pc
void nt_chargespecialreagent(char *netbuf_read)
{
	int i;

	printf("nt_chargespecialreagent\n\n");
		lprintf(log_my, INFO,"nt_chargespecialreagent\n\n");
	for (i = 0; i < 9;i++)
	{
		memset(reagent_code[(netbuf_read[0] - 1) * 9 + i].reagent_kind, 0, 9);
		memcpy(reagent_code[(netbuf_read[0] - 1) * 9 + i].reagent_kind, &netbuf_read[1 + i * 23], 9);
		reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num = netbuf_read[1 + i * 23 + 9];
		memset(reagent_code[(netbuf_read[0] - 1) * 9 + i].lot_num, 0, 9);
		memcpy(reagent_code[(netbuf_read[0] - 1) * 9 + i].lot_num, &netbuf_read[1 + i * 23 + 10], 9);
		memset(&reagent_code[(netbuf_read[0] - 1) * 9 + i].val, 0, 4);
		memcpy(&reagent_code[(netbuf_read[0] - 1) * 9 + i].val, &netbuf_read[1 + i * 23 + 19], 4);
		
		printf(" %s-%d-%s val=%d\n", reagent_code[(netbuf_read[0] - 1) * 9 + i].reagent_kind,
			
			reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num,
			reagent_code[(netbuf_read[0] - 1) * 9 + i].lot_num,
			reagent_code[(netbuf_read[0] - 1) * 9 + i].val);		
		lprintf(log_my, INFO," %s-%d-%s val=%d\n", reagent_code[(netbuf_read[0] - 1) * 9 + i].reagent_kind,
			
			reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num,
			reagent_code[(netbuf_read[0] - 1) * 9 + i].lot_num,
			reagent_code[(netbuf_read[0] - 1) * 9 + i].val);

		if (reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num >= FR1 &&
			reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num <= FR2)
			reagent_code[(netbuf_read[0] - 1) * 9 + i].special_num -= 2;
	}

	

}


void mb_canceloperate(operate_t** operate_p, BOOL IsHead)
{
	
//	operate_t** last_operate_p = NULL;
//	operate_t* free_operate_p = NULL;

//	printf("in mb_canceloperate\n" );
		
		if ((*operate_p)->next != NULL)
		{
			mb_canceloperate(&((*operate_p)->next), FALSE);
			
		}

		//退出SetOperateDisable后还需判断
		if ((*operate_p)->next == NULL)
		{
			if (!IsHead)	//连表头不进行free
			{
				free(*operate_p);
				*operate_p = NULL;
			}
		}	

}

//将一架次的操作清空 operate_head为头， IsHead 是否为头标志
void mb_setoperateheaddisable(operate_head_list** operate_head, BOOL IsHead)
{
//	operate_head_list** last_head_p = NULL;			//当前操作玻片的上个玻片用于free
//	operate_head_list* free_head_p = NULL;
	operate_t* operate_p = NULL;
	
//	printf("in mb_setoperateheaddisable");
	

	if ((*operate_head)->next_head != NULL)
	{
		mb_setoperateheaddisable(&((*operate_head)->next_head),FALSE);
	}
	
	if ((*operate_head)->next_head == NULL)
	{
		operate_p = &((*operate_head)->operate);
		mb_canceloperate(&operate_p, TRUE);

		if (!IsHead)	//连表头不进行free
		{
			free(*operate_head);
			*operate_head = NULL;
		}
		else
		{
			(*operate_head)->operate.reagent = STOP_OPERATE;
			memset( &(*operate_head)->operate.reagent_info,0,sizeof(reagent_t));
		}
	}
	
}

//将水合坐标填入
void mb_sethydratepale(unsigned char shelfnum)
{
	operate_head_list* operate_head_p = NULL;
//	operate_t * operate_p = NULL;
	unsigned char i = 0;
	dispense_t *hydrate_plate = NULL;
	
	if (shelfnum == 1)
	{
			operate_head_p = operate_head1;
			hydrate_plate = hydrateA.hydrate_plate;
	}
	else if (shelfnum == 2)
	{
			operate_head_p = operate_head2;
			hydrate_plate = hydrateB.hydrate_plate;
	}
	else if (shelfnum == 3)
	{
			operate_head_p = operate_head3;
			hydrate_plate = hydrateC.hydrate_plate;
	}
	
	memset(hydrate_plate,0xFF, sizeof(hydrateA.hydrate_plate));
	
	while(operate_head_p != NULL)	//轮询一架玻片
	{
			hydrate_plate[i].plate_num = (operate_head_p->operate.plate_num) % 30;
			hydrate_plate[i].reagent = REAGENT_WASH;
			operate_head_p = operate_head_p->next_head;
			i++;
			if (operate_head_p == NULL)
				break;
	}	//一轮查询结束
	hydrate_plate[i].reagent = STOP_OPERATE;	

	printf("hydrateA.flage = %d\n",hydrateA.flage);
	printf("hydrateA.start_time = %d\n",hydrateA.start_time);
	printf("hydrateA.hydrate_plate= \n");
	for (i = 0; i < 11;i++)
		printf(" %d-%d",hydrateA.hydrate_plate[i].plate_num,hydrateA.hydrate_plate[i].reagent);
	
	printf("hydrate_plate= \n");

}

/*
void mb_canceloperate(operate_head_list* operate_head)
{
	operate_t* operate_p = NULL;
	operate_head_list* operate_head_p = NULL;
	unsigned char i = 0;
	printf("data in list\n");
	operate_head_p = operate_head;

	while(operate_head_p != NULL)
	{
		operate_p = &(operate_head_p->operate);
		while(operate_p != NULL)
		{
			printf(" %d %d %d %d", operate_p->reagent,operate_p->time,
								operate_p->temp, operate_p->plate_num);
				
			printf("--%s",operate_p->reagent_info.code);
			operate_p = operate_p->next;
		}
		
		printf("\n");
		operate_head_p = operate_head_p->next_head;
	}
}

*/
void nb_reconnectnet(int sign)
{
	if (sign == SIGPIPE)
	{
	//	printf("lose connect with net begining to try again\n");//信号处理函数中为不安全函数
		write(STDERR_FILENO,"lose connect with net begining to try again\n",
			80);
		flg_netdisconnect = TRUE;//BOOL 类型 为原子操作不会被中断 相当于 sig_atomic_t 
	//	close(local_fd);
		
	//		nt_createsocket();
		signal(SIGPIPE,nb_reconnectnet);//重新注册
	}

	if (SIGALRM == sign)
	{
	//	printf("SIGALRM\n");//信号处理函数中为不安全函数
	}
}
/*************网线是否拔出***************/
int nt_isnetmiireg(const char *if_name, int phy_id, int reg_num )
{
	struct ifreq ifr;
	struct mii_ioctl_data *mii;
	int value;



	bzero(&ifr, sizeof(ifr));
	strncpy(ifr.ifr_name, if_name, IFNAMSIZ-1);
	ifr.ifr_name[IFNAMSIZ-1] = 0;

	if (ioctl(local_fd, SIOCGMIIPHY, &ifr) < 0)
	{
		perror("ioctl");
		return -1;
	}

	mii = (struct mii_ioctl_data *)&ifr.ifr_data;
	mii->reg_num = reg_num;//0x01
	if (ioctl(local_fd, SIOCGMIIREG, &ifr) < 0)
	{
		perror("ioctl");
		return -1;
	}

	value = ((mii->val_out&0x04)>>2);
	return value;

}
int mb_setmeasconfig()
{
	char sendbuf[10] = {0};

	sendbuf[0] = 3;
	sendbuf[1] =1;
	if (system("cp /mnt/nandflash/device_measure_config.ini /mnt/nandflash/device_measure_config.inibak") < 0)
							sendbuf[1] =0;

						nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
					

return 0;
}

int mb_getmeasconfig()
{
	char data_buf[1000000] = {0},sendbuf[10], data_hang[1000] = {0};
	FILE *F = NULL;
	int size = 0;
	
	printf("int GeGetDev\n");
	data_buf[0] = 2;
	data_buf[1] = 1;

	if ((F = fopen("/mnt/nandflash/device_measure_config.ini","r=")) == NULL)
	{
		printf("open failed\n");
		sendbuf[1] =0;
		
			nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
	}
	fseek(F, 0, SEEK_END);
	size = ftell(F);
	rewind(F);
	while(fgets(data_hang, 1000000, F) != NULL)
		strcat(&data_buf[2], data_hang);

	fclose(F);
printf("GetDevGetDevGetDevGetDevGetDevGetDev\n");
	printf(" %s size=%d", data_buf,size);
	printf("readend\n\n");
	

	nt_sendpacketdata(UpdateSlaveState , data_buf, 2 + size);
return 0;
}

int mb_updatemeasconfig(char*data, int part_len)
	{
		fd_set DeviceRead;
		fd_set DeviceWrite;
		int 	DeviceMax = 0,res,i;
			struct timeval timeout,beattime,now;
		int data_index = 0,netread_len,rec_time = 0,all_len = 0;
		char data_buf[1000000],sendbuf[10];
		 char netbuf_read[10000];
		FILE *F = NULL;
		char buf[10] = "abcdef";
		char str = 1;

		memcpy(&all_len,data,4);
		all_len -= 2;//减去命令和种类
		memcpy(data_buf,&data[6],part_len);
		data_index = part_len;
		sendbuf[0] =1;
		printf("in upgrate part_len=%d all_len=%d\n",part_len,all_len);
		
		if (data_index >= all_len )
		{
			printf("upgrate finished data_index=%d\n",data_index);
				
				if ((F = fopen("/mnt/nandflash/device_measure_config.ini","w=")) == NULL)
				{
					printf("open failed\n");
					sendbuf[1] =0;
					
						nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
				}
				fwrite(data_buf,1,data_index,F);
				
	
				fclose(F);

		for(str = 1; str < 4; str++)	
		mb_setdefaulconfpara(&str);
			
			sendbuf[1] =1;
				nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
			return 0;
		}
		
		while(!flg_mainproexit)
			{
								//读取网口命令
				timeout.tv_sec = 0;
				timeout.tv_usec = 10;
				FD_ZERO(&DeviceRead);		
				DeviceMax = local_fd + 1;
				FD_SET(local_fd, &DeviceRead);
			
				res = select(DeviceMax,&DeviceRead, &DeviceWrite, NULL, &timeout);
				
				if(res < 0) {
					perror("[ListenNet] select error");
					sendbuf[1] =0;
						nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
					return -1;
				}
	
				if (FD_ISSET(local_fd, &DeviceRead))
				{
					printf("one rute\n");
					if ((netread_len = read(local_fd, (char *)netbuf_read , 2000)) < 0)
					{
						printf("[ListenNet]read netdata error in upgrate %s\n",strerror(errno));
						
					
					}
					else 
					{
						/*
						printf("netread_len=%d\n",netread_len);
						for (i = 0; i < netread_len; i++)
							printf("%c", netbuf_read[i]); 
						printf("\n");
						*/
						if (data_index + netread_len > all_len)//防止连包
							memcpy(&data_buf[data_index],netbuf_read,(all_len - data_index));
						else
							memcpy(&data_buf[data_index],netbuf_read,netread_len);
				
						data_index += netread_len;
					}
				}
				else
					rec_time++;
				
				if (data_index >= all_len )
				{
					printf("upgrate finished data_index=%d\n",data_index);
					
						for (i = 0; i < all_len;i++)
							printf("%c",data_buf[i]);
	
					printf("******************");
					
						F = fopen("/mnt/nandflash/device_measure_config.ini","w=");
						if (F == NULL)
						{
							sendbuf[1] =0;
							perror("open file error\n");
						}
						else
						{
							fwrite(data_buf,1,all_len,F);
							fclose(F);
							sendbuf[1] =1;
						}
	
				//	for(str = 1; str < 4; str++)	
				//		mb_setdefaulconfpara(&str);
						nt_sendpacketdata(UpdateSlaveState ,sendbuf, 2);
						
					return 0;
				}
				
				
			}
	}

//part_len 为第一段数据长度
int mb_updatefirmware(char*data, int part_len)
{
	fd_set DeviceRead;
	fd_set DeviceWrite;
	int    	DeviceMax = 0,res,i;
		struct timeval timeout,beattime,now;
	int data_index = 0,netread_len,rec_time = 0,all_len = 0;
	char data_buf[1000000],sendbuf[10];
	 char netbuf_read[10000];
	FILE *F = NULL;
	char buf[10] = "abcdef";
	
	memcpy(&all_len,data,4);
	all_len -= 2;//减去命令和种类
	memcpy(data_buf,&data[6],part_len);
	data_index = part_len;
	sendbuf[0] =0;
	
	printf("in upgrate part_len=%d all_len=%d\n",part_len,all_len);
	
	if (data_index >= all_len )
	{
		printf("upgrate finished data_index=%d\n",data_index);
			
			if ((F = fopen("/mnt/nandflash/pooltest","w=")) == NULL)
			{
				printf("open failed\n");
				sendbuf[1] =0;
					nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
			}
			fwrite(data_buf,1,data_index,F);
			

			fclose(F);

		sendbuf[1] =1;
			nt_sendpacketdata(UpdateSlaveState , sendbuf, 1);
		return 0;
	}
	
	while(!flg_mainproexit)
		{
							//读取网口命令
			timeout.tv_sec = 0;
			timeout.tv_usec = 10;
			FD_ZERO(&DeviceRead);		
			DeviceMax = local_fd + 1;
			FD_SET(local_fd, &DeviceRead);
		
			res = select(DeviceMax,&DeviceRead, &DeviceWrite, NULL, &timeout);
			
			if(res < 0) {
				perror("[ListenNet] select error");
				sendbuf[1] =0;
					nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
				return -1;
			}

			if (FD_ISSET(local_fd, &DeviceRead))
			{
				printf("one rute\n");
				if ((netread_len = read(local_fd, (char *)netbuf_read , 2000)) < 0)
				{
					printf("[ListenNet]read netdata error in upgrate %s\n",strerror(errno));
					
				
				}
				else 
				{
					/*
					printf("netread_len=%d\n",netread_len);
					for (i = 0; i < netread_len; i++)
						printf("%c", netbuf_read[i]); 
					printf("\n");
					*/
					if (data_index + netread_len > all_len)//防止连包
						memcpy(&data_buf[data_index],netbuf_read,(all_len - data_index));
					else
						memcpy(&data_buf[data_index],netbuf_read,netread_len);
			
					data_index += netread_len;
				}
			}
			else
				rec_time++;
			
			if (data_index >= all_len )
			{
				printf("upgrate finished data_index=%d\n",data_index);
				/*
					for (i = 0; i < all_len;i++)
						printf("%c",data_buf[i]);

				printf("******************");
				*/
					F = fopen("/mnt/nandflash/pooltesttmp","w=");
					if (F == NULL)
					{
						sendbuf[1] =0;
						perror("open file error\n");
					}
					else
					{
						fwrite(data_buf,1,all_len,F);
						fclose(F);
						sendbuf[1] =1;
					}

				//	if (system("sh /mnt/nandflash/upgrate.sh") < 0)
				if (system("cp /mnt/nandflash/pooltesttmp /mnt/nandflash/pooltest") < 0)
						sendbuf[1] =0;
				if (system("chmod 777 /mnt/nandflash/pooltest") < 0)
						sendbuf[1] =0;	
					nt_sendpacketdata(UpdateSlaveState , sendbuf, 2);
					
				return 0;
			}
			
			
		}
}


int ListenNet(void)
{
	int netread_len, i,connect_counter = 0, rtu_len = 0;
	Eenetevent eenetevent = NO_EVENT;
	fd_set DeviceRead;
	fd_set DeviceWrite;
	int    	DeviceMax = 0,res,read_buffer_index = 0, check_cmd = 0;
	char data = 0, tcpdata = 0;
	char rtu[10000] = {0}, buffer_tmp[10000] = {0};
	char* ip = "192.168.12.201";
	char iptmp[50] = {0};
	struct timeval timeout,beattime,now;
	stminibd_sendpacket mini_cmd;
	BOOL ISmini_cmdSETEDA = FALSE,ISmini_cmdSETEDB = FALSE,ISmini_cmdSETEDC = FALSE;

	int lock_time[3] = {0};
	tcflush(local_fd,TCIFLUSH);
	tcflush(local_fd,TCOFLUSH);
		
		
			
						
	printf("*********************in listen net***************************\n\n");
		gettimeofday(&beattime, NULL);
		while(!flg_mainproexit)
		{
							//读取网口命令
			timeout.tv_sec = 0;
			timeout.tv_usec = 100000;
			FD_ZERO(&DeviceRead);		
			DeviceMax = local_fd + 1;
			FD_SET(local_fd, &DeviceRead);
		
			res = select(DeviceMax,&DeviceRead, &DeviceWrite, NULL, &timeout);
			
			if(res < 0) {
				perror("[ListenNet] select error");
				return ;
			}

			if (FD_ISSET(local_fd, &DeviceRead))
			{
				if ((netread_len = read(local_fd, (char *)netbuf_read + read_buffer_index, 2000)) < 0)
				{
					printf("[ListenNet]read netdata error %s\n",strerror(errno));
					
				
				}
				else if (netread_len == 0)//服务器主动断开
				{
				//	printf("netread_len == 0\n");
					
					gettimeofday(&now, NULL);
				//	printf("now.tv_sec=%d  beattime.tv_sec=%d",now.tv_sec ,beattime.tv_sec);
					if (now.tv_sec - beattime.tv_sec >= 5)
					{
						printf("[ListenNet]lose connect with net begining to try again server disconnect %s\n",strerror(errno));
						connect_counter = 0;
						flg_netdisconnect = TRUE;
						sleep(1);
						close(local_fd);
							
							nt_createsocket();
							gettimeofday(&beattime, NULL);
						//sleep(1);
					}
					
				}
				else
				{
				
				//	printf("[ListenNet]netdata recieved len=%d,read_buffer_index=%d\n",netread_len,read_buffer_index);
				//	for(i = 0 ; i < read_buffer_index + netread_len;i++)
				//			printf(" %d ",*((char *)netbuf_read + i + read_buffer_index));
				#if 0
					if ((read_buffer_index + netread_len) >= 10000)
					{
						perror("***data in net buffer overflow***\n");
						
						lprintf(log_my,ERROR,"net buffer overflow=");
						for(i = 0 ; i < read_buffer_index + netread_len;i++)
							lprintf(log_my,ERROR," %d ",netbuf_read[i]);
						flg_mainproexit = TRUE;
						return -1;
						//read_buffer_index = 0;
					}
					#endif
			

					/*
					for (i = 0; i < netread_len; i++)
						printf(" %x ", netbuf_read[i]); 
					printf("\n");
					*/
					read_buffer_index += netread_len;
					gettimeofday(&beattime, NULL);
				}
			}
			else
			{

				gettimeofday(&now, NULL);
			//		printf("now.tv_sec - beattime.tv_sec = %d\n",now.tv_sec - beattime.tv_sec);
					if (now.tv_sec - beattime.tv_sec >= 20)
					{
						if (nt_isnetmiireg("eth0", 0X10, 0X01) <= 0)//超时后检测网线
						{
							connect_counter = 0;
								flg_netdisconnect = TRUE;
								sleep(1);
								close(local_fd);
									
									nt_createsocket();
									gettimeofday(&beattime, NULL);
						}
						
					}
					
				
#if 0				
					gettimeofday(&now, NULL);
			//		printf("now.tv_sec - beattime.tv_sec = %d\n",now.tv_sec - beattime.tv_sec);
					if (now.tv_sec - beattime.tv_sec >= 20)
					{
						printf("[ListenNet]lose connect with net begining to try again out of beattime\n");
						connect_counter = 0;
						flg_netdisconnect = TRUE;
						sleep(1);
						close(local_fd);
							
							nt_createsocket();
							gettimeofday(&beattime, NULL);
					}
#endif
			}

			if (netbuf_read[10] == UpdateSlave)//更新单独
			{
				if (netbuf_read[11] == 0)
					mb_updatefirmware(&netbuf_read[6],netread_len - 12);
				else if (netbuf_read[11] == 1)
					mb_updatemeasconfig(&netbuf_read[6],netread_len - 12);//需要再发送命令给机械臂和温控器
				else if (netbuf_read[11] == 2)
					mb_getmeasconfig();
				else if (netbuf_read[11] == 3)
					mb_setmeasconfig();
				
				read_buffer_index = 0;
				memset(netbuf_read,0,sizeof(netbuf_read));
			}
			
			else if (netbuf_read[10] == UpdateIP)
			{
				strcpy(&iptmp[1], ip);
				iptmp[0] = 0X22;
				sprintf(&iptmp[14], "%d",netbuf_read[11]);
				iptmp[15] = 0X22; 
				rf_writeintforprofile("LOCAL_MACHINE", "IPAddress",iptmp, (const char *)UserinfoPath, 0);				
				memset(netbuf_read,0,sizeof(netbuf_read));
			}
			
			else
			{
			memcpy(&rtu_len,&netbuf_read[6],4);
			
			if (rtu_len + 10  <= read_buffer_index)
			{	
				memcpy(rtu ,&netbuf_read[10] , rtu_len);
				rtu[rtu_len] = 0;//方便直接读取字符串
				
				memcpy(buffer_tmp, (char *)netbuf_read + rtu_len + 10,
					read_buffer_index - rtu_len - 10);
				
				memcpy(netbuf_read, buffer_tmp, read_buffer_index - rtu_len - 10);

				read_buffer_index =  read_buffer_index - rtu_len - 10;

				if (netbuf_read[11] != HEART_BEAT)
				{
				//	printf("netbuf_read=");
				//	for (i = 0; i < read_buffer_index; i++)
				//		printf(" %x ",netbuf_read[i]);
				//	printf("\n");
				/*	
						printf("rut=");
					for (i = 0; i < rtu_len; i++)
						printf(" %x ",rtu[i]);
					printf("\n");
			*/
				}
				if (rtu_len == 0)	//更新最近一次BEAT时间
					gettimeofday(&beattime,NULL);
				
				eenetevent = rtu[0];

				switch(eenetevent)
				{
					case NO_EVENT:
						break;
					case INIT:	
					//	ewkevent= INIT_WORK; 
						break;
					case MAINTIAN:
						flg_maintianrunning = TRUE;
						ewkevent = MAINTAIN_WORK;
						ewkeventA = MAINTAIN_WORK;
						ewkeventB = MAINTAIN_WORK;
						ewkeventC = MAINTAIN_WORK;
						printf("MAINTIAN WORK CMD = %d scend = %d\n",rtu[1],rtu[2]);
						
						if (rtu[1] != 0XFF)
							mb_menualwork(&rtu[1]);
					//	bs_writeconfiginfo();//退出后接受配置文件
					//	mb_readconfparatinfo();
						break;
					case WORKA:
						//读取流程
						if (flg_opwork1ready)
							break;
						mb_lockallregent(0);
						if (ISmini_cmdSETEDA == FALSE)
						{
							ISmini_cmdSETEDA = TRUE;
								#ifdef BIG_VERSION
							
							ArmCabinCmdList[0].dispense_pos = 0;
											ArmCabinCmdList[0].cmd = ArmCabinLoadMotor;//命令最后赋值dowork_Arm_cabinA以此判断
											
							#else
							bs_packetshelfstreach(0,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mLOCK");
							#endif
						}
						pthread_mutex_lock(&head_lock);
						if (Nt_recreagentpara(operate_head1, &rtu[1], rtu_len - 1,0) < 0)
						{
							printf("in mb_canceloperate WORKA\n" );
							tcpdata = -1;//接收失败
							nt_sendpacketdata(WORK_START,&tcpdata,1);
							mb_setoperateheaddisable((operate_t**)&operate_head1,TRUE);
						}
						else
							tcpdata = 1;//开始运行
							
						if (pthread_mutex_unlock(&head_lock) != 0)
							lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
						if (rtu_len < 10)
						{
							if (!flg_opwork1ready && !flg_opwork2ready && !flg_opwork3ready)
								operate_pri = operate_head1;
							
							work_cnt++;
							ISmini_cmdSETEDA = FALSE;
						//	tcpdata = 1;
						//	nt_sendpacketdata(WORK_START,&tcpdata,1);
							mb_sethydratepale(1);
							ewkeventA = BUSY_WORK;
							ct_reportcaculateprocetime();
							flg_opwork1ready = TRUE;
							
							reagent_lock[0][0] =reagent_lock[1][0]=reagent_lock[2][0]=reagent_lock[3][0]= 0;
							printf("Nt_recreagentpara finished A\n");
						}
						break;
					case WORKB:
						//读取流程
						printf("flg_opwork2ready=%d\n", flg_opwork2ready);
						
						if (flg_opwork2ready)
							break;
						mb_lockallregent(1);
						if (ISmini_cmdSETEDB == FALSE)
						{
							ISmini_cmdSETEDB = TRUE;
								#ifdef BIG_VERSION
							
							ArmCabinCmdList[1].dispense_pos = 0;
											ArmCabinCmdList[1].cmd = ArmCabinLoadMotor;//命令最后赋值dowork_Arm_cabinA以此判断
											
							#else
							bs_packetshelfstreach(10,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mLOCK");
							#endif
						}
							
						pthread_mutex_lock(&head_lock);
						if (Nt_recreagentpara(operate_head2, &rtu[1], rtu_len - 1, 1) < 0)
						{
							printf("in mb_canceloperate WORKB\n" );
							tcpdata = -2;//接收失败
							nt_sendpacketdata(WORK_START,&tcpdata,1);
							mb_setoperateheaddisable((operate_t**)&operate_head2,TRUE);
						}
						else
							tcpdata = 2;//开始运行
							
						if (pthread_mutex_unlock(&head_lock) != 0)
							lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
						if (rtu_len < 10)
						{
						if (!flg_opwork1ready && !flg_opwork2ready && !flg_opwork3ready)
							operate_pri = operate_head2;
							work_cnt++;
							ISmini_cmdSETEDB = FALSE;
						//	tcpdata = 2;
						//	nt_sendpacketdata(WORK_START,&tcpdata,1);
							
							mb_sethydratepale(2);
							ewkeventB = BUSY_WORK;
							ct_reportcaculateprocetime();
							flg_opwork2ready = TRUE;
							reagent_lock[0][1] =reagent_lock[1][1]=reagent_lock[2][1]=reagent_lock[3][1]= 0;
							printf("Nt_recreagentpara finished B\n");
						}
						break;
					case WORKC:
						//读取流程	
						if (flg_opwork3ready)
							break;
						mb_lockallregent(2);
						if (ISmini_cmdSETEDC == FALSE)
						{
							ISmini_cmdSETEDC = TRUE;
							#ifdef BIG_VERSION
							
							ArmCabinCmdList[2].dispense_pos = 0;
											ArmCabinCmdList[2].cmd = ArmCabinLoadMotor;//命令最后赋值dowork_Arm_cabinA以此判断
											
							#else
							bs_packetshelfstreach(20,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
							#endif
						}
						pthread_mutex_lock(&head_lock);
						if (Nt_recreagentpara(operate_head3, &rtu[1], rtu_len - 1, 2) < 0)
						{
							printf("in mb_canceloperate WORKC\n" );
							tcpdata = -3;//接收失败
							nt_sendpacketdata(WORK_START,&tcpdata,1);
							mb_setoperateheaddisable((operate_t**)&operate_head3,TRUE);
						}
						else
							tcpdata = 3;//开始运行

						if (pthread_mutex_unlock(&head_lock) != 0)
							lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
						if (rtu_len < 10)
						{
						if (!flg_opwork1ready && !flg_opwork2ready && !flg_opwork3ready)
							operate_pri = operate_head3;
							work_cnt++;
							ISmini_cmdSETEDC = FALSE;
					//		tcpdata = 3;
					//		nt_sendpacketdata(WORK_START,&tcpdata,1);
							
							mb_sethydratepale(3);			
							ewkeventC = BUSY_WORK;
							ct_reportcaculateprocetime();
							flg_opwork3ready = TRUE;
							reagent_lock[0][2] =reagent_lock[1][2]=reagent_lock[2][2]=reagent_lock[3][2]= 0;
							printf("Nt_recreagentpara finished C\n");
						}
						//mb_setoperateheaddisable(&operate_head3, TRUE);
					//	mb_printfoperatelist(operate_head3);
						
						break;
					case ChangeReagentA:
					//	nt_recvchangereagentinfo(operate_head1, &rtu[1],  rtu_len - 1, 0);
						break;
					case ChangeReagentB:
					//	nt_recvchangereagentinfo(operate_head2, &rtu[1],  rtu_len - 1, 1);
						break;
					case ChangeReagentC:
					//	nt_recvchangereagentinfo(operate_head3, &rtu[1],  rtu_len - 1, 2);
						break;
					case ChangeReagent2:
						pthread_mutex_lock(&head_lock);
						nt_recvchangereagentinfo(&rtu[1],rtu_len - 1);
					pthread_mutex_unlock(&head_lock);
						break;
					case REAGNET_INFO: 
						nt_chargespecialreagent(&rtu[1]);
						special_reagent_recieved = TRUE;
						break;
					case CHECK_REAGENT:	//格式 CHECK_REAGENT + 1字节 坐标位置
						printf("****************CHECK_REAGENT**********************\n");
						flg_checkreagentindex[rtu[1]] = TRUE;
						break;
					case REPLACE_REAGENT:
						replace_reagent = rtu[1];
						break;
					case WORK_NORMAL:
						ewkevent = FREE_WORK; 	
						break;
					case PAUSE_NOW:
						ewkevent = PAUSE; 
						break;
					case STOP_NOW:		
						pthread_mutex_lock(&mutex_tryworklock);
						if (pthread_mutex_unlock(&mutex_tryworklock) != 0)
							lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_tryworklock");
						if (rtu[1] == 5)
						{
							
							flg_mainproexit = TRUE;
						}
						else
						{
						
							if (rtu[1] == 1)
							{				
							//	mb_setoperateheaddisable((operate_t**)&operate_head1,TRUE);
								ewkeventA = STOP_WORK;
								hydrateA.flage = FALSE;	
								mb_mainworkstop(1);	
							}
							if (rtu[1] == 2)
							{
							//	mb_setoperateheaddisable((operate_t**)&operate_head2,TRUE);
								ewkeventB = STOP_WORK;
								hydrateB.flage = FALSE;	
								mb_mainworkstop(2);	
							}
							if (rtu[1] == 3)
							{
							//	mb_setoperateheaddisable((operate_t**)&operate_head3,TRUE);
								ewkeventC = STOP_WORK;
								hydrateC.flage = FALSE;	
								mb_mainworkstop(3);	
							}
							if (rtu[1] == 4)
							{
							//	mb_setoperateheaddisable((operate_t**)&operate_head1,TRUE);
						//		mb_setoperateheaddisable((operate_t**)&operate_head2,TRUE);
						//		mb_setoperateheaddisable((operate_t**)&operate_head3,TRUE);
								ewkevent = STOP_ALL; 
								hydrateA.flage = FALSE;	
								hydrateB.flage = FALSE;	
								hydrateC.flage = FALSE;	
								mb_mainworkstop(1);	
								mb_mainworkstop(2);	
								mb_mainworkstop(3);	
							}
							 
						}
						//GPIO_OutSet(VP1);
						ct_reportcaculateprocetime();
						break;
					case STANDBY:
					//	GPIO_OutSet(VP1);
						ewkevent = STANDBY_WORK;
						
						break;
					case CHECK_PROBLEM:
							memcpy(&check_cmd, &rtu[1], 4);
						printf("check_cmd = %d", check_cmd );
							if (check_cmd == MIX_STATION_MOVED)
								flg_sancmixstatioin = TRUE;
							
							else if (check_cmd == WAST_LIUID_LOW_FULL)
								OUT_WASTHIGH_L = FALSE;
							else if (check_cmd == WAST_LIUID_HIGH_FULL)
								OUT_WASTHIGH_H = FALSE;
						break;
						
					case PROBE_CLR:
						printf("PROBE_CLR");
						ewkevent = PROBE_CLR_WORK;
						reagent_clr[0] = rtu[1];
						reagent_clr[1] = rtu[2];
						reagent_clr[2] = rtu[3];
						break;
					case DELAY_START:
						if (rtu[1] == 1	)
						{
							reagent_lock[0][0] =reagent_lock[1][0]=reagent_lock[2][0]=reagent_lock[3][0]= 0;
							ewkeventA = STANDBY_WORK;
							
							bs_packetshelfstreach(0,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
						}
						if (rtu[1] == 2	)
						{
							reagent_lock[0][1] =reagent_lock[1][1]=reagent_lock[2][1]=reagent_lock[3][1]= 0;
							ewkeventB = STANDBY_WORK;
							bs_packetshelfstreach(10,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
						}
						if (rtu[1] == 3	)
						{
						
						reagent_lock[0][2] =reagent_lock[1][2]=reagent_lock[2][2]=reagent_lock[3][2]= 0;
							ewkeventC = STANDBY_WORK;
							bs_packetshelfstreach(20,&mini_cmd);
							pthread_mutex_lock(&mutex_mlock);
							set_minicmd(pcmd_head,mini_cmd);
							if (pthread_mutex_unlock(&mutex_mlock)!= 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
						}
						break;
						
					case RUNINGCONFIG:
						bs_writeconfiginfo(&rtu[1]);
						mb_readrunparainfo();
						break;
				
					default:
						break;
				}
			}
		}

				
				
		usleep(10000);
		}

}
/******************************************************************************
*
* Function Name  : mb_errorinfoproce
* Description    : .错误处理
* 					 
* Input		   :emERRORCODE *error_code 错误数组指针, int error_num 错误个数
* Output		   :None
* Return		   :  None
*******************************************************************************/
void mb_errorinfoproce(emERRORCODE *error_code, int error_num)
{
	int i = 0;
//	printf("REAGENT_REMOVED=%d\n",REAGENT_REMOVED);
	for (i = 0; i < error_num;i++)
	{
		if (
			error_code[i] == CONNECT_ERROR_WATER || 
			error_code[i] == CONNECT_ERROR_MINIA  || error_code[i] == CONNECT_ERROR_MINIB  || 
			error_code[i] == CONNECT_ERROR_MINIC  || error_code[i] == CONNECT_ERROR_PUMPA  ||
			error_code[i] == CONNECT_ERROR_PUMPB  || error_code[i] == CONNECT_ERROR_PUMPC  ||
			error_code[i] == ARM_LOSE_MINIA       || error_code[i] == ARM_LOSE_MINIB       ||
			error_code[i] == ARM_LOSE_MINIC       || 
			error_code[i] == ARM_STEP_LOSS_X      || error_code[i] == ARM_STEP_LOSS_Y||
			error_code[i] == ARM_STEP_LOSS_Z      || error_code[i] == ARM_DEVICE_NOT_INITIALIZED ||
			error_code[i] == CONNECT_ERROR_SCANNER || error_code[i] == CONNECT_ERROR_WEIGHT||
			error_code[i] == CONNECT_ERROR_ARM ||
		//	 error_code[i] == WAST_LIUID_LOW ||
		//	error_code[i] == WAST_LIUID_HIGH ||
			error_code[i] == CONNECT_ERROR_TEMPER || error_code[i] == CONNECT_ERROR_TEMPRO ||
			error_code[i] == PUMP_PLUNGER_OVERLOAD || error_code[i] == PUMP_VALVE_OVERLOAD
			)
		
		{
			GPIO_OutSet(ER_LED);
			beep_state.error = 1;
			sleep(2);
			flg_mainproexit = TRUE;
			printf("\n******************Progress exited*************\n");
		}

		else if (error_code[i] == DOOR_OPEN || error_code[i] == WATERPOUR_WRONG || 
			error_code[i] == WASHPOUR_WRONG || error_code[i] == ALCOHOLPOUR_WRONG ||
			error_code[i] == ER1POUR_WRONG || error_code[i] == ER2POUR_WRONG
		//	|| error_code[i] == ASPIRATE_WRONG
			// || error_code[i] == REAGENT_REMOVED
			)		
		{
			stop_flag = TRUE;
			printf("\n******************Progress stoped*************\n");
		}
		else if (error_code[i] == SHELF_LOSE_MINIA)
		{
			ewkeventA = STOP_WORK;
			hydrateA.flage = FALSE;	
			mb_mainworkstop(1);	
		}
		else if (	error_code[i] == SHELF_LOSE_MINIB )
		{
			ewkeventB = STOP_WORK;
			hydrateB.flage = FALSE;	
			mb_mainworkstop(2);	
		}
		else if( error_code[i] == SHELF_LOSE_MINIC  )
		{
			ewkeventC = STOP_WORK;
			hydrateC.flage = FALSE;	
			mb_mainworkstop(3);	
		}
		
		//else if (error_code[i] >= 0XC2)
		//	flg_mainproexit = TRUE;
		
	}
}
/******************************************************************************
*
* Function Name  : mb_reportshelfstatus
* Description    : .向PC发送玻片架状态
* 					 
* Input		   :unsigned char* mini_recieve_code mini返回的码, char shelf_num 玻片架次
* Output		   :None
* Return		   :  None
*******************************************************************************/
void mb_reportshelfstatus(void)
{
	char i = 0,slf_num = 0;
	static char last_send_state[3] = {0};
	
		for (i = 0; i < 3;i++)
		{
			slf_num = i + 1;

			{
				if (SHELF_LOCK_STATE[i] == 1 && last_send_state[i] != 1)
				{
					nt_sendpacketdata(SHELF_UNLOCKED, &slf_num, 1);
					last_send_state[i] = 1;
					printf("report_shelf_stateSHELF_UNLOCKED=%d, last_send_state=%d\n", i, last_send_state[i]);
				}
				else if (SHELF_LOCK_STATE[i] == 2 && last_send_state[i] != 2)
				{
					nt_sendpacketdata(SHELF_LOCKED, &slf_num, 1);
					last_send_state[i] = 2;
					printf("report_shelf_statSHELF_LOCKEDe=%d, last_send_state=%d\n", i, last_send_state[i]);
				}
				
			}
				
		}
}
/******************************************************************************
*
* Function Name  : nt_sendpacketdata
* Description    : .向网络端口发送数据
* 					 
* Input		   :char cmd 命令头, char * data 数据指针, int data_len 数据长度
* Output		   :None
* Return		   :  int 错误-1 正确 返回长度
*******************************************************************************/
int nt_sendpacketdata(char cmd, char * data, int data_len)
{
	char netbuf_write[50000] = {0},NetWriteBuffer_tmp[50000] = {0};
	int res = 0, i = 0,	DeviceMax = 0,send_len = 0;
	struct timeval  timecur,timelast;
	struct timeval timeout;
	fd_set DeviceWrite;
	fd_set DeviceRead;
	
//	return 0;
//	netbuf_write[0] = 0XFF;
	strcpy(&netbuf_write[0],"header");
	data_len += 1;//加上命令头
	memcpy(&netbuf_write[6], &data_len, 4);
	netbuf_write[10] = cmd;
	memcpy(&netbuf_write[11], data, data_len);
	if (flg_netdisconnect) return -1;
//	while(flg_netdisconnect) sleep(1);
#if 0
printf("nt_sendpacketdata cmd = %d\n",cmd);
	for (i = 0; i < data_len;i++)
		printf(" %x ", data[i]);
printf("*********************");
#endif
	data_len += 10; //  "header"  + 长度本身占的字节
	pthread_mutex_lock(&netsend_lock);
	
	while(!flg_mainproexit)
	{
		if (flg_netdisconnect) 
		{
			if (pthread_mutex_unlock(&netsend_lock) != 0)//1.29号补的
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error netsend_lock");
			return -1;
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 10000;
		FD_ZERO(&DeviceWrite);		
		DeviceMax = local_fd + 1;
		FD_SET(local_fd, &DeviceWrite);
	
		res = select(DeviceMax,&DeviceRead, &DeviceWrite, NULL, &timeout);
		
		if(res < 0) {
			perror("[nt_sendpacketdata] select error");
			if (pthread_mutex_unlock(&netsend_lock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error netsend_lock");
			return -1;
		}

		if (FD_ISSET(local_fd, &DeviceWrite))
		{
SEND_AGAIN:
		//	if (cmd == HEART_BEAT) printf("HEART_BEATHEART_BEATHEART_BEATHEART_BEATHEART_BEATHEART_BEAT\n");
			if ((res = write(local_fd, netbuf_write, data_len)) < 0)
			//if (send(local_fd, netbuf_write, data_len, MSG_NOSIGNAL) < 0)
			{
			//	printf("[nt_sendpacketdata]lose connect with net\n");
			//	flg_netdisconnect = TRUE;
			if(pthread_mutex_unlock(&netsend_lock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error netsend_lock");
			return -1;
			
				while(flg_netdisconnect)
				{
				printf("[nt_sendpacketdata]lose connect with net\n");
					sleep(1);
				}
				goto SEND_AGAIN;
			}
			else
			{
				send_len += res;
			//	printf("send len = %d/n", res);
			}

			if(res < data_len)//缓存不够 发送余下的
			{
				data_len = data_len - res;
				memcpy(NetWriteBuffer_tmp, (char*)netbuf_write + res, data_len);
				memcpy(netbuf_write, NetWriteBuffer_tmp, data_len);
				continue;
			}

			break;
		}
		usleep(1000);
	}		
//	printf("res = %d****\n",res);
	if (pthread_mutex_unlock(&netsend_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error netsend_lock");

	return send_len;
}
/***********返回数据给PC端************/
void nt_reportpacketinfo(void)
{
	unsigned int eenetevent = NO_EVENT;
	//tcflush(local_fd,TCOFLUSH);
	unsigned int write_len = 0;
	int error_code = NO_ERROR;
	int error_table[100] = {0};
	static unsigned char temp_value_report[30] = {0};
	stnet_report report;
	int i=0,j=0;
	char tcpdata;
	char netbuf_write[512] = {0};
	char TCP_Buffer[50] = {0};
	static unsigned int head1step = 0,head2step = 0,head3step = 0;
	static unsigned short last_bigcabin_value[18]={0};
	static char firstbigget = 1;
//	printf("in [nt_reportpacketinfo]\n");
/*
	if (nt_isnetmiireg("eth0", 0X10, 0X01) <= 0)
	{
		printf("lose connect with net begining to try again\n");
		flg_netdisconnect = TRUE;
		close(local_fd);	
			nt_createsocket();
	}
	*/
	
	if (perror_head->error_code != NO_ERROR || perror_exist_head->error_code != NO_ERROR)
	{	
		memset(netbuf_write, 0, sizeof(netbuf_write));
		write_len = 0;
		i = 0;
		while((error_code = mb_geterrorcode()) != NO_ERROR)
		{	
			if ((error_code & 0X00FFFFFF) == NO_ERROR)//有可能是最高位至1的NO_ERROR
				continue;
			if ((error_code & 0XFF000000) > 0)//error has been solved
			{
				if (!mb_finderrorcodeinlist(error_code,TRUE))	//delete the error as it was solved
				{
					printf("error has been solved but it does't occured before\n");
					continue;
				}
			}
			else if (mb_finderrorcodeinlist(error_code,FALSE))	//error occured but the error has happened before
			{
				//  1107 取消
				/*
				if (error_code != DOOR_OPEN && error_code != WAST_LIUID_LOW_FULL
					&& error_code != WAST_LIUID_HIGH_FULL)//除了门错误需要发送
				continue;
				*/
			}
			else	//new error set exist
			{
				printf("set new error in exist\n");
				set_exist_error(error_code);
			}
			
			/*********send new error or solved error***********/
			
			
			error_table[i] = error_code;
			memcpy(&netbuf_write[write_len], &error_code, 4);
			write_len += 4;
				i++;
		}

		if (error_table[0] != 0)	//code needs to be sent
		{
			printf("in report error\n");
			nt_sendpacketdata(ERROR_WARNING, netbuf_write, write_len);
			sleep(1);
			//调用错误处理函数 处理仪器动作
			mb_errorinfoproce(error_table, i + 1);
		}
	}

//	printf("report WORK_STEP\n");
//	printf("\n");
	
//	workstep_state_b++;
//	workstep_state_b = workstep_state_b | 0x01000000;
//	workstep_state_c = 3;
	if (head1step != workstep_state_a || head2step != workstep_state_b || head3step != workstep_state_c)
	{
		memset(netbuf_write, 0, sizeof(netbuf_write));
		memcpy(((unsigned char *)&netbuf_write[0]), (void*)&workstep_state_a,sizeof(workstep_state_a));
		memcpy(((unsigned char *)&netbuf_write[4]), (void*)&workstep_state_b,sizeof(workstep_state_b));
		memcpy(((unsigned char *)&netbuf_write[8]), (void*)&workstep_state_c,sizeof(workstep_state_c));
		netbuf_write[12] = report_reagentinfo[0]; 
		netbuf_write[13] = report_reagentinfo[1]; 
		netbuf_write[14] = report_reagentinfo[2]; 
		
		nt_sendpacketdata(WORK_STEP, netbuf_write, 15);
		head1step = workstep_state_a,head2step = workstep_state_b,head3step = workstep_state_c;
		pthread_mutex_lock(&head_step_lock);
		if ((workstep_state_a & 0XFFFF0000) == 0X01110000)
			HEAD1_STEP_SENDED = TRUE;
		if ((workstep_state_b & 0XFFFF0000) == 0X01110000)
			HEAD2_STEP_SENDED = TRUE;
		if ((workstep_state_c & 0XFFFF0000) == 0X01110000)
			HEAD3_STEP_SENDED = TRUE;
		if (pthread_mutex_unlock(&head_step_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
	}
	{
		memset(netbuf_write, 0, sizeof(netbuf_write));//heartbeat	
	//	printf("env_temp=%d",env_temp);
		netbuf_write[0] = 25;
		nt_sendpacketdata(HEART_BEAT, netbuf_write, 1);
	//	nt_sendpacketdata(HEART_BEAT, netbuf_write, 0);
	}
#if 0
memset(TCP_Buffer, 0, sizeof(TCP_Buffer));
		
		TCP_Buffer[0] = 1;
nt_sendpacketdata(REAGENT_SEND, TCP_Buffer, sizeof(ReportArrayData) + 1);

		nt_sendpacketdata(SHELF_UNLOCKED, TCP_Buffer, 1);
		nt_sendpacketdata(SHELF_LOCKED, TCP_Buffer, 1);
		error_code = DOOR_OPEN;
		memcpy(&netbuf_write[0], &error_code, 4);
		nt_sendpacketdata(ERROR_WARNING, netbuf_write, 4);
		nt_sendpacketdata(WORK_TEMP, netbuf_write, 30);
		nt_sendpacketdata(CASE_STATE, netbuf_write, 24);
		memcpy(TCP_Buffer, "1234567", 7);
		nt_sendpacketdata(REAGENTCODE_SEND, TCP_Buffer, 7);
		memcpy(TCP_Buffer, "abcdefg", 7);
	nt_sendpacketdata(SCANNER_SEND, TCP_Buffer, 7);
		memcpy(&TCP_Buffer[1], "1234567", 7);
			nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
	
		
		nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
	nt_sendpacketdata(SHELF_SCAN_END, TCP_Buffer, 0);
	nt_sendpacketdata(SET_REAGENT_DISABLE, TCP_Buffer, 1);
	nt_sendpacketdata(REAGENT_SCAN_END, &eenetevent, 0);
#endif
#if 1

	mb_reportshelfstatus();
	

//	get_temvale = FALSE;
	if (get_temvale == TRUE)	
	{		
//		printf("report WORK_TEMP\n");
		memset(netbuf_write, 0, sizeof(netbuf_write));
		write_len = 6;
	//	printf("report temp value********************\n");
//		pthread_mutex_lock(&report_lock);
//		printf("temp_value_report ");
		for (i = 0; i < 30;i++)
		{
			if (temp_value[i] > 2550)
			{
				temp_value_report[i] = 0;
			}
			else
			{
/*				for (j = 0; (j <= 100) && ((temp_goalval[j] / 10 + j ) != temp_value[i] / 10);j++)
				{	
				}
				if (j <= 100)//找到      			没找到按原值
					temp_value_report[i] = j;
*/
				if (new_temper)
					{
					temp_value_report[i] =1+(temp_value[i]-temp_setval[i][temp_value[i]/10])/10;//加1°小数点进位
					}
				else	
					temp_value_report[i] =( temp_value[i] - temp_goalval[temp_value[i] / 10]) / 10;
			}	
/*			else if (temp_value[i] < 900)
			{
				for (j = 0; (j <= 89) && ((temp_goalval[j] / 10 + j ) != temp_value[i] / 10);j++)
				{	
				}
				if (j < 90)//找到      			没找到按原值
					temp_value_report[i] = j;
				
			}
	//		else
	//			temp_value_report[i] = (temp_value[i] - temp_goalval[i]) / 10 ;
	*/
	//			printf(" temp_value[i]=%d temp_goalval[j]=%d %d",temp_value[i],temp_goalval[j],temp_value_report[i]);
		}
//		pthread_mutex_unlock(&report_lock); 
		
			memcpy((unsigned char *)netbuf_write, temp_value_report,sizeof(temp_value_report));
			nt_sendpacketdata(WORK_TEMP, netbuf_write, 30);
	get_temvale = FALSE;	
	}



	if (flg_cabinreved)
	{
		printf("report CASE_STATE****************\n");	
		memset(netbuf_write, 0, sizeof(netbuf_write));
		flg_cabinreved = FALSE;
	//	pthread_mutex_lock(&report_lock);
	

		#ifndef BIG_VERSION
		memcpy(bigcabin_value, cabin_value,sizeof(cabin_value));
		#else

	
			printf("bigcabin_value=");
	for(i=0;i<18;i++)
		printf(" %d ",bigcabin_value[i]);
	#endif

#ifdef BIG_VERSION

		i=0;
		if(firstbigget )
		{
			firstbigget = 0;
		}
		else
		{
			for(i = 0; i < 6;i++)
			{
			if( (last_bigcabin_value[i] - 50) > bigcabin_value[i] || (last_bigcabin_value[i] + 50) < bigcabin_value[i])
				break;	

			if(last_bigcabin_value[i + 6] != bigcabin_value[i + 6])
				break;
			}
		}
		if(i != 6)
#endif
		{
			memcpy((unsigned char *)netbuf_write, bigcabin_value,sizeof(bigcabin_value));	
			nt_sendpacketdata(CASE_STATE, netbuf_write, 36);
			memcpy(last_bigcabin_value, bigcabin_value, sizeof(bigcabin_value));
		}
		
	}
	#endif
/*
	usleep(100000);
	pthread_mutex_lock(&report_lock);
	report = mb_readreportval();	
	if (report.plate_num != 0Xff)
	{
		eenetevent = WORKA_OPERATE;
		while(flg_netdisconnect) sleep(1);
		pthread_mutex_lock(&netsend_lock);
		if (send(local_fd, &eenetevent,sizeof(eenetevent), 0) < 0)
				perror("write net\n");
		pthread_mutex_unlock(&netsend_lock);
	 	write_len = 0;
		memset(netbuf_write, 0, sizeof(netbuf_write));
		while (report.plate_num != 0XFF)
		{
			memcpy((netbuf_write + write_len),&report, 2);
			report = mb_readreportval();
			
			write_len += 2;
		}
		while(flg_netdisconnect) sleep(1);
		pthread_mutex_lock(&netsend_lock);
		if (send(local_fd, netbuf_write, write_len, 0) < 0)
		perror("write net\n");
		pthread_mutex_unlock(&netsend_lock);
	}
		pthread_mutex_unlock(&report_lock);
*/
}

/******************************************************************************
*
* Function Name  : CloseAllDevice
* Description    :  GPIO initialization, configuration GPIO 0~19 output, 20~31 input mode.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void sb_serialclose(void)
{
	int i;

	for (i = 0; i < 10; i++)
		if (serail_hand[i] > 0)
			close(serail_hand[i]);
}

/**************************更新初始化文件*******************************/
void mb_updateconfilefrornet(void)
{
//		char pstring[1000] = {0};
//	char fread_buffer[50]={0};
//	char pchar;
	unsigned int i = 0;
	int netread_len;
	FILE * fp=NULL;
	
	remove(MeasureConfigPath);
	if ((fp = fopen(MeasureConfigPath, "w+")) == NULL)
				perror("open file error\n");
	while(!flg_mainproexit)						//读取网口命令
	{	
		memset(netbuf_read, 0, 1000);
		while(1)
		{
			if ((netread_len = read(local_fd, netbuf_read, 1000)) < 0)//要求pc端一个包不大于1000字节，一次为一张玻片的操作
			{
			//	perror("[mb_updateconfilefrornet]read netdata error\n");
			}
			else 
				break;
			usleep(1000);
		}
		//else
		{
			printf("[mb_updateconfilefrornet]netdata recieved\n");	//配置信息需使用字符串形式收发			
			printf("netread_len=%d netbuf_read=  \n", netread_len); 
			printf("\n");
			
		//	printf("fgetc(fp)=%c\n",fgetc(fp));
			for (i = 0; i < netread_len; i++)
			{
				printf("%c",netbuf_read[i]);
				if (fputc(netbuf_read[i],fp) < 0)
					perror("fput error\n");
			}
			
				
				if (strcmp((char*)&netbuf_read[netread_len - 3],"END" ) != 0)	//end of the file
				continue;
			else
			{
				fclose(fp);
				break;
			}
			printf("\n");
		}
		usleep(1000);	
	}
}

void DischargeHighWork(char tim)
{
	
		pthread_mutex_lock(&pump_lock);
		printf("The task is mb_dischwasteliquid_hi.\n");
		lprintf(log_my, INFO,"The task is mb_dischwasteliquid_hi.\n");
		inDischarge = TRUE;

	sleep(5);//确保吸液控制已关闭
		GPIO_OutClear(V1);
		GPIO_OutClear(V2);
		GPIO_OutClear(V3);
		GPIO_OutClear(V4);
		sleep(1);
		GPIO_OutClear(V9);
		GPIO_OutSet(V8);
		GPIO_OutClear(V7);
		GPIO_OutClear(V5);
		GPIO_OutSet(V6);
		GPIO_OutSet(VP1);
	
		sleep(tim);
	
		GPIO_OutClear(V8);
		GPIO_OutSet(V9);
		sleep(3);
		GPIO_OutClear(VP1);
		GPIO_OutClear(V8);
		GPIO_OutClear(V7);
		GPIO_OutClear(V5);
		GPIO_OutClear(V6);
		sleep(3);
		if (pthread_mutex_unlock(&pump_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
		inDischarge = FALSE;

}


/******************************************************************************
	
	排高浓度废液
*******************************************************************************/
BOOL mb_dischwasteliquid_hi(char tim)
{
	unsigned int dwPinState;
	static char Iserror = 0;

	if (Iserror)
		return TRUE;
	
	DischargeHighWork(tim);

	

	dwPinState = In_H;
	GPIO_PinState(&dwPinState);
			if (NEW_INWATST_SEN)
	{
		if ((dwPinState & In_H) == 0)
		{	
		DischargeHighWork(tim);		
				GPIO_PinState(&dwPinState);
				if ((dwPinState & In_H) == 0)
				{	
			printf("mb_dischwasteliquid_hi error\n");
		Iserror = 1;
			mb_seterrorcode(WAST_LIUID_HIGH);
				}
		 }	
	}
	else
	{
		if ((dwPinState & In_H) != 0)
		{
	DischargeHighWork(tim); 		
				GPIO_PinState(&dwPinState);
				if ((dwPinState & In_H) != 0)
				{	
			printf("mb_dischwasteliquid_hi error\n");
		
			mb_seterrorcode(WAST_LIUID_HIGH);
				}
		 }	
	}


	return TRUE;
}

void mb_phydischanrgelo(char tim)
{
	
	
	pthread_mutex_lock(&pump_lock);
	printf("The task is mb_dischargwateliquid_lo.\n");
	lprintf(log_my, INFO,"The task is mb_dischargwateliquid_lo.\n");
	inDischarge = TRUE;
	sleep(5);//确保吸液控制已关闭
	
	GPIO_OutClear(V1);
	GPIO_OutClear(V2);
	GPIO_OutClear(V3);
	GPIO_OutClear(V4);
	sleep(1);
	GPIO_OutClear(V8);
	GPIO_OutSet(V9);
	GPIO_OutClear(V7);
	GPIO_OutSet(V5);
	GPIO_OutSet(V6);
	GPIO_OutSet(VP1);

	sleep(tim);
	GPIO_OutClear(V9);
	GPIO_OutSet(V8);
	sleep(3);
	GPIO_OutClear(VP1);
	GPIO_OutClear(V9);
	GPIO_OutClear(V7);
	GPIO_OutClear(V5);
	GPIO_OutClear(V6);
	sleep(3);//防止飞溅
	if (pthread_mutex_unlock(&pump_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
	inDischarge = FALSE;
}

/******************************************************************************
排低浓度废液
GPIO_OutClear为关闭
*******************************************************************************/
BOOL mb_dischargwateliquid_lo(char tim)
{
	unsigned int dwPinState;
	static char Iserror = 0;

	if (Iserror)
		return TRUE;
	
	mb_phydischanrgelo(tim);	

	dwPinState = In_L;
	GPIO_PinState(&dwPinState);

	
	if (NEW_INWATST_SEN)
	{
		if ((dwPinState & In_L) == 0)
		{
		
		mb_phydischanrgelo(tim);	
		
				GPIO_PinState(&dwPinState);
				if ((dwPinState & In_L) == 0)
				{	
			printf("mb_dischwasteliquid_hi error\n");
		Iserror = 1;
			mb_seterrorcode(WAST_LIUID_LOW);
				}
		 }	
	}
	else
	{
		if ((dwPinState & In_L) != 0)
		{
		
		mb_phydischanrgelo(tim);	
		
				GPIO_PinState(&dwPinState);
				if ((dwPinState & In_L) != 0)
				{	
			printf("mb_dischwasteliquid_hi error\n");
		
			mb_seterrorcode(WAST_LIUID_LOW);
				}
		 }	
	}
	return TRUE;
}

/******************************************************************************
排玻片架的残留液
参数shelf 1，2，3对应三组玻片架 4大仪器废液瓶
GPIO_OutClear 关闭
*******************************************************************************/
BOOL mb_dischargeshelfwateliquid(unsigned char shelf)
{
	BOOL DischargeLock_NEED_UNLOCK = FALSE;
	static char cnt = 0;
	
	if (!flg_lockdischargliquit)
		{
			pthread_mutex_lock(&mutex_dischargelock);
			flg_lockdischargliquit = TRUE;
			DischargeLock_NEED_UNLOCK = TRUE;
		}
	printf("The task is mb_dischargeshelfwateliquid.\n");
	lprintf(log_my, INFO,"The task is mb_dischargeshelfwateliquid.\n");
	pthread_mutex_lock(&pump_lock);
			GPIO_OutClear(V1);
			GPIO_OutClear(V2);
			GPIO_OutClear(V3);
			GPIO_OutClear(V4);
			GPIO_OutClear(V8);
			GPIO_OutClear(V9);
			GPIO_OutSet(V7);
			GPIO_OutClear(V5);
			GPIO_OutClear(V6);
			GPIO_OutSet(VP1);
	
	
	sleep(5);//抽真空
	#ifdef BIG_VERSION
	GPIO_OutSet(V10);
	sleep(2);
	GPIO_OutClear(V10);
	#endif
	if(shelf == 1)
	{
			GPIO_OutSet(V1);
			sleep(6);
			GPIO_OutClear(V1);
	}
	else if(shelf == 2)
	{
			GPIO_OutSet(V2);
			sleep(6);
			GPIO_OutClear(V2);
	}
	else if (shelf == 3)
	{
			GPIO_OutSet(V3);
			sleep(6);
			GPIO_OutClear(V3);
	}
#ifdef BIG_VERSION
	else if (shelf == 4)
	{
			GPIO_OutSet(V10);
			sleep(6);
			GPIO_OutClear(V10);
	}
#endif
	
	GPIO_OutClear(VP1);
	GPIO_OutClear(V7);

if (pthread_mutex_unlock(&pump_lock) != 0)
	lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
if (DischargeLock_NEED_UNLOCK)
	{
		if (pthread_mutex_unlock(&mutex_dischargelock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_dischargelock");
		flg_lockdischargliquit = FALSE;
	}

	return TRUE;
}
/******************************************************************************
*
* Function Name  : md_gpiointion
* Description    : GPIO initialization, configuration GPIO 0~11,15~23 output;12~14, 24~31 input mode.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int md_gpiointion(void)
{
	int				rc = 0;
//	unsigned int	dwPinState = 0x002fffff;
	char ee = 0xee;
unsigned int	dwPinState = 0xffffffff;
char i=0;
	

#ifdef BIG_VERSION
{
	dwPinState = 0xCFFF03DF;
	GPIO_fd = open("/dev/esm6800_gpio", O_RDWR);
}
#else
{
	dwPinState = 0x0ffffe0f;
	GPIO_fd = open("/dev/em9280_gpio", O_RDWR);
}
#endif


	
	printf("GPIO_fd open file = %d\n", GPIO_fd);

	rc = GPIO_OutEnable(dwPinState);	//
	if(rc < 0)
	{
		printf("GPIO_OutEnable::failed %d\n", rc);
		return -1;
	}
	



if (SHELF_LOCK_WAY_NEW)
{
	GPIO_OutClear(CGLOCK1);
	GPIO_OutClear(CGLOCK2);
	GPIO_OutClear(CGLOCK3);
	GPIO_OutClear(CGLOCK4);
}
else
{
	GPIO_OutSet(CGLOCK1);
	GPIO_OutSet(CGLOCK2);
	GPIO_OutSet(CGLOCK3);
	GPIO_OutSet(CGLOCK4);

}

	
	GPIO_OutClear(V1);
	GPIO_OutClear(V2);
	GPIO_OutClear(V3);
	GPIO_OutClear(V4);
	GPIO_OutClear(V5); 
	GPIO_OutClear(V6);
	GPIO_OutClear(V7);
	GPIO_OutClear(V8);
	GPIO_OutClear(V9);
	GPIO_OutClear(VP1);

	
#ifdef BIG_VERSION
		GPIO_OutClear(RS485RW);
		GPIO_OutClear(V10);
		
#ifdef EMCTST

		GPIO_OutSet(TEM_KEYA);
	GPIO_OutSet(TEM_KEYB);
	GPIO_OutSet(TEM_KEYC);
#else
	
	GPIO_OutClear(TEM_KEYA);
	GPIO_OutClear(TEM_KEYB);
	GPIO_OutClear(TEM_KEYC);
	
	#endif
#else


	#ifdef EMCTST

	GPIO_OutClear(TEM_KEYA);
	GPIO_OutClear(TEM_KEYB);
	GPIO_OutClear(TEM_KEYC);


#else
	
			GPIO_OutSet(TEM_KEYA);
	GPIO_OutSet(TEM_KEYB);
	GPIO_OutSet(TEM_KEYC);
	#endif
	

#endif		
/*
		while(1)
			{
		GPIO_OutClear(V1);
	GPIO_OutClear(V2);
	GPIO_OutClear(V3);
	GPIO_OutClear(V4);
	GPIO_OutClear(V5); 
	GPIO_OutClear(V6);
	GPIO_OutClear(V7);
	GPIO_OutClear(V8);
	GPIO_OutClear(V9);
	GPIO_OutClear(V10);
	GPIO_OutClear(VP1);
	GPIO_OutClear(CGLOCK1);
	GPIO_OutClear(CGLOCK2);
	GPIO_OutClear(CGLOCK3);
	GPIO_OutClear(CGLOCK4);
	GPIO_OutClear(BEEPER);
	sleep(1);
			GPIO_OutSet(V1);
	GPIO_OutSet(V2);
	GPIO_OutSet(V3);
	GPIO_OutSet(V4);
	GPIO_OutSet(V5); 
	GPIO_OutSet(V6);
	GPIO_OutSet(V7);
	GPIO_OutSet(V8);
	GPIO_OutSet(V9);
	GPIO_OutSet(V10);
	GPIO_OutSet(VP1);
	GPIO_OutSet(CGLOCK1);
	GPIO_OutSet(CGLOCK2);
	GPIO_OutSet(CGLOCK3);
	GPIO_OutSet(CGLOCK4);
	GPIO_OutSet(BEEPER);
			sleep(1);
	

			}
*/
	if (!flg_mainproexit)
		GPIO_OutSet(ER_LED);// 错误退出时调用 md_gpiointion
		
	return 1;
}


/******************************************************************************
*
* Function Name  : GPIO_OutEnable
* Description    : GPIO output enable.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int GPIO_OutEnable(unsigned int dwEnBits)
{
	int fd = 0,  rc;
	struct double_pars	dpars;

	dpars.par1 = EM9280_GPIO_OUTPUT_ENABLE;		// 0
	dpars.par2 = dwEnBits;

	rc = write(GPIO_fd, &dpars, sizeof(struct double_pars));
	return rc;
}

/******************************************************************************
*
* Function Name  : GPIO_OutDisable
* Description    : GPIO output disable.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int GPIO_OutDisable(unsigned int dwDisBits)
{
	int fd = 0,  rc;
	struct double_pars	dpars;

	dpars.par1 = EM9280_GPIO_OUTPUT_DISABLE;	// 1
	dpars.par2 = dwDisBits;
	rc = write(GPIO_fd, &dpars, sizeof(struct double_pars));
	return rc;
}

/******************************************************************************
*
* Function Name  : GPIO_OutSet
* Description    : Set GPIO output mode.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int GPIO_OutSet(unsigned int dwSetBits)
{
	int fd = 0,  rc;
	struct double_pars	dpars;

//硬件上F300电路板io输出与S300相反
#ifdef BIG_VERSION
	dpars.par1 = EM9280_GPIO_OUTPUT_CLEAR;	// 2
//	printf("big clean\n");
#else 
	dpars.par1 = EM9280_GPIO_OUTPUT_SET;	// 2
#endif
	dpars.par2 = dwSetBits;

//	if (CGLOCK3 == dwSetBits)
	//	printf("CGLOCK3 OutSet\n");
	rc = write(GPIO_fd, &dpars, sizeof(struct double_pars));
	return rc;
}

/******************************************************************************
*
* Function Name  : GPIO_OutClear
* Description    : Clear GPIO output mode.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int GPIO_OutClear(unsigned int dwClearBits)
{
	int fd = 0,  rc;
	struct double_pars	dpars;

	#ifdef BIG_VERSION
	dpars.par1 = EM9280_GPIO_OUTPUT_SET;	// 2
//	printf("big set dwClearBits=%d\n",dwClearBits);
#else 
	dpars.par1 = EM9280_GPIO_OUTPUT_CLEAR;	// 2
#endif
	dpars.par2 = dwClearBits;
	
//	if (CGLOCK3 == dwClearBits)
//		printf("CGLOCK3 OutClear\n");

	rc = write(GPIO_fd, &dpars, sizeof(struct double_pars));
	return rc;
}

int GPIO_PinState( unsigned int* pPinState)
{
	int 				rc;
	struct double_pars	dpars;

	dpars.par1 = EM9280_GPIO_INPUT_STATE;	// 5
	dpars.par2 = *pPinState;

	rc = read(GPIO_fd, &dpars, sizeof(struct double_pars));
	if(!rc)
	{
		*pPinState = dpars.par2;
	}
	return rc;
}

/******************************************************************************
*
* Function Name  : GPIO_PinState
* Description    : Gets one GPIO pin status.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
/*
int GPIO_PinState2(unsigned int* pPinState)
{
	int fd = 0,  rc;
	struct double_pars	dpars;
	unsigned int	dwPinState;

	dpars.par1 = EM9280_GPIO_INPUT_STATE;	// 5
	dpars.par2 = *pPinState;
	fd = open("/dev/em9280_gpio", O_RDWR);


	for(;;)
	{
		dwPinState = 0xffffffff;				// read states of all bits
	rc = GPIO_PinState2(fd, &dwPinState);
	if(rc < 0)
	{
		printf("GPIO_PinState::failed %d\n", rc);
		return rc;
	}
	printf("PinState = 0x%08x\n", dwPinState);

	sleep(1);
		
		
	}

	close(fd);
	return rc;
}
*/
int PWM_Start(int fd, int freq, int duty )
{
	int 					rc;
	struct stmb_pwmconf	conf;

	conf.cmd = EM9280_PWM_START;
	conf.freq = freq;
	conf.duty = duty;
	conf.polarity = POLARITY;

	rc = write(fd, &conf, sizeof(struct stmb_pwmconf));
	return rc;
}

int PWM_Stop(int fd )
{
	int 					rc;
	struct stmb_pwmconf	conf;

	memset( &conf, 0, sizeof(struct stmb_pwmconf));
	conf.cmd = EM9280_PWM_STOP;

	rc = write(fd, &conf, sizeof(struct stmb_pwmconf));
	return rc;

}

int Vacuum_Work(BOOL isFirst)	//GPIO_OutSet 为 关闭
{}
	

int Compressor_Work(void)
{
	return 0;
}

int SendArmCabinWork(ArmCabinCmd armcmd, char shelfnum,char reagent,char pos,char val)
{

	return 0;
}

#ifdef BIG_VERSION
int mb_beeperproce(void)
{	
	unsigned int	duty = 50;
	unsigned char FREQH[] ={0xF2,0xF3,0xF5,0xF5,0xF6,0xF7,0xF8,//低音1234567?????
						0xF9,0xF9,0xFA,0xFA,0xFB,0xFB,0xFC,0xFC,//1// ,2,3,4,5,6,7,i?????
						0xFC,0xFD,0xFD,0xFD,0xFD,0xFE,//高音?234567?????
						0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF};//超高音?1234567
	int fd = 0;
	
	if (ewkevent == MAINTAIN_WORK)
	return 0;
	
	if (beep_state.door == 0 && beep_state.cabin == 0 && beep_state.error == 0)
	{
		GPIO_OutClear(BEEPER);
	}
	else if ((beep_state.door == 1 || beep_state.cabin == 1) && beep_state.error == 0)
	{
		while(1)
		{
			GPIO_OutClear(BEEPER);
			if ((beep_state.door == 1 || beep_state.cabin == 1) && beep_state.error == 0)
			{}
			else	break;
			
			GPIO_OutSet(BEEPER);
			usleep(300000);
			GPIO_OutClear(BEEPER);
			usleep(3000000);
		}
	}
	else if (beep_state.error == 1)
	{
		
		while(beep_state.error == 1)
		{
			GPIO_OutSet(ER_LED);
			GPIO_OutSet(BEEPER);
			usleep(500000);
			GPIO_OutClear(ER_LED);
			GPIO_OutClear(BEEPER);
			usleep(500000);
		}
	}
	
	return 0;

}
#else

//fr == 0 停止声音 fr == 1 通知声 fr == 2 报警声
int mb_beeperproce(void)
{	
	unsigned int	duty = 50;
	unsigned char FREQH[] ={0xF2,0xF3,0xF5,0xF5,0xF6,0xF7,0xF8,//低音1234567?????
						0xF9,0xF9,0xFA,0xFA,0xFB,0xFB,0xFC,0xFC,//1// ,2,3,4,5,6,7,i?????
						0xFC,0xFD,0xFD,0xFD,0xFD,0xFE,//高音?234567?????
						0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF};//超高音?1234567
	int fd = 0;
	
	if (ewkevent == MAINTAIN_WORK)
	return 0;
	
	if (beep_state.door == 0 && beep_state.cabin == 0 && beep_state.error == 0)
	{
		GPIO_OutSet(BEEPER);
	}
	else if ((beep_state.door == 1 || beep_state.cabin == 1) && beep_state.error == 0)
	{
		while(1)
		{
			GPIO_OutSet(BEEPER);
			if ((beep_state.door == 1 || beep_state.cabin == 1) && beep_state.error == 0)
			{}
			else	break;
			
			GPIO_OutClear(BEEPER);
			usleep(300000);
			GPIO_OutSet(BEEPER);
			usleep(3000000);
		}
	}
	else if (beep_state.error == 1)
	{
		
		while(beep_state.error == 1)
		{
			GPIO_OutSet(ER_LED);
			GPIO_OutClear(BEEPER);
			usleep(500000);
			GPIO_OutClear(ER_LED);
			GPIO_OutSet(BEEPER);
			usleep(500000);
		}
	}
	
	return 0;
	fd = open("/dev/em9280_pwm4", O_RDWR);
	if ( fd < 0)
	{
		printf("can not open /dev/em9280_pwm4 device file!\n");
		return -1;
	}
	while(!flg_mainproexit)
	{
	//	for (i = 0;i < sizeof(FREQH);i++)
		{
			
			PWM_Start( fd, FREQH[0] * 2, duty );
			sleep(1);
			PWM_Start( fd, FREQH[7] * 2, duty );
			sleep(1);
		}
	}
	
	PWM_Stop( fd);
	

}
#endif

BOOL mb_checksensorproce(void)
{
	unsigned int dwPinState,i;
	static BOOL DOOR_OPEN_SENDED = FALSE,WAST_LIUID_HIGH_SENDED=FALSE,WAST_LIUID_LOW_SENDED=FALSE,
		 WAST_LIUID_HIGH_ENDED=FALSE,
		 CG1_SCANED[4] = {FALSE};
	static BOOL LAST_STATE[4] = {0};
	static int scan_cnt = 0;
	static struct timeval disc_now,last_disc;
	static char IsWastError = 0;
//return 0;

gettimeofday(&disc_now, NULL);

//printf("in sensor_check disc_now.tv_sec=%d last_disc.tv_sec=%d\n",disc_now.tv_sec,last_disc.tv_sec);

	
	if(disc_now.tv_sec > (last_disc.tv_sec + 60*20) )
	{
	printf("discharge time reach\n");
	//	mb_dischargwateliquid_lo(DischargeTime);	
		last_disc.tv_sec = disc_now.tv_sec;
	}
#if 1
#if 1
	dwPinState = DOOR;
	GPIO_PinState(&dwPinState);
//	printf("PinState = 0x%08x\n", dwPinState);
	if ((dwPinState & DOOR) != 0)			//在洗针时pthread_mutex_lock(&mutex_dischargelock);，门打开暂停洗针
	{										//，ExcuteOperate中不能pthread_mutex_lock(&mutex_dischargelock)
		if (DOOR_OPEN_SENDED == FALSE)		//而门检测与ExcuteOperate同以县城导致死锁不能正常运行所以门检测需其他线程中
		{
			DOOR_OPENDED = TRUE;
			beep_state.door = 1;
				mb_seterrorcode(DOOR_OPEN);
			DOOR_OPEN_SENDED = TRUE;
		//	return FALSE;
		}
	}
	else
	{	
	//	printf("DOOR_OPEN_SENDED=%d\n",DOOR_OPEN_SENDED);
		if (DOOR_OPEN_SENDED == TRUE)
		{
			DOOR_OPEN_SENDED = FALSE;
			DOOR_OPENDED = FALSE;
			mb_seterrorcode(DOOR_OPEN | 0X01000000);
			beep_state.door = 0;
		}
	}
#endif

	dwPinState = POWER_SEN;
	GPIO_PinState(&dwPinState);	
//	printf("PinState = 0x%08x\n", dwPinState);
	if ((dwPinState & POWER_ERROR) == 1)
	{
		printf("^^^^^^^^^^^^POWER_ERROR^^^^^^^^^^^^^");
		mb_seterrorcode(POWER_ERROR);
	}
	

	dwPinState = Out_H;
	GPIO_PinState(&dwPinState);	
//	printf("PinState = 0x%08x\n", dwPinState);
if(NEW_OUTWATST_SEN)
{
	if ((dwPinState & Out_H) == 0)
	{
		if (OUT_WASTHIGH_H == FALSE)
		{
			printf("^^^^^^^^^^^^Out_H^^^^^^^^^^^^^");
			mb_seterrorcode(WAST_LIUID_HIGH_FULL);
			OUT_WASTHIGH_H = TRUE;
			
		}
	}
}
else
{
	if ((dwPinState & Out_H) != 0)
		{
			if (OUT_WASTHIGH_H == FALSE)
			{
				printf("^^^^^^^^^^^^Out_H^^^^^^^^^^^^^");
				mb_seterrorcode(WAST_LIUID_HIGH_FULL);
				OUT_WASTHIGH_H = TRUE;
				
			}
		}

}
	dwPinState = Out_L;
	GPIO_PinState(&dwPinState);	
//	printf("PinState = 0x%08x\n", dwPinState);
if(NEW_OUTWATST_SEN)
{
	if ((dwPinState & Out_L) == 0)
		{
			if(OUT_WASTHIGH_L == FALSE)
			{
				printf("^^^^^^^^^^^^Out_L^^^^^^^^^^^^^");
				mb_seterrorcode(WAST_LIUID_LOW_FULL);
				OUT_WASTHIGH_L = TRUE;
				
			}
		}

}
else
{
	if ((dwPinState & Out_L) != 0)
	{
		if(OUT_WASTHIGH_L == FALSE)
		{
			printf("^^^^^^^^^^^^Out_L^^^^^^^^^^^^^");
			mb_seterrorcode(WAST_LIUID_LOW_FULL);
			OUT_WASTHIGH_L = TRUE;
			
		}
	}
}


	dwPinState = In_H;
	GPIO_PinState(&dwPinState);
//	printf("PinState = 0x%08x In_H = 0x%08x\n", dwPinState,In_H);
	if (NEW_INWATST_SEN)
	{
		if ((dwPinState & In_H) == 0)
		{	printf("^^^^^^^^^^^^In_H^^^^^^^^^^^^^");
			mb_dischwasteliquid_hi(DischargeTime);		
		last_disc.tv_sec = disc_now.tv_sec;
		}
	}
	else
	{
		if ((dwPinState & In_H) != 0)
		{	printf("^^^^^^^^^^^^In_H^^^^^^^^^^^^^");
			mb_dischwasteliquid_hi(DischargeTime);	
		last_disc.tv_sec = disc_now.tv_sec;
		}
	}
	dwPinState = In_L;
	GPIO_PinState(&dwPinState);
//	printf("PinState = 0x%08x In_L= 0x%08x\n", dwPinState,In_L);
	if (NEW_INWATST_SEN)
	{
		if ((dwPinState & In_L) == 0)
		{	printf("^^^^^^^^^^^^In_L^^^^^^^^^^^^^");
			mb_dischargwateliquid_lo(DischargeTime);	
		last_disc.tv_sec = disc_now.tv_sec;
		}
	}
	else
	{
		if ((dwPinState & In_L) != 0)
		{	printf("^^^^^^^^^^^^In_L^^^^^^^^^^^^^");
			mb_dischargwateliquid_lo(DischargeTime);	
		last_disc.tv_sec = disc_now.tv_sec;
		}
	}

#endif	

	#ifdef BIG_VERSION
	dwPinState = In_W;
	GPIO_PinState(&dwPinState);

	if ((dwPinState & In_W) == 0 && !IsWastError)
		{	printf("^^^^^^^^^^^^In_W^^^^^^^^^^^^^");
			mb_dischargeshelfwateliquid(4);	
		if ((dwPinState & In_W) == 0)
		{
			printf("DischargeWASTEWasteLiquid error\n");
		IsWastError = 1;
			mb_seterrorcode(WAST_LIUID_WAST);
		}
		last_disc.tv_sec = disc_now.tv_sec;
		}
	
	if(scan_cnt++ > 3)
	{
		scan_cnt = 0;
		GetMixStationVal(4,0);
		for (i = 0; i < 4; i++)
		{
	//	printf("LAST_STATE[%d]= %d reagent_check[%d].STATE=%d\n",i, LAST_STATE[i],i,reagent_check[i].STATE );
			if(LAST_STATE[i]  != reagent_check[i].STATE)
			{
			printf("set scannum=%d\n", i);
				if( reagent_check[i].STATE == TRUE)//有mix直接返回是否扫描
					//{}
				 	reagent_check[i].NEED_SCAN = TRUE;
				else
					mb_cancelreagentwork(i + 1);
			}
			
			LAST_STATE[i] = reagent_check[i].STATE;
		}
	}
	#else
	for (i = 0; i < 4; i++)
	{
		dwPinState = reagent_check[i].sen;
		GPIO_PinState(&dwPinState);
		
		if ((dwPinState & (reagent_check[i].sen)) == 0)
		{
		//	printf("in CG%d\n",i + 1);
			if (!CG1_SCANED[i])
			{printf("reagent_check[%d].NEED_SCAN",i);
			if (ewkevent != MAINTAIN_WORK)
				reagent_check[i].NEED_SCAN = TRUE;
			
				CG1_SCANED[i] = TRUE;
		//	printf("reagent_check[%d].NEED_SCAN = %d",i,reagent_check[i].NEED_SCAN);
			}
		}
		else
		{
		//	printf("out CG%d\n",i + 1);
			reagent_check[i].NEED_SCAN = FALSE;
			if (CG1_SCANED[i] == TRUE)
			{
				CG1_SCANED[i] = FALSE;
				
				mb_cancelreagentwork(i + 1);	//使流程中试剂无效 并将有效试剂加入outside链表中
			}
		}
	}
	
	#endif
	return TRUE;
	
}

/******************************************************************************
*
* Function Name  : sb_checkbytesbit
* Description    : Gets one GPIO pin status.
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
unsigned char sb_checkbytesbit(char x, char n)
{
	assert(n < 8);
	
	return ( x & (0x01 << n) ); //n = 0-7 如要n用 1-8表示则表达式改为( x | (0x01<<(n-1)) ); 
}

/******************************************************************************
*
* Function Name  : sb_findframeheadtailflg
* Description    : .
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
int sb_findframeheadtailflg(unsigned char *FrameBuff, int *FrameLen, int ReadLen)
{
	char *pFrameCnt = NULL;
	int pCnt = 0;
	unsigned char found = 0, start_flag = 0;
	 int counter = 0;
	
	pFrameCnt = (char *)FrameBuff;
//	printf("[sb_findframeheadtailflg]: Framelen = %d, pCnt = %d, counter = %d, ReadLen = %d.\n", *FrameLen, pCnt, counter, ReadLen);
	
	while (!found && (pFrameCnt != NULL))
	{
		if (counter >= ReadLen) {
			counter = 0;
			return 0;
		}
		
		pCnt++;
		
		if (!start_flag && 
			(*pFrameCnt == STX_FLAG))
			start_flag = 1;
		if (start_flag && 
			(*pFrameCnt == ETX_FLAG))
		{
			found = 1;
			*FrameLen = pCnt + 1;
			counter += *FrameLen;
			
			if (counter >= ReadLen) 
				counter = 0;
			//printf("2.[sb_findframeheadtailflg]: Framelen = %d, pCnt = %d, counter = %d.\n", *FrameLen, pCnt, counter);
			return found;
		}
		
		pFrameCnt++;
		counter++;
	}
//	printf("sb_findframeheadtailflg finished\n");
	return found;
}


/******************************************************************************
*
* Function Name  : Tecan_OEM_Command
* Description    : RSP 9000 II and XLP6000 command frame .
*                      
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
 
int sb_armpumpsend(emb_comid comPort, unsigned char *SndCmdStr, unsigned char srdevaddr, unsigned char seq, unsigned char isReaptSnd, unsigned char ConnectMode)
	{
			unsigned char WDataLength = 0;	//写入串口的数据长度
			unsigned char WriteBuffer[256]; //Com Device Write Buffer
			int write_len = 0;
			int cmdStrLength = 0;
			int fd = 0;
			static unsigned char seq_num = 1; 
		
			if (flg_mainproexit)
				return -1;

			if(flg_intosleep)
				return 1;
//		if (srdevaddr == ARM_ADDR)
//		return 1 ;
			if (seq_num > 7)
				seq_num = 1;
			if (srdevaddr == ARM_ADDR)
				comPort = port_arm;
			else
			{
				comPort = port_pump;
//return 1;//tst
			}
			
				fd =  serail_hand[comPort];

			if (SndCmdStr == NULL)	//接收到answer后 发送ACK
			{
				cmdStrLength = 0;
			}
			else
				cmdStrLength = strlen((char *)SndCmdStr);
			
		//	if (comPort == port_arm)
		//	if (srdevaddr == ARM_ADDR)
			if(cmdStrLength != 2 || SndCmdStr[0] == 'Z')
				{
				printf("[RSP_OEM_Command]: Write cmd [%s]\n ", SndCmdStr);
			lprintf(log_my, INFO,"Write cmd [%s]\n ",SndCmdStr);
				}
		
				
			/* Pack the frame */
			if (srdevaddr == ARM_ADDR)
				{
				// the pump connect with RSP9000
					if (SndCmdStr != NULL)	//接收到answer后 发送ACK
					{
						WDataLength = sb_frameconver2rsp9000((char *) SndCmdStr, cmdStrLength, srdevaddr, seq_num, isReaptSnd, WriteBuffer);
					}
					else
					{
						WDataLength = sb_frameconver2rsp9000((char *) SndCmdStr, cmdStrLength, srdevaddr, 0, 0, WriteBuffer);
						if (seq != 0)	//seq == 0为 超时重发 
							seq_num++;			//SndCmdStr == NULL发送ACK后 为下一命令准备 自加
					}
				}
			else // the pump connect the RS232 serial independence
				{
			//	return 1;
				
					WDataLength = CanverFrameContentToXLP6000((char *) SndCmdStr, cmdStrLength, seq_num, isReaptSnd, WriteBuffer);
					if (seq != 0)	//seq == 0为 超时重发 
						seq_num++;	
				}
		
			
				
			
		//	printf("WDataLength = %d fd = %d\n", WDataLength, fd);
		//	printf("\n");
			
				flg_armack = 0;
				sr_armansercode = 0;
				tcflush( fd,TCOFLUSH);
				write_len = write(fd, WriteBuffer,	WDataLength);
			//	printf("\nSend END\n\n");
			
#if 0	
			write_len = write(fd, &test, 2);
			if (write_len < 0)
			{
				tcflush( fd,TCOFLUSH);
				printf("write error\n");
			}
			else
				printf("write success\n");
			
			while(!flg_mainproexit)
			{
			tcflush( fd,TCOFLUSH);
			write_len = write(fd, WriteBuffer, 23);
		//	write_len = write(fd, &test, 1);
		
			if (write_len < 0)
			{
				printf("write error\n");
			}
			tcflush( fd,TCOFLUSH);	
			usleep(2000);
			}
#endif
		//	tcdrain(fd);
		
			return write_len;
		}


/******************************************************************************
*
* Function Name  : RSP_OME_Command
* Description	 : The string according to the RSP9000 OME communication protocol format function.
*					   
* Input 		 : None
* Output		 : None
* Return		 : None
*******************************************************************************/
int sb_frameconver2rsp9000(char* cmdStr, int cmdStrLength, unsigned char DeviceAddr, unsigned char seq, unsigned char isCmdRepeat, unsigned char *WriteBuffer)
{
	int i;
	int WDataLength = 0;
	unsigned char control = 0;
	unsigned char checksum = 0;

	//数据帧开始字节
	WriteBuffer[0] = STX_FLAG;

	if (isCmdRepeat)
		control = 0x08;	// control the Req is 1, then Command repeated

//	printf("isCmdRepeat=%d  seq = %d control %x\n", isCmdRepeat,seq, control);

	control |= 0x40;	// control, 4,5,67 bit is 0100

//	printf("[sb_frameconver2rsp9000]: seq =  %d.\n", seq);
	switch (seq)
	{
		case 1:
			control |= 0x01;	// seq#0
			break;
		case 2:
			control |= 0x02;	// seq#1
			break;
		case 3:
			control |= 0x03;	// seq#0,#1
			break;
		case 4:
			control |= 0x04;	// seq#2
			break;
		case 5:
			control |= 0x05;	// seq#2,#0				
			break;
		case 6:			
			control |= 0x06;	// seq#2,#1
			break;
		case 7:
			control |= 0x07;	// seq#0,#1,#2
			break;
		default:
			break;
	}
	
	WriteBuffer[1] = control;
	WriteBuffer[2] = 0X31;
	WriteBuffer[3] = DeviceAddr;

	WDataLength += 4;
	
	//Do copy the Message block
	if ((cmdStr != NULL) && (cmdStrLength != 0)) {
		memcpy((void *)&WriteBuffer[4], (void *)cmdStr, cmdStrLength);
		WDataLength += cmdStrLength;
	}

	
	// The communication data end byte
	WriteBuffer[WDataLength] = ETX_FLAG;
	WDataLength += 1;
	
	// calculate the VRC
	for (i = 0;i < WDataLength; i++) 
		checksum ^= WriteBuffer[i];	// XOR acceptance value

	// The VRC byte
	WriteBuffer[WDataLength] = checksum;
	WDataLength += 1;
	
#if PRINTF
	printf("[sb_frameconver2rsp9000].Send To Comm:\n");
	for(i = 0;i < WDataLength; i++)
		printf(" %x ",WriteBuffer[i]);
#endif

	return WDataLength;
}


int CanverFrameContentToXLP6000(char* cmdStr, int cmdStrLength, unsigned char cmdSeqNum, unsigned char isCmdRepeat, unsigned char *WriteBuffer)
{
	int i;
	int WDataLength = 0;
	unsigned char SeqNumber = 0;
	unsigned char checksum = 0;

	//数据帧开始字节
	WriteBuffer[0] = STX_FLAG;
	
	WriteBuffer[1] = PUMP_ADDR;

	if (isCmdRepeat) {			
		SeqNumber |= 0X08;
	}
	
	SeqNumber |= 0x30;	// control the 4,5,6,7 bit is 0011

	switch (cmdSeqNum)	// Here need to comford
	{
		case 1:
			SeqNumber |= 0x01;	// seq#0
			break;
		case 2:
			SeqNumber |= 0x02;	// seq#1
			break;
		case 3:
			SeqNumber |= 0x03;	// seq#0,#1
			break;
		case 4:
			SeqNumber |= 0x04;	// seq#2
			break;
		case 5:
			SeqNumber |= 0x05;	// seq#2,#0 			
			break;
		case 6: 		
			SeqNumber |= 0x06;	// seq#2,#1
			break;
		case 7:
			SeqNumber |= 0x07;	// seq#0,#1,#2
			break;
		default:
			break;
	}

	WriteBuffer[2] = SeqNumber;
	WDataLength += 3;

	//Do copy the Data block
	memcpy((void *)&WriteBuffer[3], cmdStr, cmdStrLength);
	WDataLength += cmdStrLength;
	

	// The communication data end byte
	WriteBuffer[WDataLength] = ETX_FLAG;
	WDataLength += 1;
	
	// calculate the VRC
	for (i = 0;i < WDataLength; i++) 
		checksum ^= WriteBuffer[i];	// XOR acceptance value

	// The VRC byte
	WriteBuffer[WDataLength] = checksum;
	WDataLength += 1;

#if 0
	printf("Send To Comm:\n");
	for(i = 0;i < WDataLength; i++)
		printf("%x ",WriteBuffer[i]);
	printf("\nSend END\n");
#endif
	
	return WDataLength;
}


/******************************************************************************
*
* Function Name  : RSP_OME_Command
* Description	 : The string according to the RSP9000 OME communication protocol format function.
*					   
* Input 		 : None
* Output		 : None
* Return		 : None
*******************************************************************************/
sr_tecanoemstruct_t* sb_getoemframe(FRAME_TYPE tecanOEMFrameType, unsigned char *RDataBuff, 
	unsigned int RDataLength, unsigned char*isErrFrame, int *nLen)
{
	int end, LengthCount = 0;  
	int length_needed = 0; 
	unsigned char *data = NULL;	
	unsigned char fcs = 0x00; 
	unsigned char flag_found = 0;
	unsigned char is_error_code = 0;

	sr_tecanoemstruct_t *frame = NULL; 

	//data = RDataBuff;
	data =  (unsigned char *)parminfo;		

	// Find start flag and end flag 
	flag_found = sb_findframeheadtailflg(parminfo, &LengthCount, RDataLength);
	if (!flag_found) {// no frame started	  and end
		printf("The recieve data is invaild.\n");
		return NULL;	
	}
	
//	printf("[sb_getoemframe]: LengthCount = %d\n ", LengthCount);
	switch (tecanOEMFrameType) {
		case RSP9000_FRAME: 
			length_needed = 6;	// STX, control, arm, device, ETX, fcs  ACK frame

			//if (RDataLength >= length_needed)	
			if (LengthCount >= length_needed)	
			{	 
				//data = parminfo;    
				while((frame = malloc(sizeof(sr_tecanoemstruct_t))) == NULL)
				{
					sleep(1);
					printf("malloc error sr_tecanoemstruct_t\n");
				}
				
				fcs ^= *data;	// STX
				data++;
				
				frame->control = *data;	
				fcs ^= *data;	
				data++;
				
				frame->arm_addr = *data;    
				fcs ^= *data;	
				data++;

				frame->device_addr = *data;    
				fcs ^= *data;	
				data++;
								
				//extract data
				is_error_code = sb_checkbytesbit(frame->control, 4);
				memcpy(frame->data, data, (LengthCount - length_needed));
				
			//	printf("[sb_getoemframe]: is_error_code = %d, LengthCount - length_needed = %d.\n", is_error_code, LengthCount - length_needed);
				if ((!is_error_code) && 	// Is not ack frame, error frame
					( LengthCount - length_needed > 0 )) {
			//		printf("[sb_getoemframe]: error frame--->.\n");
					*isErrFrame = 1;	// 出错
					//if ((frame->data = (unsigned char *)malloc(sizeof(char)*(LengthCount - length_needed)))) 
					memcpy(frame->data, data, (LengthCount - length_needed));
					fcs ^= frame->data[0]; 
					data++;
				}
				
				// ack frame or answer frame ETX flag
		//		printf("[sb_getoemframe]: ----------------->>>>>1.\n");
				//*isErrFrame = 2;	// 正常回复
				while(*data != 0X03)
				{
					fcs ^= *data;
					data++;
				}
				fcs ^= *data;
				
				// check FCS	, the last byte 
		//		printf("[sb_getoemframe]: ----------------->>>>>2.\n");
				if (fcs != *(++data)) {
					printf("[sb_getoemframe]: Dropping frame: FCS[%02x <---> %02x] doesn't match.\n", fcs, *data);
					return NULL;
				}
				
				*nLen += LengthCount;

				if (*data++ != NULL)
					parminfo = data;
				else
					parminfo = NULL;
			
		//		printf("[sb_getoemframe]: is_error_code = %x, isErrFrame = %d, parminfo = %x.\n", is_error_code, *isErrFrame, parminfo);
			}
			break;
			
		case XLP6000_FRAME:
			length_needed = 5;	// STX, Master address, Status code, ETX, fcs. The pump responing with ACK

			if (RDataLength >= length_needed)	
			{	 
				while((frame = malloc(sizeof(sr_tecanoemstruct_t))) == NULL)
				{
					sleep(1);
					printf("malloc error sr_tecanoemstruct_t\n");
				}
				fcs ^= *data;	// STX
				data++;

				frame->arm_addr = *data;   // master address 
				fcs ^= *data;	
				data++;

				frame->control = *data;		// status 
				fcs ^= *data;	
				data++;
								
				//extract data	 
				if ( RDataLength - length_needed > 0 ) { // data block frame
						memcpy(frame->data, data, (LengthCount - length_needed));
						
						for (end = 0; end < (LengthCount - length_needed); end++)	//计算整帧fcs
							fcs ^= (frame->data[end]);	 
				} 
				
				// answer frame ETX flag
				fcs ^= *data;						
				data++;

				// check FCS	 
				if (fcs != *data) 
					printf("Dropping frame: FCS doesn't match\n");	  
			}			
			break;
		default:
			break;
	}

	return frame;

}

int sb_parseframe(FRAME_TYPE tecanOEMFrameType, int ReadLength)
{
	int returncode = -1, pLength = 0;
	unsigned char isErrorFrame = 0;
	unsigned char frameseq = 0;
	char str_array[5] = {0};
	
	sr_tecanoemstruct_t *frame = NULL;
 
	parminfo = serail_recvbuf;
	while (frame = sb_getoemframe(RSP9000_FRAME, serail_recvbuf, ReadLength, &isErrorFrame, &pLength)) 
	//frame = sb_getoemframe(RSP9000_FRAME, serail_recvbuf, ReadLength, &isErrorFrame, &pLength);
	//if (!frame) return 0;
	
	{
		//printf("[sb_parseframe]: Recieved frame is error.\n");
		//return returncode;
	//	printf("pLength = %d ReadLength=%d\n", pLength, ReadLength);
		frameseq = frame->control & 0x07;
		if ((frame->control == 0x40) && 
			(frameseq == 0)) {	// ACK 响应帧		
			printf("in ack\n");
			sr_armansercode = 0;	//防止先接收到answer信息出现commendoverflow现象
			flg_armack = 1;
			pthread_mutex_lock(&armlock_ack);
			pthread_cond_signal(&armcondtion_ack);
			if (pthread_mutex_unlock(&armlock_ack) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_ack");
			
/*			pthread_mutex_lock(&mutex);
			flg_armack = 1;
			pthread_mutex_unlock(&mutex);
*/		//	printf("\n");
	//		printf("[sb_parseframe]: RSP9000 sent ACK to board.\n");
		} 
		else 
		{	// 应答帧
			//确保只收到anwser继续执行
			flg_armack = 1;
			pthread_mutex_lock(&armlock_ack);
			pthread_cond_signal(&armcondtion_ack);
			if (pthread_mutex_unlock(&armlock_ack) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_ack");
			
			printf("in answer\n");
			switch (isErrorFrame)
			{				
				case 0:	// answer frame 
			//		printf("[sb_parseframe]: Answer frame %d. \n", isErrorFrame);
					frameseq = 0;
					if ((returncode = sb_armpumpsend(port_arm, NULL, frame->device_addr, frameseq, 0, 1)) < 0)
						printf("[sb_parseframe]: Send ack to RSP9000 error.\n");
					
			//		printf("[sb_parseframe]: Send ack to RSP9000 successful.\n");
				
					if (flg_getedserailarr)
						{
					//		printf("frame->data[0]=%d,frame->data[1]=%d,frame->data[2]=%d,frame->data[3]=%d",
						//			frame->data[0],frame->data[1],frame->data[2],frame->data[3]);
						//	printf("\n");
							
								memcpy(str_array,(serail_recvbuf + 4),ReadLength - 6 );
								serail_dataarr = atoi(str_array) ;//selfarm -20
						//serail_dataarr = (frame->data[0]-48) * 1000 + (frame->data[1]-48) * 100 + (frame->data[2]-48)* 10  + frame->data[3]-48;
					
					//	flg_getedserailarr = FALSE;
						}
			
					sr_armansercode = 1;
					/*
					pthread_mutex_lock(&armlock_answer);
					pthread_cond_signal(&armcondtion_answer);
					if (pthread_mutex_unlock(&armlock_answer) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");
					*/
					break;
					
				case 1:	// error freame
					printf("[sb_parseframe]: Error frame %d, send the error code to PC. \n", isErrorFrame);
					frameseq = 0;
					if ((returncode = sb_armpumpsend(port_arm, NULL, frame->device_addr, frameseq, 0, 1)) < 0)
						printf("[sb_parseframe]: Send ack to RSP9000 error.\n");
					
			//		printf("[sb_parseframe]: Send ack to RSP9000 successful.\n");
			
					if ((frame->control & 0xF0) == 0X50)//正常恢复
					{
						sr_armansercode = 1;
						pthread_mutex_lock(&armlock_answer);
						pthread_cond_signal(&armcondtion_answer);
						if (pthread_mutex_unlock(&armlock_answer) != 0)
							lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");
					}
				else
					{
						if ((frame->data[0] == 0x49) || (frame->data[0] == 0x4b))//测液体错误在具体步骤中报错
						{
							sr_armansercode = frame->data[0] - 0X40;
							pthread_mutex_lock(&armlock_answer);
							pthread_cond_signal(&armcondtion_answer);
							if (pthread_mutex_unlock(&armlock_answer) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");
							
						}
						else
						{
							if (frame->data[0] == 0X54)
								sr_armansercode = 4;
							else if (frame->data[0] == 0X55)
								sr_armansercode = 5;
							else if (frame->data[0] == 0X56)
								sr_armansercode = 6;
							else
								sr_armansercode = 3;
							printf("sr_armansercode=%d@@@@@@@@@@@@@22/n",sr_armansercode);
							lprintf(log_my, INFO,"sr_armansercode=%d@/n",sr_armansercode);
							pthread_mutex_lock(&armlock_answer);	
							pthread_cond_signal(&armcondtion_answer);
							if (pthread_mutex_unlock(&armlock_answer) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");

					//		if (frame->data[0] == 0X54 || frame->data[0] == 0X55 || frame->data[0] == 0X56)
					//			sr_armansercode = 4;
							
							//受阻在具体执行位置发送//主臂命令不可以不发
							if (frame->data[0] != 0X42 && frame->data[0] != 0X43  && frame->data[0] !=  0X48 &&
								frame->data[0] != 0X54 && frame->data[0] != 0X55 && frame->data[0] != 0X56)
								mb_seterrorcode(frame->data[0] | 0X20);
							
						}
					}
					break;
				default:
					break;
			}
		}
		
	//	printf("[sb_parseframe]: control = %x, frameseq =  %x, pLength = %d\n", frame->control, frameseq, pLength);
		if (pLength == ReadLength)
			break;
		else if (frame->control != 0x40)//当多个帧粘连时接受到回复消息时不再处理同个帧后续字节
			break;
			
	}
	free(frame);
	frame = NULL;
//	printf("[sb_parseframe]: go to listen message.\n\n");
	return returncode;
}

/******************************************************************************
*
* Function Name  : sb_waitingframeaswer
* Description    : .等待知道主臂动作完成
* 					 
* Input		   :sr_cmdstruct_t * CommandElemt 
* Output		   :None
* Return		   :  BOOL 错误FALSE 正确 TRUE
*******************************************************************************/

int sb_waitingframeaswer(sr_cmdstruct_t * CommandElemt)
	{
		unsigned int seqNum = 1,timeout_counter=0,timeout_counter_an = 0,pump_error = 0;
		unsigned char isReaptSnd = 0;
		struct timeval ack_now;
		struct timespec ack_timeout;
		int res_ack=0,pi_cnt = 0,errortmp=0;
		int res_answer=0,last_pump_error=0;
		emb_comid comPort;
		sr_cmdstruct_t CommandElemt_tmp;
		BOOL PUMP_ACK = FALSE;
		int i=0,timeout_overall = 0;

		if(flg_intosleep)
				return 0;
		memcpy(&CommandElemt_tmp,CommandElemt,sizeof(sr_cmdstruct_t));
	//	BOOL res = TRUE;
	if (CommandElemt->srdevaddr == PUMP_ADDR)
	{
//return 0;//TST

		while(!flg_mainproexit)
		{
	PUMP_AGAIN:
			usleep(200000);
			if (sb_armpumpsend(port_pump, "QR", 
				(*CommandElemt).srdevaddr , 0, 0, 2) > 0)
			{
			//	printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]successful.\n" , 
			//		0, (*CommandElemt).srdevaddr);
			}
			else
			{
				printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]failed.\n" , 
					0, (*CommandElemt).srdevaddr);
			}
			
		//	while(!flg_mainproexit)
			{
			if(timeout_overall++ > 500)
				lprintf(log_my, INFO,"allwayssaomepump=%x\n",pump_readbuf[2]);
			
				usleep(100000);
				if (flg_recvpump)
				{
					timeout_counter = 0;
					flg_recvpump = FALSE;
				//	printf("flg_recvpump pump_readbuf[2]=%x\n",pump_readbuf[2]);
	
					if (pump_readbuf[2] == 0X60) 
						{
						lprintf(log_my, INFO,"pump=0X60\n");
						return 0;	
						}
					else if ( (pump_readbuf[1] == 0X40) )
					{
						//PUMP_ACK = TRUE;
					}
					else if ( (pump_readbuf[2] & 0X0F) > 0 && pump_readbuf[2] != 0X31) 
					{
					lprintf(log_my, INFO,"pump=%x\n",pump_readbuf[2]);
					//	printf("flg_recvpump pump_readbuf[2]=%x\n",pump_readbuf[2]);
						if ((pump_readbuf[2] & 0X0F) == 9 || (pump_readbuf[2] & 0X0F) == 0X0A
							|| (pump_readbuf[2] & 0X0F) == 7 || (pump_readbuf[2] & 0X0F) == 0X0C)
						{
							if (pump_error == 0)
								last_pump_error = pump_readbuf[2];
							pump_error++;
							if (pump_error > 5)
							{
								mb_seterrorcode(last_pump_error);
								mb_seterrorcode(pump_readbuf[2]);
							}
							else
							{
								sprintf(CommandElemt_tmp.cmdbuf, "ZR");
								sb_armpumpsend(port_pump, CommandElemt_tmp.cmdbuf, 
									(*CommandElemt).srdevaddr , 0, 0, 2);
							sleep(10);	
								
								lprintf(log_my, INFO,"send pump cmd again cmd=%s\n",CommandElemt->cmdbuf);
								printf("send pump cmd again cmd=%s\n",CommandElemt->cmdbuf);
								sb_armpumpsend(port_pump, CommandElemt->cmdbuf, 
									(*CommandElemt).srdevaddr , 0, 0, 2);
									goto PUMP_AGAIN;
							}
						}
						else 
						{
							mb_seterrorcode(pump_readbuf[2]);
						//	mb_seterrorcode(last_pump_error);
							return -1;
						}
						
						
					}
					memset(pump_readbuf,0,sizeof(pump_readbuf));
				}
				else
				{
			//	printf("timeout_counter %d\n",timeout_counter);
					
					if (timeout_counter++ > 80 )
					{	
						mb_seterrorcode(CONNECT_ERROR_PUMPA);
						return -1;
					}
					else if (!PUMP_ACK && timeout_counter % 10 == 0)
					{
		//				sb_armpumpsend(port_pump, CommandElemt->cmdbuf, 
			//					(*CommandElemt).srdevaddr , 0, 1, 2);
					}
				}
				
					
			}
		}
		
	}
	
	else
	{
//return TRUE;
		while(!flg_mainproexit)
		{
		gettimeofday(&ack_now, NULL);
		ack_timeout.tv_sec = ack_now.tv_sec + 2;
		 ack_timeout.tv_nsec== ack_now.tv_usec * 1000;;
		pthread_mutex_lock(&armlock_ack);
	
		
		while((flg_armack != 1) && (res_ack != ETIMEDOUT))		
			res_ack = pthread_cond_timedwait(&armcondtion_ack, &armlock_ack, &ack_timeout);
		if (pthread_mutex_unlock(&armlock_ack) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_ack");
		flg_armack = 0;
		if (res_ack  != ETIMEDOUT)
		{
		//	printf("ack recieved wait for answering\n");
			
			
			pthread_mutex_lock(&armlock_answer);
	
			while(sr_armansercode != 1 && (!flg_mainproexit))
			{
				if (strcmp(CommandElemt->cmdbuf,"PI")==0 && sr_armansercode == 4)
				{
					mb_seterrorcode(0X70 + sr_armansercode);//初始化时X轴失步直接报错不能重新初始化
					return -1;
				}
				if ((sr_armansercode == 2) || (sr_armansercode == 3 )|| sr_armansercode == 4 || sr_armansercode == 5 
					|| sr_armansercode == 6|| sr_armansercode == 9 || sr_armansercode == 0X0B)	//测液体错误 
					break;
				
			//	res_answer = pthread_cond_wait(&armcondtion_answer, &armlock_answer);
				usleep(100000);
				timeout_counter_an++;
				if (timeout_counter_an > 500)
				{
				if(flg_intosleep)
				return 0;
					mb_seterrorcode(CONNECT_ERROR_ARM);
					if (pthread_mutex_unlock(&armlock_answer) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");
				lprintf(log_my,FATAL,"CONNECT_ERROR_ARM sr_armansercode");
				sleep(1);
				return -1;
				}
			}
			//	if (res_answer == 0)
			//		printf("answer recieved\n");
			//	else
			//		perror("armcondtion_answer error\n");
			
			if (pthread_mutex_unlock(&armlock_answer) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error armlock_answer");
			lprintf(log_my, INFO,"sr_armansercode=%d\n",sr_armansercode);
			if (sr_armansercode == 1 || sr_armansercode == 0)
			{
				inwait_init_flag = 0;
				sr_armansercode = 0;
				return 0;
			}
			else if (sr_armansercode == 3)
			{
				inwait_init_flag = 0;
				
				sr_armansercode = 0;
				
					return -3;
				
			}
			else if (sr_armansercode == 9)
			{
				sr_armansercode = 0;
				inwait_init_flag = 0;
				return -9;
			}
			else if (sr_armansercode == 11)
			{
				sr_armansercode = 0;
				inwait_init_flag = 0;
				return -11;
			}
			else
			{
				if (inwait_init_flag && (strcmp(CommandElemt->cmdbuf,"PI")==0 || strcmp(CommandElemt->cmdbuf,"ZI")==0))
				{
					mb_seterrorcode(0X70 + sr_armansercode);
					sr_armansercode = 0;
									
					inwait_init_flag = 0;
					return -3;
				}
				errortmp = sr_armansercode;
				printf("sr_armansercode=%d!!!!!!!!!!!!!!!/n",sr_armansercode);
				pi_cnt++;
				inwait_init_flag = 1;
				if (CommandElemt->cmdbuf[0] == 'Z')
				{
					strcpy(CommandElemt_tmp.cmdbuf , "ZI");
					if (sb_armpumpsend(port_arm,"ZI", 
					CommandElemt_tmp.srdevaddr , 1, 0, 1) > 0)
					{
						printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]successful.\n" , 
							"ZI", CommandElemt_tmp.srdevaddr);
					}
					if (sb_waitingframeaswer(&CommandElemt_tmp) < 0)
						return -3;
						
				}
				else
				{
					strcpy(CommandElemt_tmp.cmdbuf , "PI");
					if (sb_armpumpsend(port_arm,"PI", 
					CommandElemt_tmp.srdevaddr , 1, 0, 1) > 0)
					{
						printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]successful.\n" , 
							"PI", CommandElemt_tmp.srdevaddr);
					}
					if (sb_waitingframeaswer(&CommandElemt_tmp) < 0)
						return -3;
				}
				printf("error send again#####################\n");
				lprintf(log_my, INFO,"error send again%s\n",(unsigned char	*)(*CommandElemt).cmdbuf);
				if (sb_armpumpsend(port_arm, (unsigned char	*)(*CommandElemt).cmdbuf, 
				(*CommandElemt).srdevaddr , 1, 0, 1) > 0)
				{
					printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]successful.\n" , 
						(unsigned char	*)(*CommandElemt).cmdbuf, (*CommandElemt).srdevaddr);
				}
				if (pi_cnt == 2)
				{
					inwait_init_flag = 0;
					mb_seterrorcode(0X70 + errortmp);
					return -3;
				}
			}
			
			
		}
		else if(res_ack  == ETIMEDOUT)
		{
			isReaptSnd = 1;
			
			timeout_counter++;
		
			if (timeout_counter > 20)
			{
			if(flg_intosleep)
				return 0;
				mb_seterrorcode(CONNECT_ERROR_ARM);
				lprintf(log_my,FATAL,"CONNECT_ERROR_ARM ");
				sleep(1);
				return -1;
			}
		/*	
			if ((*CommandElemt).srdevaddr != PUMP_ADDR)
			{
				seqNum++;
				if (seqNum > 7) // seq置1
					seqNum = 1;
				(*CommandElemt).seq = seqNum;
			}
			
			if (sr_armansercode == 1)	//没收到ack但收到amswer
			{
				sr_armansercode = 0;
				return TRUE;
			}
		*/
			printf("ack recieve timeout send cmd again seqNum = %d\n", 0 );
		lprintf(log_my, INFO,"ack recieve timeout send cmd again seqNum = %d\n", 0 );
			isReaptSnd = 1;
			
			
			if (sb_armpumpsend(port_arm, (unsigned char	*)(*CommandElemt).cmdbuf, 
				(*CommandElemt).srdevaddr , 0, 1, 2) > 0)
			{
				printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]successful.\n" , 
					0, (*CommandElemt).srdevaddr);
			}
			else
			{
				printf("[sb_waitingframeaswer]: Send message [%d] to tecan device [%x]failed.\n" , 
					0, (*CommandElemt).srdevaddr);
			}
		}
		res_ack=0;
		}
	}
		return 0;
	}


/******************************************************************************
*
* Function Name  : sm_sendminibdframe 
* Description    : .向自控臂板发送命令
* 					 
* Input		   :emb_comid comPort 串口号,char * frame 数据指针, unsigned int send_num 数据长度
* Output		   :None
* Return		   :  None
*******************************************************************************/
void sm_sendminibdframe (emb_comid comPort,char * frame, unsigned int send_num)
{
	int res,i;
	unsigned short crc=0;
	unsigned char cmdbuffer[102] ={0};
	
	memcpy(cmdbuffer,frame,send_num);
	crc = usMBCRC16(frame, send_num);
//	printf("crc=%xsend_num=%d",crc,send_num);
	
	memcpy(&cmdbuffer[send_num],&crc,2);
	
//	cmdbuffer[send_num] = (unsigned char)0x33;
//	cmdbuffer[send_num + 1] = (unsigned char)0x44;
	tcflush(serail_hand[comPort],TCOFLUSH);
if (PRINTF)
{
	printf("the data send to minib send_num=%d comPort=%d\n",send_num,comPort);
	lprintf(log_my, INFO,"the data send to minib\n");
	for (i = 0;i < send_num + 2;i++)
		{
		printf(" %x",cmdbuffer[i]);
		if(send_num < 20)//配置信息不计入太长
			lprintf(log_my, INFO," %x",cmdbuffer[i]);
		}
}
	res = write(serail_hand[comPort],cmdbuffer,send_num + 2);

	if (res < 0)
		printf("write em_minicmd error\n");
	else
		printf("write em_minicmd successed\n");
}
/******************************************************************************
*
* Function Name  : sm_parseminibdframe
* Description    : .解析自控臂板数据
* 					 
* Input		   :emb_comid comPort 串口号, int ReadLength 数据长度
* Output		   :volatile unsigned char* mini_recieve_code 填入命令码
* Return		   :  None
*******************************************************************************/
void sm_parseminibdframe(emb_comid comPort, int ReadLength)
{
	unsigned short crc=0; 
	char data[5] ={0};
	stminibd_sendpacket cmd;
	 unsigned char mini_recieve_code;

	//sleep(2);
	if (ReadLength < 4)
		return;
	printf("in [sm_parseminibdframe]\n");
	
	crc = usMBCRC16(serail_recvbuf, ReadLength - 2);
//	printf("crc=%x,(unsigned char)crc=%x (unsigned char)crc >> 8=%x\n",crc,(unsigned char)crc,(unsigned char)(crc >> 8));
	if (((unsigned char)crc != serail_recvbuf[ReadLength-2]) || (((unsigned char)(crc >> 8)) != serail_recvbuf[ReadLength-1]))
	{
		printf("COM%d crc error\n",comPort);
		
	}	
	else
	{
	//	pthread_mutex_lock(&minib_recievecode_lock);	//另一线程*mini_recieve_code清零标志操作几乎不占用时间 允许加锁
		if (serail_recvbuf[1] == MINI_ACK)
			 mini_recieve_codeACK = serail_recvbuf[1];
		else	//when response, send ack to minib 	serail_recvbuf[1] is shelf_num
		{		//璇淇℃ReadBuffer[2] = 0XFF

			
				data[0] = MINI_ACK;
				data[1] = serail_recvbuf[2];	
		//		if (*mini_recieve_code != 0x9e)	//9e为按键检测返回，不需回信息否则 那端停止按键检测
					sm_sendpacket(comPort,0,2,&data); 
		printf("answer recieved\n");
			if(serail_recvbuf[2] == 0XFF)
				serail_recvbuf[2] = serail_recvbuf[3] %3;
			 mini_recieve_code = mini_recieve_code_all[serail_recvbuf[2] - 1] = serail_recvbuf[3];
				mini_work_finished[serail_recvbuf[2] - 1] = TRUE;
					
			if ((mini_recieve_code) <= SHELF_UNLOCKED_C && (mini_recieve_code) >= SHELF_UNLOCKED_A)	//当为解锁信息时
			{	
				if (serail_recvbuf[2] == 1)
				{
					if (ewkeventA != FREE_WORK && ewkeventA != MAINTAIN_WORK && ewkeventA != INIT_WORK)
						flg_dischargeremainliquid[0] = TRUE;
					
					ewkeventA = FREE_WORK;	//水合结束回到空闲工作状态
					hydrateA.flage = FALSE;
						
				//	flg_opwork1ready  = FALSE;
				}
				else if (serail_recvbuf[2] == 2)
				{
				if (ewkeventB != FREE_WORK && ewkeventB != MAINTAIN_WORK && ewkeventB != INIT_WORK)
						flg_dischargeremainliquid[1] = TRUE;
					ewkeventB = FREE_WORK;	//水合结束回到空闲工作状态
					hydrateB.flage = FALSE;	
				//	flg_opwork2ready  = FALSE;
				}
				else if (serail_recvbuf[2] == 3)
				{
				if (ewkeventC != FREE_WORK && ewkeventC != MAINTAIN_WORK && ewkeventC != INIT_WORK)
						flg_dischargeremainliquid[2] = TRUE;
					ewkeventC = FREE_WORK;	//水合结束回到空闲工作状态
					hydrateC.flage = FALSE;	
				//	flg_opwork3ready  = FALSE;
				}
			}
			
printf("*mini_recieve_code=%x\n", mini_recieve_code);
				if (mini_recieve_code >= SHELF_LOCKED_A && mini_recieve_code <= SHELF_LOCKED_C)
				{
				//	if (ewkevent != MAINTAIN_WORK)
					//	flg_shelfcanindex[serail_recvbuf[2] - 1] = TRUE;
						mb_setstatetoshelf(serail_recvbuf[2] - 1, TRUE);
						SHELF_LOCK_STATE[serail_recvbuf[2] - 1] = 2;
						flg_shelfarmsleep[serail_recvbuf[2]] = FALSE;
				}
				if (mini_recieve_code >= SHELF_UNLOCKED_A && mini_recieve_code <= SHELF_UNLOCKED_C)
				{
					SHELF_LOCK_STATE[serail_recvbuf[2] - 1] = 1;		
					flg_shelfarmsleep[serail_recvbuf[2]] = TRUE;
					memset(&cmd,0,sizeof(cmd));
					cmd.cmd = RELOAD;
					cmd.minicmd_buffer[3] = (unsigned char)RELOAD;
					cmd.minicmd_buffer[4] = serail_recvbuf[2];
					cmd.minicmd_num=2;
					pthread_mutex_lock(&mutex_mlock);
					set_minicmd(pcmd_head,cmd);
					if (pthread_mutex_unlock(&mutex_mlock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error m_lock");
				}
				
				if (mini_recieve_code == 0x2e)
				{
					 if((serail_recvbuf[2] == 1 && flg_opwork1ready)
					 	|| (serail_recvbuf[2] == 2 && flg_opwork2ready)
					 	|| (serail_recvbuf[2] == 3 && flg_opwork3ready))//防止降温时强制停止
					flg_fanworked[serail_recvbuf[2] - 1] = TRUE;
				}
					
				if (mini_recieve_code >= SHELF_LOSE_A && mini_recieve_code <= SHELF_LOSE_C)	
					{
					mb_seterrorcode(SHELF_LOSE_MINIA + mini_recieve_code - SHELF_LOSE_A);			
					}
				
				if (mini_recieve_code >= SHELF_UNLOAD_A && mini_recieve_code <= SHELF_UNLOAD_C)		
					mb_seterrorcode(SHELF_UNLOAD_MINIA + mini_recieve_code - SHELF_UNLOAD_A);	

				
		//		pthread_mutex_unlock(&minib_recievecode_lock);	
		}
	}
}

int ExtractWG(emixcmd cmd, char* data, char data_len )
{
	char i = 0;
	static unsigned short last_cabin_state[6] = {1,1,1,1,1,1};//0表示被拔出 1表示装入状态//DEW WATER ALCHOLE WASH ER1 ER2
	
	#ifdef BIG_VERSION

	memcpy(bigcabin_value, data, data_len);
	memcpy(bigcabin_value_init, data, data_len);//用于标定

/*	
	printf("bigcabin_value_init=");
	for(i=0;i<18;i++)
		printf(" %d ",bigcabin_value_init[i]);
*/
for(i = 0;i<6;i++)
{
	if(reagent_cabin_full[i] == reagent_cabin_zero[i])
		continue;
	if(bigcabin_value[i] <= reagent_cabin_zero[i])
	{
		bigcabin_value[i] = 0;
		bigcabin_ledstate[i] = 1;
		continue;
	}
	if(i < 4)
	{
		bigcabin_value[i] =4000* (bigcabin_value[i] - reagent_cabin_zero[i])/(reagent_cabin_full[i] - reagent_cabin_zero[i]);
		if(bigcabin_value[i] < 800)
			bigcabin_ledstate[i] = 1;
		else
			bigcabin_ledstate[i] = 0;
		
	}
	else
	{
		bigcabin_value[i] =1500* (bigcabin_value[i] - reagent_cabin_zero[i])/(reagent_cabin_full[i] - reagent_cabin_zero[i]);
		if(bigcabin_value[i] < 300)
			bigcabin_ledstate[i] = 1;
		else
			bigcabin_ledstate[i] = 0;
	}
}

		for (i = 0; i < 6;i++)
		{
		//		printf(" %d **",last_cabin_state[i]);
		//		printf(" %d ",need_perfusion[i]);
			if (last_cabin_state[i] == 0 && bigcabin_value[6 + i] == 1)	//当有0变成1时表示试剂桶装入
			{
				need_perfusion[i]++;//在其他操作中发现先前值与当前值不同 灌注后重复其操作
											
			}
			last_cabin_state[i] = bigcabin_value[6 + i];//赋值 当前值
		}


/*
printf("bigcabin_value=");
	for(i=0;i<18;i++)
		printf(" %d ",bigcabin_value[i]);

*/
	flg_cabinreved = TRUE;
#endif
return 0;
}


int ExtractMix(emixcmd cmd, char* data, char data_len )
{
	char i = 0;
	#ifdef BIG_VERSION

	if (cmd == MIXSTATE || cmd == SENSTATE)//状态
	{
		for(i=0;i<4;i++)
			reagent_check[i].STATE = data[i];
	}
	
	else if(cmd >= MIXDATA1 && cmd <=MIXDATA4)
	{
		memcpy(reagentdata.reagent_bigcode, data, data_len);
		reagentdata.DataRead = TRUE;
	}
	else if(cmd == MIXRESP)
	{
		lightdata = (*(short*)data) & 0XFFFF;
		printf("revlightdata=%x\n", lightdata);
	}
	else if(cmd == SCANSTATE)
	{
		//for(i=0;i<4;i++)
		//	reagent_check[i].NEED_SCAN = data[i];
		

	}
#endif
return 0;
}

//第一次灌注 perfusion_num不要求 在灌注操作的下层会赋值
int mb_checkcabinhavereagt(unsigned char perfusion_num)
{
	int i = 0,res = 0;
	stminibd_sendpacket cmd;
//	static unsigned short need_perfusion_last[6] = {0};//DEW WATER ALCHOLE WASH ER1 ER2
					
//	return 0;	

	if (flg_cabinremovreagt_inport)
		return 0;
//	printf("in [mb_checkcabinhavereagt]\n");
//	sleep(1);
	flg_cabinremovreagt_inport = TRUE;
/*
	printf("cabin_value=");
	for (i = 0; i < 6; i++)
		printf(" %d ",cabin_value[i +6]);
	printf("\n");
	*/
	i = 0;
	while(i < 6)
	{	
		usleep(100000);
		for (i = 0; i < 6; i++)
		{
			if (flg_cabinhavereagent[i] )	//有效的瓶子被拿掉 一直等待
				if ( cabin_value[i + 6] == 0)
				{printf("cabin was removed num = %d\n",i);
					break;
				}
		}
	}
/*
	printf("need_perfusion_last=");
	for (i = 0; i < 6; i++)
		printf(" %d ",need_perfusion_last[i]);
	printf("\n");
	printf("need_perfusion=");
	for (i = 0; i < 6; i++)
		printf(" %d ",need_perfusion[i]);
	printf("\n");
*/
	for (i = 0; i < 6; i++)
	{
		if (need_perfusion_last[i] < need_perfusion[i])//如果差值大于1 表示拔了两次只需灌注一次
		{
			need_perfusion_last[i] = need_perfusion[i];
			if (i == perfusion_num)//当此操作中正是对应试剂的灌注操作在外层就不需要在继续灌注
				res = -1;
			
		tp_washchange(TRUE);
			if (i == 0)
			{
				if (!mb_waterwashreagentpour(WATERPORT))
					mb_seterrorcode(WATERPOUR_WRONG);
			}
			else if (i == 1)
			{
				if (!mb_waterwashreagentpour(WASHPORT))
					mb_seterrorcode(WASHPOUR_WRONG);
			}
			else if (i == 2)
			{
				if  (!mb_muiltreagentpour(ALCOHOLPORT))
					mb_seterrorcode(ALCOHOLPOUR_WRONG);
			}
			else if (i == 3)
				mb_muiltreagentpour(DEWAXPORT);
			else if (i == 4)
			{
				if (!mb_muiltreagentpour(ER1PORT))
					mb_seterrorcode(ER1POUR_WRONG);
			}
			else if (i == 5)
			{
				if (!mb_muiltreagentpour(ER2PORT))
					mb_seterrorcode(ER2POUR_WRONG);
			}
		tp_washchange(FALSE);
		}	}
#if 0
	for (i = 0; i < 6; i++)
	{
		if (need_perfusion_last[i] < need_perfusion[i])//如果差值大于1 表示拔了两次只需灌注一次
		{
			need_perfusion_last[i] = need_perfusion[i];
			memset(&cmd,0,sizeof(cmd));
			cmd.cmd = PERFUSION;
			cmd.minicmd_buffer[3] = (unsigned char)PERFUSION;		
			cmd.minicmd_num = 2;
			
			if (i == perfusion_num)//当此操作中正是对应试剂的灌注操作在外层就不需要在继续灌注
				res = -1;
			if (i == 0)
			{
				cmd.minicmd_buffer[4] = REAGENT_DEWAX;
			//	mb_muiltreagentpour(DEWAXPORT);
			}
			else if (i == 1)
			{
				cmd.minicmd_buffer[4] = REAGENT_WATER;
			//	mb_waterwashreagentpour(WATERPORT);
			}
			else if (i == 2)
			{
				cmd.minicmd_buffer[4] = REAGENT_ALCOHOL;
			//	mb_muiltreagentpour(ALCOHOLPORT);
			}
			else if (i == 3)	//大仪器主臂操作中只需关注WASH是否被拔出
			{
				mb_waterwashreagentpour(WASHPORT);//清洗步骤灌注相当于清洗上层操作不需执行
			}
			else if (i == 4)
			{
				cmd.minicmd_buffer[4] = REAGENT_ER1;
			//	mb_muiltreagentpour(ER1PORT);
			}
			else if (i == 5)
			{
				cmd.minicmd_buffer[4] = REAGENT_ER2;
			//	mb_muiltreagentpour(ER2PORT);
			}

			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			pthread_mutex_unlock(&mutex_mlock);
		}
		
	}
#endif
flg_cabinremovreagt_inport = FALSE;
return res;
}

int mb_monitdoorstate(void)
{
	sr_cmdstruct_t CommandElemt;

//return 0;
	if (inDischarge)	{
		while(inDischarge) 
			sleep(1);
	}

	if (!door_open_action)
	{
		if (DOOR_OPENDED)
		{
			printf("DOOR_OPENDED***********************\n");
			if (initialize_finished)
			{
			CommandElemt.srdevaddr = ARM_ADDR;

		strcpy(CommandElemt.cmdbuf, "ZA 0");	
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			}
		while(DOOR_OPENDED)
			sleep(1);
	}
		}
		if (!dng_wast_barrel)
	{
		while(OUT_WASTHIGH_L) sleep(1);
		while(OUT_WASTHIGH_H) sleep(1);
		
	//	printf("outof tst&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&7\n");
	}
		

//	while(OUT_WASTHIGH_L || OUT_WASTHIGH_H)
//		sleep(1);
	
	
	if (ewkevent != FREE_WORK)
	{
		if (ewkevent == PAUSE)
		{
		/*
			while(ewkevent != FREE_WORK)	//等待PC 继续工作信息
			{
				if (ewkevent == STOP_ALL)	//等待过程中收到停止命令
						pthread_exit(NULL);
				sleep(1);
			}
		*/
		}
		else if (ewkevent == STOP_ALL)
			pthread_exit(NULL);
		else if (ewkeventA == STOP_WORK )
			return -1;
		else if (ewkeventB == STOP_WORK )
			return -2;
		else if (ewkeventC == STOP_WORK)
			return -3;
	}

	return 0;
}

/***********************水 缓冲液的灌注**************************/
BOOL mb_waterwashreagentpour(unsigned char reagent_port)
	{
		BOOL res = TRUE;
		sr_cmdstruct_t CommandElemt;
		unsigned char perfusion_num;
		int perfusion_res = 0;
		printf("in **[mb_waterwashreagentpour] reagent_port=%d**",reagent_port);
		sleep(1);
	Water_Wash_Pour_AGAIN:
	
			if (reagent_port == WATERPORT)
			{
				mb_procwashprobe(REAGENT_WATER);
				last_cabin_reagent = reagent_flag = REAGENT_WATER;
				perfusion_num = 0;
			}
			else
			{
				mb_procwashprobe(REAGENT_WASH);
				last_cabin_reagent = reagent_flag = REAGENT_WASH;
				perfusion_num = 1;
			}
	mb_monitdoorstate(); 
			
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	
	mb_monitdoorstate(); 
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	pthread_mutex_lock(&pump_lock);//防止排液
		if (IsWashProbeStart == FALSE)//防止dowork_WashProbe 线程也锁上但是优先级这里高
		{
			if (pthread_mutex_unlock(&pump_lock) != 0);//防止排液
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
			sleep(1);
			pthread_mutex_lock(&pump_lock);
		}
	  
		CommandElemt.srdevaddr = PUMP_ADDR;						//注射器命令最多50个字符								//注射器共拉6下，打掉5下半的液体
		sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG5I%dP%dM%dO%dD%dR",
											SYSPEED,reagent_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY,reagent_port,SYFSTEP,SYDELAY,PROBEPORT,SYHSTEP);
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	if (pthread_mutex_unlock(&pump_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
/*	
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	*/
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH3][0], ordArray_wash[WASH1][1], ZWASH_STEP3);// 3号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			 
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_CLEAN, SYHHSTEP);	//打掉剩余的一半液体的1/2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	mb_monitdoorstate();
	/*
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	*/
	usleep(DISPENSE_T);
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	sleep(1);
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dA%dM%dI%dP%dM%dO%dD%dR", 
											SYSPEED_CLEAN,0,SYDELAY,reagent_port,SYFSTEP,SYDELAY,
											PROBEPORT,SYFSTEP); //打光剩余的液体。注射器吸一下，打光
	
	//	sprintf(CommandElemt.cmdbuf, "S%dD%dM%dI%dP%dM%dO%dD%dM%dI%dP%dM%dO%dD%dR", 
	//										SYSPEED,SYHHSTEP,SYDELAY,reagent_port,SYFSTEP,SYDELAY,
	//										PROBEPORT,SYFSTEP,SYDELAY,reagent_port,SYHSTEP,SYDELAY,PROBEPORT,SYHSTEP);	//打光剩余的液体。注射器吸一下，打光，再吸半下，打光
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	/*
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	*/
	usleep(DISPENSE_T);
				
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
	
		//sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 600, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	sleep(3);
			sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);//
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt); 
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH2][0], ordArray_wash[WASH2][1], ZWASH_STEP2_2);// 2号清洗槽状态2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	/*
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	*/
	/*
	mb_monitdoorstate();
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	*/
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", ZWASH_STEP2_1);// 2号清洗槽状态1
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dO%dS%dP%dR", SYSPEED,reagent_port,SYMHSTEP,PROBEPORT,SYSPEED_WASTE,SYSTEP_WASTE);	//一半多液体及吸取残留液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
/*
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;//确保当有多个需要灌注时，灌注操作的完整性
	else if (perfusion_res == 2)
		goto Water_Wash_Pour_AGAIN;
	*/
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED,SYLIQTSTSTEP + SYSTEP_WASTE - wat_sypstep); //打掉注射器中液体的一半
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
	sleep(3);		//有空气会有液体滴下来
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH2][0], ordArray_wash[WASH2][1], ZWASH_STEP2_2);// 2号清洗槽状态2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_TST,SYSTEP_WASTE);	//打掉少量液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	//	return 1;
	usleep(DISPENSE_T);
	mb_monitdoorstate(); 
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);// 2号清洗槽状态3
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_LIQTSTAIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	mb_monitdoorstate(); 
	
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  ZWASH_STEP2_2 - 50);//
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	usleep(300000);
	
		sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", POUR_LIQUID_DISTANCE_ZMAX, POUR_LIQUID_DISTANCE_ZMAX, ZWASH_STEP2_ZX);//测液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
			if (sb_waitingframeaswer(&CommandElemt) < 0)
			{	
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				
				if (sb_waitingframeaswer(&CommandElemt) < 0)
				{	
					res = FALSE;
				}			
			}
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", ZWASH_STEP2_1);// 2号清洗槽状态1
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_WASTE,SYSTEP_WASTE);	//吸取残留液
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dA%dR", SYSPEED,0); //打光注射器中所有液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		usleep(DISPENSE_T);
		
		CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
			sleep(1);
		if (res)	
			mb_seterrorcode((WATERPOUR_WRONG + perfusion_num) | 0X01000000);
			return res;
	}



/***********************酒精，脱蜡剂，修复1，修复2的灌注**************************/
BOOL mb_muiltreagentpour(unsigned char reagent_port)
	{
		sr_cmdstruct_t CommandElemt;
		BOOL res = TRUE;
		unsigned char perfusion_num;
		int perfusion_res = 0;

	CommandElemt.srdevaddr = ARM_ADDR;

	sprintf(CommandElemt.cmdbuf, "SL %d %d", 5000,0X1200);
			//	sprintf(CmdElemt.cmdbuf, "SL %d %d", 5000,0X3000);
						if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
								CommandElemt.srdevaddr , 1, 0, 2) > 0)
								printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
							else
								printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
							sb_waitingframeaswer(&CommandElemt);
							
#if 0
while(1)
{
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH2][0], ordArray_wash[WASH2][1], ZWASH_STEP2_2);// 2号清洗槽状态2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  ZWASH_STEP2_2 - 50);//
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	usleep(300000);
	//return TRUE; 
	  
				 
		sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", POUR_LIQUID_DISTANCE_ZMAX, POUR_LIQUID_DISTANCE_ZMAX, ZWASH_STEP2_1 );//测液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
		if (sb_waitingframeaswer(&CommandElemt) < 0)
		{	
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
			if (sb_waitingframeaswer(&CommandElemt) < 0)
			{	
				res = FALSE; 
			}			  
		}  

}
#endif
	OtherPour_AGAIN:	
		sleep(1);
	
		printf("reagent_port=%d", reagent_port);
		
			if (reagent_port == ALCOHOLPORT)
			{
				mb_procwashprobe(REAGENT_ALCOHOL);
				last_cabin_reagent = reagent_flag = REAGENT_ALCOHOL;
				perfusion_num = 3;
			}
			else if (reagent_port == DEWAXPORT)
			{
				mb_procwashprobe(REAGENT_DEWAX);
				last_cabin_reagent = reagent_flag = REAGENT_DEWAX;
				perfusion_num = 2;
			}
			else if (reagent_port == ER1PORT)
			{
				mb_procwashprobe(REAGENT_ER1);
				last_cabin_reagent = reagent_flag = REAGENT_ER1;
				perfusion_num = 4;
			}
			else if (reagent_port == ER2PORT)
			{
				mb_procwashprobe(REAGENT_ER2);
				last_cabin_reagent = reagent_flag = REAGENT_ER2;
				perfusion_num = 5;
			}
		
	mb_monitdoorstate(); 
			
	perfusion_res = mb_checkcabinhavereagt(perfusion_num);
	if (perfusion_res < 0)	return TRUE;	
	else if (perfusion_res == 2)
		goto OtherPour_AGAIN;
	
	mb_monitdoorstate(); 
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	//	strcpy(CommandElemt.cmdbuf, "PA 2445 60 200");	
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
	
	pthread_mutex_lock(&pump_lock);//防止排液
	if (IsWashProbeStart == FALSE)//防止dowork_WashProbe 线程也锁上但是优先级这里高
	{
		if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
		sleep(1);
		pthread_mutex_lock(&pump_lock);
	}
	
	CommandElemt.srdevaddr = PUMP_ADDR;						//注射器命令最多50个字符								//注射器共拉6下，打掉5下半的液体
		sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG5I%dP%dM%dO%dD%dR",
											SYSPEED_CLEAN,reagent_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY,reagent_port,SYFSTEP,SYDELAY,PROBEPORT,SYHSTEP);
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
	usleep(ASPIRATE_T); 	
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH3][0], ordArray_wash[WASH3][1], ZWASH_STEP3);// 3号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_CLEAN, SYHHSTEP);	//打掉剩余的液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(DISPENSE_T);
		
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZS -%d %d",  200, ZSPEED_SLOW);//针缓慢上升
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	sleep(3);
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//针缓慢上升
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	mb_monitdoorstate(); 
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH2][0], ordArray_wash[WASH2][1], ZWASH_STEP2_2);// 2号清洗槽状态2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	/*
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	*/
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", ZWASH_STEP2_1);// 2号清洗槽状态1
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		/*	
			perfusion_res = mb_checkcabinhavereagt(perfusion_num);
			if (perfusion_res < 0)	return TRUE;	
			else if (perfusion_res == 2)
				goto OtherPour_AGAIN;
	*/
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dO%dS%dP%dR", SYSPEED,reagent_port,SYMHSTEP,PROBEPORT,SYSPEED_WASTE,SYSTEP_WASTE);	//一半多液体及吸取残留液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED,SYLIQTSTSTEP + SYSTEP_WASTE);	//打掉注射器中液体的一半
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
	sleep(3);		//有空气会有液体滴下来
	
	mb_monitdoorstate(); 
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH2][0], ordArray_wash[WASH2][1], ZWASH_STEP2_2);// 2号清洗槽状态2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_TST,SYSTEP_WASTE);	//打掉少量液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	//while(1) scanf("%d",&res);
	usleep(DISPENSE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);// 2号清洗槽状态3
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else	
				printf("mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_LIQTSTAIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  ZWASH_STEP2_2 - 50);//
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	usleep(300000);
	//return TRUE; 
	  
				 
		sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", POUR_LIQUID_DISTANCE_ZMAX, POUR_LIQUID_DISTANCE_ZMAX, ZWASH_STEP2_1 );//测液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
		if (sb_waitingframeaswer(&CommandElemt) < 0)
		{	
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			
			if (sb_waitingframeaswer(&CommandElemt) < 0)
			{	
				res = FALSE; 
			}			  
		}  
			 
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;	
		sprintf(CommandElemt.cmdbuf, "ZA %d", ZWASH_STEP2_1);// 2号清洗槽状态1
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_WASTE,SYSTEP_WASTE);	//吸取残留液
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dA%dR", SYSPEED,0); //打光注射器中所有液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt); 
	usleep(DISPENSE_T);
		CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		sleep(1);
		
	sprintf(CommandElemt.cmdbuf, "SL %d %d", DEC_SEN,CHECK_SEN);
		//	sprintf(CmdElemt.cmdbuf, "SL %d %d", 5000,0X3000);
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 2) > 0)
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
						
		if (res && (reagent_port != DEWAXPORT))
			mb_seterrorcode((WATERPOUR_WRONG + perfusion_num) | 0X01000000);
		return res;
	}


/*****************清洗探针********************/
void mb_probewash_a(unsigned char liquid_port)		//清洗并灌注大容量试剂 水和缓冲液 其他不能用A
{
	sr_cmdstruct_t CommandElemt;

	
	sleep(1);
mb_monitdoorstate();

 
	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T); 
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
pthread_mutex_lock(&pump_lock);//防止排液
	if (IsWashProbeStart == FALSE)//防止dowork_WashProbe 线程也锁上但是优先级这里高
	{
		if(pthread_mutex_unlock(&pump_lock) != 0)//防止排液
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
		sleep(1);
		pthread_mutex_lock(&pump_lock);
	}
		
	CommandElemt.srdevaddr = PUMP_ADDR;						//注射器命令最多50个字符								//排空注射器拉4下打3+4/5液体
//	sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG2I%dP%dM%dO%dD%dR",
//										SYSPEED,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SY45STEP);
	sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG2R",
										SYSPEED,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY);


	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
	lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
usleep(DISPENSE_T);	
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH3][0], ordArray_wash[WASH3][1], ZWASH_STEP3);// 3号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,liquid_port,SYFSTEP,PROBEPORT,SY15STEP);	//打掉剩余液体再拉1下打掉1/5
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	sleep(1);
	CommandElemt.srdevaddr = PUMP_ADDR;
	//sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,liquid_port,SYFSTEP,PROBEPORT,SY45STEP);	//打掉剩余液体再拉1下打掉
	sprintf(CommandElemt.cmdbuf, "S%dA%dR", SYSPEED,0);	//打掉剩余液体再拉1下打掉

	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	

	
	usleep(DISPENSE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 800, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
//	sleep(1);
	
	 
}

void mb_probewash_b(unsigned char liquid_port)
{
	sr_cmdstruct_t CommandElemt;
	int ssspd = 0;

	if (liquid_port == ALCOHOLPORT)
		ssspd = SYSPEED_ALCHOLE;
	else
		ssspd = SYSPEED_CLEAN;
	sleep(1);
mb_monitdoorstate();

	
	 
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气	
if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_b]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_b]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_b]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_b]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
pthread_mutex_lock(&pump_lock);//防止排液
	if (IsWashProbeStart == FALSE)//防止dowork_WashProbe 线程也锁上但是优先级这里高
	{
		if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
		sleep(1);
		pthread_mutex_lock(&pump_lock);
	}
	
	CommandElemt.srdevaddr = PUMP_ADDR;						//注射器命令最多50个字符								//排空注射器拉4下打3+4/5液体
//	sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG3I%dP%dM%dO%dD%dR",
//										ssspd,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SY45STEP);
	sprintf(CommandElemt.cmdbuf, "S%dA0gI%dP%dM%dO%dD%dM%dG3R",
										ssspd,liquid_port,SYFSTEP,SYDELAY,PROBEPORT,SYFSTEP,SYDELAY);
	

	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[WarterPour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[WarterPour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液\
	lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
usleep(DISPENSE_T);
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH3][0], ordArray_wash[WASH3][1], ZWASH_STEP3);// 3号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_b]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_b]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;	
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED_ALCHOLE,0,liquid_port,SYHSTEP,PROBEPORT,SYHSTEP);	//打掉剩余液体再拉1下打掉1/5
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_b]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_b]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

usleep(DISPENSE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_b]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_b]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
//	sleep(1);
	
}

void mb_probewash_c(unsigned char liquid_port)		
{
	sr_cmdstruct_t CommandElemt;
Wash_ProbeC:	
	//sleep(1);
mb_monitdoorstate();
	if (mb_checkcabinhavereagt(3) < 0)	return;//洗针以前就需要灌注
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气	
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,liquid_port,SYHSTEP,PROBEPORT,SYHHSTEP);	//排空注射器拉1/2下打1/4液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH3][0], ordArray_wash[WASH3][1], ZWASH_STEP3);// 3号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dR", SYSPEED_CLEAN,0);	//打掉剩余液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

usleep(DISPENSE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_c]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_c]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		if (mb_checkcabinhavereagt(3) < 0)	goto Wash_ProbeC;//洗针以后需要灌注,灌注好后重新洗针
//	sleep(1);


}

void mb_probewash_d(unsigned char liquid_port)		
{
	sr_cmdstruct_t CommandElemt;

//	sleep(1);
mb_monitdoorstate();
	
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,liquid_port,SYFSTEP,PROBEPORT,SYHHSTEP);	//排空注射器拉1下打1/4液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 3号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dI%dP%dO%dD%dR", SYSPEED_CLEAN,0,liquid_port,SYFSTEP,PROBEPORT,SYFSTEP,liquid_port,SYHHSTEP,PROBEPORT,SYHHSTEP);	//打掉剩余液体拉1打1拉1/4打光
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
		usleep(DISPENSE_T);
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 800, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);

	
	CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_d]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_d]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
//	sleep(1);
	
	
}

void mb_dab1wash(void)
{
	sr_cmdstruct_t CommandElemt;
	BOOL DischargeLock_NEED_UNLOCK = FALSE;//确保只进行一次解锁
	
mb_monitdoorstate();
	if (!flg_lockdischargliquit)
	{
		pthread_mutex_lock(&mutex_dischargelock);
		flg_lockdischargliquit = TRUE;
		DischargeLock_NEED_UNLOCK = TRUE;
	}
	tp_washchange(TRUE);
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气	
if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT,SYHSTEP);	//排空注射器拉1下打1/2液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();	
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dI%dP%dO%dD%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT,SYFSTEP,WATERPORT,SY15STEP,PROBEPORT,SY15STEP);	//打掉剩余液体拉1打1拉1/5打光
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();

	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
	//sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dab1wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dab1wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	tp_washchange(FALSE);

if (DischargeLock_NEED_UNLOCK)
	{
		if (pthread_mutex_unlock(&mutex_dischargelock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error DiscahgeLock");
		flg_lockdischargliquit = FALSE;
	}

}

void mb_dab2wash(void)
{
	sr_cmdstruct_t CommandElemt;
	BOOL DischargeLock_NEED_UNLOCK = FALSE;//确保只进行一次解锁
	
mb_monitdoorstate();
	
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dR", SYSPEED,0,WATERPORT,SYFSTEP);	//排空注射器拉1下液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();	
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT,SYFSTEP);	//打掉剩余液体拉1打光
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(DISPENSE_T);
mb_monitdoorstate();
	
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
	//sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dab2wash]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dab2wash]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

}

/*********
send channel num 
*********/

#ifdef BIG_VERSION

void mb_getreagentliquitcab(emb_comid comPort)
	{
		int res,i,timeout_counter=0,error_counter = 0;
		unsigned short crc=0;
		 char cmdbuffer[10] ={0};
		 char Ackbuffer[6] ={'W', 2, 0, 0X40, 0X46, 0X88};
		unsigned char * rtu;
		unsigned short  rtu_long;
		char serail_recvbuf[50];
		static char seq = 0;
		int rel,eor_cnt=0, timout_cnt=0,len;
			fd_set	DeviceRead;   //设备读准备就绪;
			fd_set	DeviceError; // 设备出现错误
			int 	DeviceMax = 0;


#ifdef EMCTST
	return;
#endif
		if (seq > 7)
			seq = 0;
		
		cmdbuffer[0] = 'W';
		cmdbuffer[1] = 0;
		cmdbuffer[2] = seq;
		cmdbuffer[3] = 0;
		memcpy(&cmdbuffer[4],bigcabin_ledstate, 6);
		
		
			crc = usMBCRC16(cmdbuffer, 10);
		//	printf("crc=%xsend_num=%d",crc,send_num);
			
			memcpy(&cmdbuffer[10],&crc,2);
			
		//	cmdbuffer[send_num] = (unsigned char)0x33;
		//	cmdbuffer[send_num + 1] = (unsigned char)0x44;
			tcflush(serail_hand[cabin_port],TCOFLUSH);
	//	if (PRINTF)
		{
			printf("the data send to WG\n");
			for (i = 0;i < 10 + 2;i++)
				printf(" %x",cmdbuffer[i]);
		}
			res = write(serail_hand[cabin_port],cmdbuffer,10 + 2);
			if (res < 0)
				printf("write WG error\n");
			else
				printf("write WG successed\n");
		{
	tcflush(serail_hand[cabin_port],TCIFLUSH);

	WG_Res = WGACK = FALSE;
	while(!WGACK && !WG_Res)
	{
			if(timout_cnt++ > 9)
			 {
			 timout_cnt = 0;
			 	if (eor_cnt++ > 9)
			 	{
			 		mb_seterrorcode(CONNECT_ERROR_WEIGHT);
					return -3;
			 	}
			 cmdbuffer[2] |= 0X80; 
			 	res = write(serail_hand[cabin_port],cmdbuffer,10 + 2);
				if (res < 0)
					printf("write WG error\n");
				else
					printf("write WG successed\n");
				printf("recieve WG timeout send again\n");
			 }
		 
		usleep(200000);
	}

	timout_cnt = eor_cnt = 0;

	while(!WG_Res)
	{
		if(timout_cnt++ > 100)
		{
			return -3;
		}
	usleep(100000);
	}
	
}
	return res;
}
#else

void mb_getreagentliquitcab(emb_comid comPort)
	{
		
			int res,i,timeout_counter=0,error_counter = 0;
		unsigned short crc=0;
		unsigned char cmdbuffer[10] ={0};
	//	unsigned char sensor_state = 0;
		static unsigned short last_cabin_state[6] = {1,1,1,1,1,1};//0表示被拔出 1表示装入状态//DEW WATER ALCHOLE WASH ER1 ER2
	//	stminibd_sendpacket cmd;
		static  short last_cabin_val[6] = {0};
		static unsigned short last_cabin_value[12]={0};
		static BOOL fisrt_value = TRUE;
		memset(cmdbuffer,0,sizeof(cmdbuffer));
		static int selcnt = 0;
		short sen_change = 0;
		char Isallzero = 0;

			if (selcnt > 5)
				selcnt = 0;
			else
				selcnt++;
			
	selcnt = 0;
			cmdbuffer[0] = 0xff;
			cmdbuffer[1] = 0x00;
			cmdbuffer[2] = selcnt;
			crc = crc16_ccitt(&cmdbuffer[1], 2);
			memcpy((char*)&cmdbuffer[3],&crc,2);
			cmdbuffer[5] = 0xfe;
			tcflush(serail_hand[comPort],TCOFLUSH);
	
	//		for (i = 0;i < 6;i++)
		//		printf(" %x",cmdbuffer[i]);
			res = write(serail_hand[comPort],cmdbuffer,6);
	
			if (res < 0)
				printf("write weight error\n");
			
	
	//	printf("need_perfusion= %d\n ",need_perfusion[0]);
		while(!readfinished485)
		{
			usleep(100);
			if (timeout_counter >= 60000)
			{
				printf("recieve weight timeout send cmd again\n");
		//		printf("need_perfusion= %d\n ",need_perfusion[0]);
				res = write(serail_hand[comPort],cmdbuffer,6);
				if (res < 0)
					printf("write weight error\n");
				
				timeout_counter = 0;
			}
			if (error_counter >= 300000)
			{
				if (!initialize_finished)//只在初始化时报错
					mb_seterrorcode(CONNECT_ERROR_WEIGHT);
		
				return;
			}
			timeout_counter++;
			error_counter++;
		}
		 
		if (ReadBufferweight[0] == 0)
		{
		//	printf("data484 from weight\n");
		//	printf("need_perfusion= %d\n ",need_perfusion[0]);
			if(ReadBufferweight[1] == WATER_ACK)
			{
		//		printf("ack from weight\n");
		//		printf("need_perfusion= %d\n ",need_perfusion[0]);
				pthread_mutex_lock(&mutex_cabinlock);
				memset(ReadBufferweight,0,sizeof(ReadBufferweight));
				readindexweight = 0;
				readfinished485 = FALSE;
				pthread_mutex_unlock(&mutex_cabinlock);
				error_counter = 0;
				while(!readfinished485)
				{
					usleep(100000);
					if (error_counter >= 100)
					{
						printf("communicating with weight error response\n");
						memset(ReadBufferweight,0,sizeof(ReadBufferweight));
						readindexweight = 0;
						readfinished485 = FALSE;
						return;
					}
					error_counter++;
				}
		//		printf("response need_perfusion= %d\n ",need_perfusion[0]);
		//		pthread_mutex_lock(&report_lock);
				
				memcpy((char*)cabin_value, &ReadBufferweight[1], 18);			
				for ( i = 12;i < 18;i++)
				{
					cabin_value[i - 6] = ReadBufferweight[i + 1];
				}

		//		sen_change = cabin_value[4];
			//	 cabin_value[4] =  cabin_value[5];
			//	  cabin_value[5] =sen_change;
				
			//	printf("last_cabin_state[]=");
			for(i = 0; i < 6;i++)
			{
				if(last_cabin_state[i] == 1 && cabin_value[6 + i] == 0)
					Isallzero = 1;
				else
				{
					Isallzero = 0;
					break;
				}
			}

			if(!Isallzero)
				{
				for (i = 0; i < 6;i++)
				{
			//		printf(" %d **",last_cabin_state[i]);
			//		printf(" %d ",need_perfusion[i]);
					if (last_cabin_state[i] == 0 && cabin_value[6 + i] == 1)	//当有0变成1时表示试剂桶装入
					{
						need_perfusion[i]++;//在其他操作中发现先前值与当前值不同 灌注后重复其操作
													
					}
					last_cabin_state[i] = cabin_value[6 + i];//赋值 当前值
				}
				}
				
			
		
#if 0			 
if (BIG_VIERSION)
{
	for (i = 0;i < 6;i++)
	{ 
		 if (abs(last_cabin_val[i] - cabin_value[i]) < 500)
		{
			if (cabin_value[i] >=  last_cabin_val[i])
				cabin_value[i] = last_cabin_val[i];
			else
				last_cabin_val[i] = cabin_value[i];
		 }
		 else
		 	last_cabin_val[i] = cabin_value[i];
	}
}
#endif
		#if 0
				printf("cabin_value=\n");
				for (i = 0;i < 12;i++)
				{
					 
					printf(" %d ",*(unsigned short*)&cabin_value[i]);
				//	printf(" %x ",cabin_value[i]);
				}
		#endif
		//		pthread_mutex_unlock(&report_lock);
#if 0
				for (i = 0; i < 6;i++)
				{
					if ((cabin_value[i] == 1 || cabin_value[i + 6] == 0 ) && flg_cabinhavereagent[i] == 1)
						break
				}
				if (i >= 6)
					beep_state.cabin = 0;
				else
					beep_state.cabin = 1;
#endif
					if (fisrt_value)
					{
						memcpy((char *)last_cabin_value, (char *)cabin_value, 24);
						fisrt_value = FALSE;
						flg_cabinreved = TRUE;
					}
					else
					{
						if(!Isallzero)
						{
							if (memcmp((char *)last_cabin_value, (char *)cabin_value, 24) != 0)
								flg_cabinreved = TRUE;
							else 
								flg_cabinreved = FALSE;
						}
	
						memcpy((char *)last_cabin_value, (char *)cabin_value, 24);
					}
				}
			
		/*	printf("after memcpy last_cabin_state[]=");
				for (i = 0; i < 6;i++)
				{
					printf(" %d **",last_cabin_state[i]);
					}
				*/
			//	printf("sensor_state=%d\n", sensor_state);
	
			//解析结束清数据
			pthread_mutex_lock(&mutex_cabinlock);
			memset(ReadBufferweight,0,sizeof(ReadBufferweight));
			readindexweight = 0;
			readfinished485 = FALSE;
			pthread_mutex_unlock(&mutex_cabinlock);
		}
	}

#endif
/******************************************************************************
*
* Function Name  : mb_waterctrl
* Description    : 水箱控制
* 					 
* Input		   :emb_comid comPort 串口号, unsigned char cmd 命令码
* Output		   :
* Return		   :  int 错误-1 正确0
*******************************************************************************/
int mb_waterctrl(emb_comid comPort,unsigned char cmd)
{
	int res,i,timeout_counter=0,error_counter = 0;
	unsigned short crc=0;
	unsigned char cmdbuffer[10] ={0};

return;
	memset(cmdbuffer,0,sizeof(cmdbuffer));

		cmdbuffer[0] = 0xff;
		cmdbuffer[1] = 0x01;
		cmdbuffer[2] = cmd;
		crc = crc16_ccitt(&cmdbuffer[1], 2);
		memcpy(&cmdbuffer[3],&crc,2);
		cmdbuffer[5] = 0xfe;
		tcflush(serail_hand[comPort],TCOFLUSH);

		for (i = 0;i < 6;i++)
			printf(" %x",cmdbuffer[i]);
		res = write(serail_hand[comPort],cmdbuffer,6);
		if (res < 0)
			printf("write water error\n");
		else
			printf("write water successed\n");

	while(!readfinished485)
	{
	
		usleep(100000);
		if (timeout_counter >= 20)
		{
			printf("recieve water timeout send cmd again\n");
			res = write(serail_hand[comPort],cmdbuffer,6);
			if (res < 0)
				printf("write water error\n");
			else
				printf("write water successed\n");
			timeout_counter = 0;
		}
		if (error_counter >= 100)
		{
			mb_seterrorcode(CONNECT_ERROR_WATER);
	
			return -1;
		}
		timeout_counter++;
		error_counter++;
	}

		
	if (ReadBuffer485[0] == 1)
	{
		printf("data484 from water\n");
		if(ReadBuffer485[1] == WATER_ACK)
		{
			printf("ack from water\n");
			memset(ReadBuffer485,0,sizeof(ReadBuffer485));
			readindex485 = 0;
			readfinished485 = FALSE;
			error_counter = 0;
			while(!readfinished485)
			{
				usleep(100000);	
				if (error_counter >= 5000)
				{
					printf("communicating with water error response\n");
					return -1;
				}
				error_counter++;
			}

			if(ReadBuffer485[1] == WATER_WORK_NORMAL) 
			{
				printf("WATER_WORK_NORMAL\n");
			}
			else
			{
				//mb_seterrorcode(WATER_PROVIDE_ERROR);
			}
		}

		//解析结束清数据
		memset(ReadBuffer485,0,sizeof(ReadBuffer485));
		readindex485 = 0;
		readfinished485 = FALSE;
	}
	return 0;
}

BOOL sc_getcsanbanack(const int fd,const char *Buf1,int len)
{
	  char	  Buf0=0;
	  char ReBuf[50] = {0};
	  short check_sum = 0,sum = 0;
	int ack_counter=0,try_connect_again = 0,i;
	char inited = 0;
	
	printf("Buf= len=%d\n",len );
		for(i = 0; i< len;i++)
			printf(" %x ",Buf1[i]);
		

	memcpy(ReBuf, Buf1, len);
	ReBuf[3] = 1; // set resend

	for (i=0;i<len - 2;i++)
		sum +=  ReBuf[i];

	check_sum = ~sum + 1;

	ReBuf[len - 2] = (check_sum & 0XFF00) >> 8;	
	ReBuf[len - 1] = check_sum & 0XFF ;
#if 0
	printf("ReBuf= len=%d\n",len );
	for(i = 0; i< len;i++)
		printf(" %x ",ReBuf[i]);
	printf("\n");
	while(1);
	return TRUE;
#endif
//	ReBuf[len - 2] = 0XFF ;	
//	ReBuf[len - 1] =0X12 ;
	//	scanner_acknum = 0;

		while(scanner_acknum != 1)
		{
			 usleep(100000);
			 if (ack_counter++ > 50)
			 {
			 	if(!inited)
			 	{
			 		ack_counter = 0;
					try_connect_again = 0;
			 		inited = 1;
			 		if(!Isinitscanban)
						sc_scanerinition();
			 	}
				else
				{//	flg_scanerworking = 1;//确保下次扫描
					printf("CONNECT_ERROR_SCANNER\n");
					mb_seterrorcode(CONNECT_ERROR_SCANNER);
					return FALSE;
				}
				
				
			 }
			 if (try_connect_again++ > 10)
			{
				
				try_connect_again = 0;
				printf("send try_connectd scaner reactivate trigger success\n");	
		printf("ReBuf= len=%d\n",len );
	for(i = 0; i< len;i++)
		printf(" %x ",ReBuf[i]);
	printf("\n");
					tcflush( fd,TCOFLUSH);
					write(fd, ReBuf, len);
			 }
			 else if (scanner_acknum == 2)
			{
				sleep(1);
				printf("send scaner reactivate trigger success\n");	
	printf("ReBuf= len=%d\n",len );
	for(i = 0; i< len;i++)
		printf(" %x ",ReBuf[i]);
	printf("\n");
					tcflush( fd,TCOFLUSH);
					write(fd, ReBuf, len);
			 }
		}
		scanner_acknum = 0;
	return TRUE;
}
#define newxin 1
BOOL sc_scanerinition(void)
{
	int fd	= serail_hand[port_scanner];
	char Buf0 = 0;
	const char	  Buf1[6]={4,0xE4,4,0,0xFF,0x14};//4 //4 E4 4 0 FF 14 START
	char	Buf2[10]={8,0XC6,4,0,0XFF,0XF0,0X31,64,0XFC,0XCE};// 扫描图像质量
	char	Buf3[10]={8,0XC6,4,0,0XFF,0XF0,0X2D,0X01,0XFD,0X11};// 扫描图像大小 ENABLE
	char	Buf4[10]={8,0XC6,4,0,0XFF,0XF0,0X30,0X01,0XFD,0XE};// 扫描图像格式JPG
//	char	Buf4[10]={8,0XC6,4,0,0XFF,0XF0,0X30,0X03,0XFD,0XE};// 扫描图像格式BMP
	
	char	Buf5[9]={7,0XC6,4,0,0XFF,0X88,0X14,0XFD,0X94};// 扫描超时时间
//	char	Buf6[13]={11,0XC6,4,0,0XFF,0XF4,0XF0,0X3B,'1','0','1',0XFB,0XAB};// 扫描图像TOP	
//	char	Buf7[13]={11,0XC6,4,0,0XFF,0XF4,0XF0,0X3C,'3','0','0',0XFB,0XAA};// 扫描图像LEFT
//	char	Buf8[13]={11,0XC6,4,0,0XFF,0XF4,0XF0,0X3D,'3','7','9',0XFB,0XA9};// 扫描图像BOTTOM
//	char	Buf9[13]={11,0XC6,4,0,0XFF,0XF4,0XF0,0X3E,'4','5','0',0XFB,0XA8};// 扫描图像RIGHT
//	char	Buf10[10]={8,0XC6,4,0,0XFF,0XF0,0X2f,0X00,0XFD,0X10};// 扫描图像灰度
//	char	Buf11[10]={8,0XC6,4,0,0XFF,0XF0,0X86,0X3A,0XFC,0X59};// 扫描图像白平衡
//	char	Buf12[10]={8,0XC6,4,0,0XFF,0XF0,0X68,0X01,0XFC,0XD7};// 扫描图像自动曝光DISABLE
//	char	Buf13[10]={8,0XC6,4,0,0XFF,0XF1,0X38,0X10,0XFC,0XE6};// 扫描图像 GAIN 
//	char	Buf14[11]={9,0XC6,4,0,0XFF,0XF4,0XF1,0X37,0X9,0XFC,0XE6};// 扫描图像 曝光时间
//	char	Buf15[10]={8,0XC6,4,0,0XFF,0XF0,0X2c,0X00,0XFD,0X10};// 扫描图像 瞄准点
//	char	Buf16[10]={8,0XC6,4,0,0XFF,0XF0,0X9D,0X03,0XFD,0X10};// 扫描图像 补光亮度
//	char	Buf17[10]={8,0XC6,4,0,0XFF,0XF0,0X69,0X01,0XFD,0X10};// 扫描图像 补光disable
//	char 	Buf18[10]={8,0XC6,4,0,0XFF,0XF1,0X9D,10,0XFD,0XC};// LED亮度
	char	Buf19[30]={0X1C,0XC6,4,0,0XFF,0XF0,0X2D,1,0XF4,0XF0,
					0X3B,0,130,0XF4,0XF0,0X3C,1,40,0XF4,0XF0,0X3D,1,0,0XF4,0XF0,0X3E,1,230,0XF2,0XE8};//
	
//	char 	Buf20[10]={8,0XC6,4,0,0XFF,0XF1,0X9C,0X10,0XFD,0XC};// AIM 亮度
	
//	char	Buf21[10]={8,0XC6,4,0,0XFF,0XF1,0X34,3,0XFC,0XE6};// 对比度
	
//	char	Buf22[10]={8,0XC6,4,0,0XFF,0XF0,0X32,2,0XFC,0XE6};// decode aim
	char	Buf23[9]={7,0XC6,4,0,0XFF,0X80,0X00,0XFD,0XB0};// 扫描中心识别	
	char   Bufall[40]={0x26, 0xC6, 0x04, 0x00, 0xFF, 0xF0, 0x31, 0x40, 0xF0, 0x30, 0x01, 0x88, 0x14, 0x80, 0x00, 0xF0,
		0x2D, 0x01, 0xF4, 0xF0, 0x3B, 0x00, 0x82, 0xF4, 0xF0, 0x3C, 0x01, 0x28, 0xF4, 0xF0, 0x3D, 0x01, 0x00, 0xF4,
		0xF0, 0x3E, 0x01, 0xE6, 0xEF, 0x40};
	Isinitscanban = 1;

	tcflush( fd,TCOFLUSH);

write(fd, &Buf0,1);   //激活扫描头
	usleep(200000);

#if newxin
		write(fd, &Bufall,sizeof(Bufall));	//激活扫描头
			if (!sc_getcsanbanack(fd, Bufall,sizeof(Bufall)))
					return FALSE;	
#else

		write(fd, &Buf23,sizeof(Buf23));	//激活扫描头
		if (!sc_getcsanbanack(fd, Buf23,sizeof(Buf23)))
				return FALSE;	
						
				 write(fd, &Buf3,sizeof(Buf3));  //激活扫描头
				 if (!sc_getcsanbanack(fd, Buf3,sizeof(Buf3)))
							 return FALSE;
							
					  write(fd, &Buf2,sizeof(Buf2));  //激活扫描头
				 if (!sc_getcsanbanack(fd, Buf2,sizeof(Buf2)))
							 return FALSE;
			
				
			 write(fd, &Buf4,sizeof(Buf4));  //激活扫描头
				 if (!sc_getcsanbanack(fd, Buf4,sizeof(Buf4)))
							 return FALSE;
			 write(fd, &Buf5,sizeof(Buf5));  //激活扫描头
				 if (!sc_getcsanbanack(fd, Buf5,sizeof(Buf5)))
							 return FALSE;
				 
			
					write(fd, &Buf19,sizeof(Buf19));	//激活扫描头
						if (!sc_getcsanbanack(fd, Buf19,sizeof(Buf19)))
								return FALSE;	
	#endif			
			Isinitscanban = 0;

			/*

						write(fd, &Buf5,9);	//激活扫描头
					  printf("send scaner activate trigger success fd= %d\n", fd);
					printf("Buf13=\n");
					usleep(200000);
					if (!sc_getcsanbanack(fd, Buf5,sizeof(Buf5)))
							return FALSE;
						
						write(fd, &Buf6,13);	//激活扫描头
						  printf("send scaner activate trigger success fd= %d\n", fd);
						printf("Buf13=\n");
						usleep(200000);
						if (!sc_getcsanbanack(fd, Buf6,sizeof(Buf6)))
								return FALSE;

						write(fd, &Buf7,13);	//激活扫描头
						  printf("send scaner activate trigger success fd= %d\n", fd);
						printf("Buf13=\n");
						usleep(200000);
						if (!sc_getcsanbanack(fd, Buf7,sizeof(Buf6)))
								return FALSE;
							write(fd, &Buf8,13);	//激活扫描头
						  printf("send scaner activate trigger success fd= %d\n", fd);
						printf("Buf13=\n");
						usleep(200000);
						if (!sc_getcsanbanack(fd, Buf8,sizeof(Buf6)))
								return FALSE;
							write(fd, &Buf9,13);	//激活扫描头
						  printf("send scaner activate trigger success fd= %d\n", fd);
						printf("Buf13=\n");
						usleep(200000);
						if (!sc_getcsanbanack(fd, Buf9,sizeof(Buf6)))
								return FALSE;

*/

#if 0
		usleep(200000);
					 write(fd, &Buf3,10);	//激活扫描头
					  printf("send scaner activate trigger success fd= %d\n", fd);
					printf("BUF3=\n");
					usleep(200000);
					if (!sc_getcsanbanack(fd, Buf3,sizeof(Buf3)))
								return FALSE;
						

		usleep(500000);
			write(fd, &Buf6,11);    //激活扫描头
						 printf("send scaner activate trigger success fd= %d\n", fd);
					   printf("BUF6=\n");
					   usleep(200000);
					   if (!sc_getcsanbanack(fd, Buf6,sizeof(Buf6)))
								   return FALSE;
		usleep(500000);	
			write(fd, &Buf7,11);    //激活扫描头
						 printf("send scaner activate trigger success fd= %d\n", fd);
					   printf("Buf7=\n");
					   usleep(200000);
					   if (!sc_getcsanbanack(fd, Buf7,sizeof(Buf7)))
								   return FALSE;
					   usleep(500000);

			write(fd, &Buf8,11);    //激活扫描头
						 printf("send scaner activate trigger success fd= %d\n", fd);
					   printf("Buf8=\n");
					   usleep(200000);
					   if (!sc_getcsanbanack(fd, Buf8,sizeof(Buf8)))
								   return FALSE;
					   usleep(500000);

			write(fd, &Buf9,11);    //激活扫描头
						 printf("send scaner activate trigger success fd= %d\n", fd);
					   printf("Buf9=\n");
					   usleep(200000);
					   if (!sc_getcsanbanack(fd, Buf9,sizeof(Buf9)))
								   return FALSE;

#endif
			
	/*		
			write(fd, &Buf2,10);   //激活扫描头
						 printf("send scaner activate trigger success fd= %d\n", fd);
					   printf("BUF2=\n");
					   usleep(200000);
					   if (!sc_getcsanbanack(fd, Buf2,sizeof(Buf2)))
								   return FALSE;
					   
*/

	
			
		
			
			
}
BOOL sc_getscanerhoney(const unsigned char plate_num,BOOL IsReagent)
	{
			char TCP_Buffer[50000] = {0};
		//	char string[20] = {0};
			int write_len = 0;
			int fd	= serail_hand[port_scanner];
			int res_scan = 0,counter=0;
		//	struct timeval scan_now;
		//	struct timespec scan_timeout;
		//	unsigned int** ordArray_reagent;
			char eenetevent=NO_EVENT;
			const char	  Buf1[3]={0x16, 0x54, 0x0D};
			const char	  Buf3[3]={0x16, 0x55, 0x0D};
		//	const char	  Buf4[11]={22,77,13,'S','C','N','A','I','M','0','.'};
			char	Buf4[20]={0};
		//	const char	  Buf5[14]={0x16, 0x4D, 0x0D, 0x52, 0x45, 0x56, 0x5F, 0x43, 0x43, 0x3F, 0x2E, 0x16, 0x54, 0x0D};
			BOOL res = TRUE;
			char try_again=0;
			reagentoutside_list * reagentoutside_head_tmp = reagentoutside_head, *reagentoutside_head_lst = NULL;
		//	char * image_snap_cmd = "IMGSNP2P50E255D150W1L.";
			//char * image_snap_cmd = "IMGSNP1L.";
			char * image_snap_cmd = "IMGSNP0T.";
		
		//	char * image_cmd = "IMGSHP178L463R163T318B14E8F1D3P0~.";
		//	char * image_cmd = "IMGSHP1D14E8F180L460R150T380B3P0~.";//MY
			
		//	char * image_cmd = "IMGSHP1D5E8F0IR0IF0T450B3P0~.";
		//	char * image_cmd = "IMGSHP3P1D8F0~.";
	
	//	char * image_cmd = "IMGSHP1D14E8F135L505R150T310B3P0~.";//TST
		//char * image_cmd ="IMGSHP6F2P.";
		char * image_cmd ="IMGSHP1D6F220L420R150T280B2P.";
			char Buf2[50] = {0};
			/*
			const char	Buf2[42] = {0x16,0x4D,0x0D,0x49,0x4D,0x47,0x53,0x48,0x50,0x38,0x46,0x31,
			0x44,0x33,0x50,0x31,0x32,0x35,0x4C,0x35,0x52,0x35,0x42,0x35,0x4D,0x32,0x49,0x52,0x33,0x30,0x4B,0x30,0x55,0x31,0x35,0x45,0x30,0x49,
			0x46,0x30,0x7E,0x2E};
			*/ 
			static char lat_scan_OCR_data[20] = {0};
			char retry_cnt = 0;
			char get_image_cnt = 0;
			int i=0;
#if 0	// MENU CMD
			Buf4[0] = 22;
			Buf4[1] = 77;
			Buf4[2] = 13;
		//	strcpy(&Buf4[3],"VIDREV1.");
			strcpy(&Buf4[3],"SCNAIM0.");
			tcflush( fd,TCOFLUSH);
			  //0917171177?
				 if (write(fd, Buf4, sizeof(Buf4)) < 0)
					printf("send scaner activate trigger failed fd= %d\n", fd);
				 else
					printf("send scaner activate trigger success fd= %d\n", fd);
		
			return TRUE;	
#endif 
		
		//	printf("flg_scanerworking=%d\n",flg_scanerworking);
	//printf("\n");
		//return TRUE;
			while (flg_scanerworking == 0) 
			usleep(1000);
	
			image_cmd_len = strlen(image_cmd);
	
	SCAN_AGAIN:
			flg_scanerworking = 0;
		//	sleep(1);
			tcflush( fd,TCOFLUSH);
			  //091717081717
				 if (write(fd, Buf1, sizeof(Buf1)) < 0)
					printf("send scaner activate trigger failed fd= %d\n", fd);
				 else
					printf("send scaner activate trigger success fd= %d\n", fd);
		
		//	 usleep(100000);
			while(!flg_scanerworking)
			{
				counter++;
					
				usleep(1000);
				if (counter > 1000) 	//171702051717OCR 171704170117 171717171702171177?(1717170217171717001717170017761177?
				{
					printf("recived data from scaner time out \n");
					printf("\n");
					counter = 0;
					try_again++;
					if (IsReagent)	//09171717041701091717171717171717	04091717011717return
					{
						printf("send scaner reactivate trigger success\n");
						flg_scanerworking = 1;//021717170717091717
						tcflush( fd,TCOFLUSH);
						write(fd, Buf3, sizeof(Buf3));
						return FALSE;		
					 }
					else 
					{
#if 0	
						if (try_again < 2)
						{
							
							counter = 0;
							tcflush( fd,TCOFLUSH);
							write(fd, Buf3, sizeof(Buf3));
							usleep(500000);
							tcflush( fd,TCOFLUSH);
							//091717081717
							 if (write(fd, Buf1, sizeof(Buf1)) < 0)
								printf("send scaner activate trigger failed fd= %d\n", fd);
							 else
								printf("send scaner activate trigger success fd= %d\n", fd);
							continue;
						}
						else
#endif
						{
							tcflush( fd,TCOFLUSH);
							write(fd, Buf3, sizeof(Buf3));
							res = FALSE;
							break;
						}
					}
					 
				
				}
			}
			
				res_scan = 0;
			printf("cmp %s %s\n",lat_scan_OCR_data,scan_OCR_data);
			if (!IsReagent)
			{
				if ( (strcmp(scan_OCR_data, lat_scan_OCR_data) == 0) && scan_OCR_data[0] != 0 && retry_cnt < 2)
				{
					retry_cnt++;
					sleep(1);
					goto	SCAN_AGAIN;
				}
					
				if ( (strcmp(scan_OCR_data, lat_scan_OCR_data) == 0))
				{
					memset(scan_OCR_data,0,sizeof(scan_OCR_data));
					scan_OCR_len = 0;
				}
			
			}
			 if (IsReagent)
				eenetevent = REAGENTCODE_SEND;
			 else
				eenetevent = SCANNER_SEND;
			 
		//		eenetevent = eenetevent | 0x05000000;
			eenetevent = eenetevent | ((unsigned int )plate_num << 24);
				TCP_Buffer[0] = plate_num;
				memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);
				strcpy(lat_scan_OCR_data,scan_OCR_data);
				
		//	if (scan_OCR_len != 0)	//scanner get OCR					//OCR17171717170417171717171717171177?
			{
				if (IsReagent)
				{
					strcpy(reagent_code[plate_num].code,scan_OCR_data);
					while(strcmp(reagentoutside_head_tmp->reagent_info.code,(char*)scan_OCR_data) != 0)//0017171717171709171717041717и17170417170917171717
					{
						reagentoutside_head_tmp = reagentoutside_head_tmp->next;
						if (reagentoutside_head_tmp == NULL)
							break;
					}
					
					if ( reagentoutside_head_tmp != NULL)//17171717 FALSE 171717170417171717170417
					{
						//17171717170417171704
						memcpy(&reagent_code[plate_num], &reagentoutside_head_tmp->reagent_info, sizeof(reagent_t));
						res = FALSE;
					}
		
			//		printf("scan_OCR_data = %s\n", scan_OCR_data);
				
				//04091717OCR17171717041717171717171706081717λ17171717041717170117171177?
		//		while ((res_scan = nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1)) < 0) sleep(1);
		
					nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1);//171717171717170717 0X0A,0X0B
				memset(scan_OCR_data,0,sizeof(scan_OCR_data));
				scan_OCR_len = 0;
				}
		
			
				
			}
		/*
			else					//scanner can not get OCR
			{
				while(flg_netdisconnect) sleep(1);
				pthread_mutex_lock(&netsend_lock);
				if (send(local_fd, &eenetevent, sizeof(eenetevent), 0) < 0)
					perror("write net\n");
				pthread_mutex_unlock(&netsend_lock);
			}
		*/	
			
			
		
		if (!IsReagent)
		{
			counter = 0;
			//printf("send image cmd\n");
			/*
			while(counter < (strlen(image_cmd) + 3))
			{
				printf(" %x ", Buf2[counter]);
				counter++;
			}
			*/
	GET_IMAGE:
#if 0 
	
			 //171700001717081717
			Buf2[0]=0x16;
			Buf2[1]=0x4D;
			Buf2[2]=0x0D;
			memcpy(&Buf2[3],image_snap_cmd,strlen(image_snap_cmd));
			write_len = write(fd, Buf2, (strlen(image_snap_cmd) + 3));
		//	printf("send scaner get snap_image success image_snap_cmd= %s\n", image_snap_cmd);
		//	printf("IMGSNP_ACK=%d", IMGSNP_ACK);
			counter = 0;
			while(!IMGSNP_ACK)
			{
				counter++;
				usleep(10000);
				if (counter > 500)
				{
					flg_scanerworking = 1;//021717170717091717
					printf("CONNECT_ERROR_SCANNER\n");
					mb_seterrorcode(CONNECT_ERROR_SCANNER);
					return FALSE;
				}
			} 
			
#endif 
			Buf2[0]=0x16;
			Buf2[1]=0x4D;
			Buf2[2]=0x0D;
			memset(&Buf2[3], 0, strlen(image_snap_cmd));
			memcpy(&Buf2[3],image_cmd,strlen(image_cmd));
			
			write_len = write(fd, Buf2, (strlen(image_cmd) + 3));
			printf("send scaner get image success fd= %d\n", fd);
			for(i = 0; i<(strlen(image_cmd) + 3);i++)	
				printf("%c",Buf2[i]);
			
		//	tcflush( fd,TCOFLUSH);
		//	write(fd, Buf3, sizeof(Buf3));
			IsGetImage = 1;
			flg_scanerworking = 0;
			counter = 0;
			while (flg_scanerworking == 0)
			{
				counter++;
				usleep(10000);
				if (counter > 500)
				{
					flg_scanerworking = 1;//021717170717091717
					printf("CONNECT_ERROR_SCANNER\n");
					mb_seterrorcode(CONNECT_ERROR_SCANNER);
					return FALSE;
				}
			}
			printf("scan_OCR_data = %s\n", scan_OCR_data);
	
			
			memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);
			if (scan_OCR_data[0] == 0 && plate_num == 0XED)//17170517λ1717000409171177?
				{}
			else
				nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1);
					
			memset(scan_OCR_data,0,sizeof(scan_OCR_data));
			scan_OCR_len = 0;
	
			if (scan_data_len == 0 && get_image_cnt == 0)
			{
				get_image_cnt++;
				goto GET_IMAGE;
			}
			TCP_Buffer[0] = plate_num;
			if (plate_num == 0XED)
				TCP_Buffer[0] = 0XEE;
			memcpy(&TCP_Buffer[1],scan_data,scan_data_len);
		//	printf("*******************scan_data_len = %d**********************\n", scan_data_len);
		//	while(nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1) < 0) sleep(1);
		//	if (plate_num >=20)
			if ((counter = nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1)) > 0)
			{
		//		printf("send scanner data to tcp success len = %d*******************\n", counter);
			}
		
			memset(scan_data,0,sizeof(scan_data));
			scan_data_len = 0;
		}
			 write(fd, Buf3, sizeof(Buf3));
		//	printf("send scaner stop cmd success fd= %d\n", fd);
			
			
			return res;
		}



BOOL sc_scanergetban(const unsigned char plate_num,BOOL IsReagent)
{
	char TCP_Buffer[100000] = {0};
			int write_len = 0,i=0;
			int fd	= serail_hand[port_scanner];
			int res_scan = 0,counter=0,ack_counter=0;
			char eenetevent=NO_EVENT;
			const char	  Buf0=0;
			const char	  Buf1[6]={4,0xE4,4,0,0xFF,0x14};//4 //4 E4 4 0 FF 14 START
			const char	  Buf3[6]={4,0xE5,4,0,0xFF,0x13};//STOP
			char	Buf4[7]={5,0xF7,4,0,1,0XFE,0XFF};
			
			char ACKBUF[6]={4,0XD0,4,0,0XFF,0X28};
			short check_sum = 0,sum=0;
			BOOL res = TRUE;
			char try_again=0,try_connect_again = 0;
			reagentoutside_list * reagentoutside_head_tmp = reagentoutside_head, *reagentoutside_head_lst = NULL;
	//		char * image_snap_cmd = "IMGSNP1L.";
	//		char * image_cmd = "IMGSHP1D14E8F135L505R150T310B3P0~.";//TST
			char Buf2[50] = {0};
			int image_cnt = 0,code_cnt = 0;
				
		printf("sc_scanergetban\n");


//	while (flg_scanerworking == 0) 
//		usleep(1000);

		
		flg_scanerworking = 0;
		IsGetImage =FALSE;
		InGetImage = FALSE;
		flg_scannerlastimage = FALSE;
		IsGetCode = FALSE;

	if (!IsReagent)
		{
		
			scan_data_len = 0;
			scanner_acknum = FALSE;
	
	 IsGetImage =1; 

#if newxin
#else
	  if (write(fd, Buf1, sizeof(Buf1)) < 0)
				printf("send scaner activate trigger failed fd= %d\n", fd);
			 else
				printf("send scaner activate trigger success fd= %d\n", fd);
	
		if (!sc_getcsanbanack(fd, Buf1,sizeof(Buf1)))
			return FALSE;	
#endif

#if 1
		 //获取图像指令
//	while(1)
		{
	 tcflush( fd,TCOFLUSH);
		if (write(fd, Buf4, sizeof(Buf4)) < 0)
					  printf("send scaner activate trigger failed fd= %d\n", fd);
				   else
					  printf("send scaner activate trigger success fd= %d\n", fd);
//		usleep(100000);
		}		   
		if (!sc_getcsanbanack(fd, Buf4,sizeof(Buf4)))
						return FALSE;			   

#endif


		

		 //扫描指令
			 if (write(fd, Buf1, sizeof(Buf1)) < 0)
				printf("send scaner activate trigger failed fd= %d\n", fd);
			 else
				printf("send scaner activate trigger success fd= %d\n", fd);
	
		if (!sc_getcsanbanack(fd, Buf1,sizeof(Buf1)))
			return FALSE;


					  

	while(!flg_scannerlastimage)
	{
		if (flg_scannerrecivimage)
		{
			
			flg_scannerrecivimage = FALSE;
		//	printf("flg_scannerrecivimage((((((((((((((((((((((\n");
			
		}
		usleep(10000);
		if (image_cnt++ > 1000)
			{
			if (write(fd, Buf1, sizeof(Buf1)) < 0)
					   printf("send scaner activate trigger failed fd= %d\n", fd);
					else
					   printf("send scaner activate trigger success fd= %d\n", fd);
			
			   if (!sc_getcsanbanack(fd, Buf1,sizeof(Buf1)))
				   return FALSE;

		}
		if (image_cnt++ > 1500)
		{
			printf("CONNECT_ERROR_SCANNER\n");
				mb_seterrorcode(CONNECT_ERROR_SCANNER);
				return FALSE;
			break;
		}
	}
	printf("image_cnt =%d scan_data_len=%d\n",image_cnt,scan_data_len);
	flg_scannerlastimage = FALSE;
	/*
	for (i = 0; i < scan_data_len;i++)
		printf( "%c", scan_data[i]);
	printf("\n end \n");
	*/
		scan_data_len -= 10;
	TCP_Buffer[0] = plate_num;
		if (plate_num == 0XED)
			TCP_Buffer[0] = 0XEE;
		memcpy(&TCP_Buffer[1],&scan_data[10],scan_data_len);//10字节头去掉
	//	printf("*******************scan_data_len = %d**********************\n", scan_data_len);
	//	while(nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1) < 0) sleep(1);
	//	if (plate_num >=20)
		if ((counter = nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1)) > 0)
		{
	//		printf("send scanner data to tcp success len = %d*******************\n", counter);
		}
	
		memset(scan_data,0,sizeof(scan_data));
		scan_data_len = 0;
		
}
 //扫描指令
 IsGetCode = TRUE;

 write(fd, &Buf0,1);   //激活扫描头
			  usleep(20000);
			 if (write(fd, Buf1, sizeof(Buf1)) < 0)
				printf("send scaner activate trigger failed fd= %d\n", fd);
			 else
				printf("send scaner activate trigger success fd= %d\n", fd);
	
		if (!sc_getcsanbanack(fd, Buf1,sizeof(Buf1)))
			return FALSE;

		while(!flg_scanerworking)
		{
			usleep(200000);
			if (code_cnt++ > 10)
			{
				res = FALSE;
				break;
			}
		}
		/*
		tcflush( fd,TCOFLUSH);
			write(fd, Buf3, sizeof(Buf3));
			if (!sc_getcsanbanack(fd, Buf3,sizeof(Buf3)))
						return FALSE;
		*/
		
		printf("scan_OCR_data = %s\n", scan_OCR_data);
		memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);

		 if (IsReagent)
			eenetevent = REAGENTCODE_SEND;
		 else
			eenetevent = SCANNER_SEND;
		 
	//		eenetevent = eenetevent | 0x05000000;
		eenetevent = eenetevent | ((unsigned int )plate_num << 24);
			TCP_Buffer[0] = plate_num;
			memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);
	//	if (scan_OCR_len != 0)	//scanner get OCR					//OCR码与二维码数据类似
		{
			if (IsReagent)
			{
				strcpy(reagent_code[plate_num].code,scan_OCR_data);
				while(strcmp(reagentoutside_head_tmp->reagent_info.code,(char*)scan_OCR_data) != 0)//寻找在已扫描试剂中该试剂是否存在
				{
					reagentoutside_head_tmp = reagentoutside_head_tmp->next;
					if (reagentoutside_head_tmp == NULL)
						break;
				}
				
				if ( reagentoutside_head_tmp != NULL)//存在 FALSE 将不去检测此试剂	
				{
					//填入试剂信息
					memcpy(&reagent_code[plate_num], &reagentoutside_head_tmp->reagent_info, sizeof(reagent_t));
					res = FALSE;
				}
			}

			nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1);
				
			memset(scan_OCR_data,0,sizeof(scan_OCR_data));
			scan_OCR_len = 0;
						
		}
	
		

return res;

		
	
	
}

/**************扫描器*****************
plate_num == 0XEE 为扫描混合站
*****************************************/
/******************************************************************************
*
* Function Name  : sc_getscode
* Description    : 扫描头扫描
* 					 
* Input		   :unsigned char plate_num 玻片位置,BOOL IsReagent 是否为扫描试剂
* Output		   :
* Return		   :  BOOL 错误FLASE 正确TRUE
*******************************************************************************/
BOOL sc_getscode(const unsigned char plate_num,BOOL IsReagent)
	{
		char TCP_Buffer[50000] = {0};
	//	char string[20] = {0};
		int write_len = 0;
		int fd	= serail_hand[port_scanner];
		int res_scan = 0,counter=0;
	//	struct timeval scan_now;
	//	struct timespec scan_timeout;
	//	unsigned int** ordArray_reagent;
		char eenetevent=NO_EVENT;
		const char	  Buf1[3]={0x16, 0x54, 0x0D};
		const char	  Buf3[3]={0x16, 0x55, 0x0D};
	//	const char	  Buf4[11]={22,77,13,'S','C','N','A','I','M','0','.'};
		char	Buf4[20]={0};
	//	const char	  Buf5[14]={0x16, 0x4D, 0x0D, 0x52, 0x45, 0x56, 0x5F, 0x43, 0x43, 0x3F, 0x2E, 0x16, 0x54, 0x0D};
		BOOL res = TRUE;
		char try_again=0;
		reagentoutside_list * reagentoutside_head_tmp = reagentoutside_head, *reagentoutside_head_lst = NULL;
	//	char * image_snap_cmd = "IMGSNP2P50E255D150W1L.";
		char * image_snap_cmd = "IMGSNP1L.";
	//	char * image_cmd = "IMGSHP178L463R163T318B14E8F1D3P0~.";
	//	char * image_cmd = "IMGSHP1D14E8F180L460R150T380B3P0~.";//MY
		char * image_cmd = "IMGSHP1D14E8F135L505R150T310B3P0~.";//TST
	//	char * image_cmd = "IMGSHP1D5E8F0IR0IF0T450B3P0~.";
	//	char * image_cmd = "IMGSHP3P1D8F0~.";
		char Buf2[50] = {0};
		/*
		const char	Buf2[42] = {0x16,0x4D,0x0D,0x49,0x4D,0x47,0x53,0x48,0x50,0x38,0x46,0x31,
		0x44,0x33,0x50,0x31,0x32,0x35,0x4C,0x35,0x52,0x35,0x42,0x35,0x4D,0x32,0x49,0x52,0x33,0x30,0x4B,0x30,0x55,0x31,0x35,0x45,0x30,0x49,
		0x46,0x30,0x7E,0x2E};
		*/ 
		static char lat_scan_OCR_data[20] = {0};
		char retry_cnt = 0;
		char get_image_cnt = 0;

//	return TRUE;
		if (honey_scaner)
			return sc_getscanerhoney(plate_num,IsReagent);
		
		if (new_scaner)
			return sc_scanergetban(plate_num,IsReagent);
#if 0	// MENU CMD
		Buf4[0] = 22;
		Buf4[1] = 77;
		Buf4[2] = 13;
	//	strcpy(&Buf4[3],"VIDREV1.");
		strcpy(&Buf4[3],"SCNAIM0.");
		tcflush( fd,TCOFLUSH);
		  //扫描指
			 if (write(fd, Buf4, sizeof(Buf4)) < 0)
				printf("send scaner activate trigger failed fd= %d\n", fd);
			 else
				printf("send scaner activate trigger success fd= %d\n", fd);
	
		return TRUE;	
#endif 
	
	//	printf("flg_scanerworking=%d\n",flg_scanerworking);
//printf("\n");
	//return TRUE;
		while (flg_scanerworking == 0) 
		usleep(1000);

SCAN_AGAIN:
		flg_scanerworking = 0;
	//	sleep(1);
		tcflush( fd,TCOFLUSH);
		  //扫描指令
			 if (write(fd, Buf1, sizeof(Buf1)) < 0)
				printf("send scaner activate trigger failed fd= %d\n", fd);
			 else
				printf("send scaner activate trigger success fd= %d\n", fd);
	
	//	 usleep(100000);
		while(!flg_scanerworking)
		{
			counter++;
				
			usleep(1000);
			if (counter > 1000) 	//超时说明OCR 码没收到 或连接错误 (连接错误由接收图像处理)
			{
				printf("recived data from scaner time out \n");
				printf("\n");
				counter = 0;
				try_again++;
				if (IsReagent)	//扫描试剂只扫描条形码	没扫到直接return
				{
					printf("send scaner reactivate trigger success\n");
					flg_scanerworking = 1;//确保下次扫描
					tcflush( fd,TCOFLUSH);
					write(fd, Buf3, sizeof(Buf3));
					return FALSE;		
				 }
				else 
				{
#if 0	
					if (try_again < 2)
					{
						
						counter = 0;
						tcflush( fd,TCOFLUSH);
						write(fd, Buf3, sizeof(Buf3));
						usleep(500000);
						tcflush( fd,TCOFLUSH);
						//扫描指令
						 if (write(fd, Buf1, sizeof(Buf1)) < 0)
							printf("send scaner activate trigger failed fd= %d\n", fd);
						 else
							printf("send scaner activate trigger success fd= %d\n", fd);
						continue;
					}
					else
#endif
					{
						tcflush( fd,TCOFLUSH);
						write(fd, Buf3, sizeof(Buf3));
						res = FALSE;
						break;
					}
				}
				 
			
			}
		}
		
			res_scan = 0;
		printf("cmp %s %s\n",lat_scan_OCR_data,scan_OCR_data);
		if (!IsReagent)
		{
			if ( (strcmp(scan_OCR_data, lat_scan_OCR_data) == 0) && scan_OCR_data[0] != 0 && retry_cnt < 2)
			{
				retry_cnt++;
				sleep(1);
				goto	SCAN_AGAIN;
			}
				
			if ( (strcmp(scan_OCR_data, lat_scan_OCR_data) == 0))
			{
				memset(scan_OCR_data,0,sizeof(scan_OCR_data));
				scan_OCR_len = 0;
			}
		
		}
		 if (IsReagent)
			eenetevent = REAGENTCODE_SEND;
		 else
			eenetevent = SCANNER_SEND;
		 
	//		eenetevent = eenetevent | 0x05000000;
		eenetevent = eenetevent | ((unsigned int )plate_num << 24);
			TCP_Buffer[0] = plate_num;
			memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);
			strcpy(lat_scan_OCR_data,scan_OCR_data);
			
	//	if (scan_OCR_len != 0)	//scanner get OCR					//OCR码与二维码数据类似
		{
			if (IsReagent)
			{
				strcpy(reagent_code[plate_num].code,scan_OCR_data);
				while(strcmp(reagentoutside_head_tmp->reagent_info.code,(char*)scan_OCR_data) != 0)//寻找在已扫描试剂中该试剂是否存在
				{
					reagentoutside_head_tmp = reagentoutside_head_tmp->next;
					if (reagentoutside_head_tmp == NULL)
						break;
				}
				
				if ( reagentoutside_head_tmp != NULL)//存在 FALSE 将不去检测此试剂	
				{
					//填入试剂信息
					memcpy(&reagent_code[plate_num], &reagentoutside_head_tmp->reagent_info, sizeof(reagent_t));
					res = FALSE;
				}
	
		//		printf("scan_OCR_data = %s\n", scan_OCR_data);
			
			//没扫到OCR码或试剂条形码也要将位置信息发送出去
	//		while ((res_scan = nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1)) < 0) sleep(1);
	
			nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1);
				
			memset(scan_OCR_data,0,sizeof(scan_OCR_data));
			scan_OCR_len = 0;
			}
	
		
			
		}
	/*
		else					//scanner can not get OCR
		{
			while(flg_netdisconnect) sleep(1);
			pthread_mutex_lock(&netsend_lock);
			if (send(local_fd, &eenetevent, sizeof(eenetevent), 0) < 0)
				perror("write net\n");
			pthread_mutex_unlock(&netsend_lock);
		}
	*/	
		
		
	
	if (!IsReagent)
	{
		counter = 0;
		//printf("send image cmd\n");
		/*
		while(counter < (strlen(image_cmd) + 3))
		{
			printf(" %x ", Buf2[counter]);
			counter++;
		}
		*/
#if 1
GET_IMAGE:
		 //获取图像指令 
		Buf2[0]=0x16;
		Buf2[1]=0x4D;
		Buf2[2]=0x0D;
		memcpy(&Buf2[3],image_snap_cmd,strlen(image_snap_cmd));
		write_len = write(fd, Buf2, (strlen(image_snap_cmd) + 3));
	//	printf("send scaner get snap_image success image_snap_cmd= %s\n", image_snap_cmd);
	//	printf("IMGSNP_ACK=%d", IMGSNP_ACK);
		counter = 0;
		while(!IMGSNP_ACK)
		{
			counter++;
			usleep(10000);
			if (counter > 500)
			{
				flg_scanerworking = 1;//确保下次扫描
				printf("CONNECT_ERROR_SCANNER\n");
				mb_seterrorcode(CONNECT_ERROR_SCANNER);
				return FALSE;
			}
		}
		
#endif 
		Buf2[0]=0x16;
		Buf2[1]=0x4D;
		Buf2[2]=0x0D;
		memset(&Buf2[3], 0, strlen(image_snap_cmd));
		memcpy(&Buf2[3],image_cmd,strlen(image_cmd));
		
		write_len = write(fd, Buf2, (strlen(image_cmd) + 3));
	//	printf("send scaner get image success fd= %d\n", fd);
			
		
		tcflush( fd,TCOFLUSH);
		write(fd, Buf3, sizeof(Buf3));
		
		flg_scanerworking = 0;
		counter = 0;
		while (flg_scanerworking == 0)
		{
			counter++;
			usleep(10000);
			if (counter > 500)
			{
				flg_scanerworking = 1;//确保下次扫描
				printf("CONNECT_ERROR_SCANNER\n");
				mb_seterrorcode(CONNECT_ERROR_SCANNER);
				return FALSE;
			}
		}
		printf("scan_OCR_data = %s\n", scan_OCR_data);
		memcpy(&TCP_Buffer[1],scan_OCR_data,scan_OCR_len);
		if (scan_OCR_data[0] == 0 && plate_num == 0XED)//第一次混合站没扫到
			{}
		else
			nt_sendpacketdata(eenetevent, TCP_Buffer, scan_OCR_len + 1);
				
		memset(scan_OCR_data,0,sizeof(scan_OCR_data));
		scan_OCR_len = 0;

		if (scan_data_len == 0 && get_image_cnt == 0)
		{
			get_image_cnt++;
			goto GET_IMAGE;
		}
		TCP_Buffer[0] = plate_num;
		if (plate_num == 0XED)
			TCP_Buffer[0] = 0XEE;
		memcpy(&TCP_Buffer[1],scan_data,scan_data_len);
	//	printf("*******************scan_data_len = %d**********************\n", scan_data_len);
	//	while(nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1) < 0) sleep(1);
	//	if (plate_num >=20)
		if ((counter = nt_sendpacketdata(SCANNER_IMAGE_SEND, TCP_Buffer, scan_data_len + 1)) > 0)
		{
	//		printf("send scanner data to tcp success len = %d*******************\n", counter);
		}
	
		memset(scan_data,0,sizeof(scan_data));
		scan_data_len = 0;
	}
		 write(fd, Buf3, sizeof(Buf3));
	//	printf("send scaner stop cmd success fd= %d\n", fd);
		
		
		return res;
	}


/*************
当num == 0XFF 表示 测液体直到测不到或管路出错为止
***************/
/******************************************************************************
*
* Function Name  : mb_dabaspirateclear
* Description    : 在清洗混合站时吸取液体
* 					 
* Input		   :const unsigned char num 循环次数, BOOL NEED_ZS 是否测液体,unsigned int* Mixing_Sation 坐标指针
* Output		   :
* Return		   :  BOOL 错误FLASE 正确TRUE
*******************************************************************************/
int mb_dabaspirateclear(const unsigned char num, BOOL NEED_ZS,unsigned int* Mixing_Sation)
{
	sr_cmdstruct_t CommandElemt;
	unsigned char error_counter = 0, i = 0;
	BOOL is_clear = FALSE;

	for (i = 0; i < num; i++)		//循环吸取混合瓶中DAB混合液直到检测不到为止或管路出错
	{
			mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], MOV_ZH);//混合站目标位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
/*			
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dO%dP%dS%dI%dP%dO%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR,SYSPEED,WATERPORT,SYHHSTEP,PROBEPORT);	//缓慢抽吸空气拉1/4水
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
usleep(ASPIRATE_T);

*/
		if (NEED_ZS)
		{
				mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", 0, 0, DAB_ZMAX - 10);//测液体
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				
				if (sb_waitingframeaswer(&CommandElemt) < 0)	
				{
						mb_monitdoorstate();
						sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", 0, 0, DAB_ZMAX - 10);//再测液体
						if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
								CommandElemt.srdevaddr , 1, 0, 1) > 0)
								printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
							else
								printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
							
						if (sb_waitingframeaswer(&CommandElemt) < 0)	
							is_clear = TRUE;
				}
		}
			mb_monitdoorstate();
		if (is_clear)
			break;	
			CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", DAB_ZMAX);//
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_muiltreagentpour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );	
			sb_waitingframeaswer(&CommandElemt);
			
		CommandElemt.srdevaddr = PUMP_ADDR;
	//	sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_MIXDAB,SYHHSTEP);	//吸取1/4DAB
	
	sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_MIXDAB,SY45STEP);	//吸取1/4DAB
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);	
usleep(ASPIRATE_T);
		CommandElemt.srdevaddr = ARM_ADDR;
				sprintf(CommandElemt.cmdbuf, "ZS %d %d",  MOV_ZH - DAB_ZMAX, LIQUID_SPEED);//混合站目标位置
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);

		mb_monitdoorstate();
		
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dA%dR", SYSPEED,0);	//打光注射器中所有液体拉一下打光

	//	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT,SYFSTEP);	//打光注射器中所有液体拉一下打光
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);	
		error_counter++;
usleep(DISPENSE_T);

		if (error_counter > 8 && num == 0XFF)
		{
			CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
			return -1;
		}
	}

	return 0;
}

int mb_dabprobleclear(void)
{
	sr_cmdstruct_t CommandElemt;
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT);	//打光注射器中所有液体拉一下
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);	
usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dA%dI%dP%dO%dD%dR", SYSPEED,0,WATERPORT,SYFSTEP,PROBEPORT,SYFSTEP);	//打光注射器中所有液体拉一下打光
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	
usleep(DISPENSE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	
		
	sprintf(CommandElemt.cmdbuf, "ZA %d",0);
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	
		
	return 0 ;
}
int mb_findoperatedabkind(operate_head_list* operate_head,char kind)
{
	operate_t * operate_p = NULL;
	BOOL IsDAB = FALSE, IsRED = FALSE;
	
	operate_p = &operate_head->operate;
		
		while (operate_p != NULL)		//找出滴加混合试剂的时间
		{
			if (operate_p->reagent == REAGENT_DAB)
				IsDAB = TRUE;
			if (operate_p->reagent == REAGENT_SECEND)
				IsRED = TRUE;
			
			operate_p = operate_p->next;
		}
	if (!IsDAB && !IsRED)
		return -1;
	
	if (kind == 1 && IsDAB)
		return 1;
	else if (kind == 2 && IsRED)
		return 2;
}




int soak_work(char reagent_num, char percent)
	{
		sr_cmdstruct_t CommandElemt;
		int i =0;
		
		
		mb_shelfaspirate(reagent_num,1,1300,-1);
		
		nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dispensingliquid]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dispensingliquid]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		
		usleep(ASPIRATE_T);
		
		percent += 2;
		nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
		
		mb_monitdoorstate(); 
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dD%dM%dR", SYSPEED,PROBEPORT,SYSTEP_LIQUID*13 - SYSTEP_LIQUID*135/100,800);	//打掉剩余液体再拉1下打掉
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt); 
			
		for(i = 0;i<21;i++)
			{
		percent += 1;
		nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dD%dM%dP%dR", SYSPEED,PROBEPORT,SYSTEP_LIQUID*135/100,800,SYSTEP_LIQUID*135/100);	//打掉剩余液体再拉1下打掉
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt); 
/*
			if (i == 0)
				sleep(540);
			else
	
				sleep(3);
			*/
			}
		
		nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		reagent_flag = reagent_num;
		
	}



#if 0
int soak_work(char reagent_num, char percent)
{
		sr_cmdstruct_t CommandElemt;


	
mb_monitdoorstate();
	CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_reagent[reagent_num][0], ordArray_reagent[reagent_num][1], MOV_ZH);//到达试剂位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
mb_monitdoorstate();
		sprintf(CommandElemt.cmdbuf, "ZA %d", LIQUID_ZMAX);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);	
		
sleep(600);			
	sprintf(CommandElemt.cmdbuf, "ZS -%d %d",LIQUID_ZMAX - 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
									CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
						
					sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);

	percent += 2;
}
#endif
#if 1
int wash4_aspirate(void)
{
	
	sr_cmdstruct_t CommandElemt;

	tp_washchange(TRUE);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[wash4_aspirate]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[wash4_aspirate]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);


	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dA0I%dP%dR",SYSPEED,PROBEPORT,SYSTEP_LIQUID*15);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[wash4_aspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[wash4_aspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
	usleep(ASPIRATE_T);
	
	CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 4号清洗槽
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[wash4_aspirate]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[wash4_aspirate]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dD%dR", SYSPEED,PROBEPORT,SYSTEP_LIQUID*15);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[wash4_aspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[wash4_aspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

			tp_washchange(FALSE);

}
#endif
#if 0
int soak_work(char reagent_num, char percent)
{
	sr_cmdstruct_t CommandElemt;
	int i =0;
	
	
	mb_shelfaspirate(reagent_num,1,1300,-1);
	
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
	usleep(ASPIRATE_T);
	
	percent += 2;
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
    
	mb_monitdoorstate(); 
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH4][0], ordArray_wash[WASH4][1], ZWASH_STEP4);// 4号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dD%dM%dR", SYSPEED,PROBEPORT,SYSTEP_LIQUID*13 - SYSTEP_LIQUID*135/100,800);	//打掉剩余液体再拉1下打掉
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	
		
	for(i = 0;i<3;i++)
		{
	percent += 20;
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dD%dM%dP%dR", SYSPEED,PROBEPORT,SYSTEP_LIQUID*135/100,800,SYSTEP_LIQUID*135/100);	//打掉剩余液体再拉1下打掉
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	

		sleep(600);
		}

	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
	if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	reagent_flag = reagent_num;
	
}
#endif
#if 0
int mb_probectrl(void)
{
	char percent = 0;
	sr_cmdstruct_t CommandElemt;
	
	wash4_aspirate();
	soak_work(reagent_clr[0],10);
//	soak_work(1,40);
//	soak_work(2,80);
//	soak_work(reagent_clr[0],10);
	//soak_work(reagent_clr[1],40);
//	soak_work(reagent_clr[2],80);
	wash4_aspirate();
	tp_washchange(TRUE);

	mb_probewash_a(WATERPORT);
	tp_washchange(FALSE);

	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
	if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
		
	percent = 100;
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	printf("mb_probectrl\n\n");
	
}
#endif
#if 1
int mb_probectrl(void)
{
	char percent;
	unsigned int dwPinState;
	int reagent_index = reagent_clr[0] / 9;
	reagent_check[reagent_index].NEED_CHECK  = TRUE;
/*	
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[0],10);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[0],25);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[1],40);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[1],60);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[2],80);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	soak_work(reagent_clr[2],90);
	AspirateWash4();
	mb_procwashprobe(REAGENT_WATER);
	percent = 100;
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	printf("mb_probectrl\n\n");
*/
#ifdef BIG_VERSION 
	
	
		GetMixStationVal(4,reagent_index);
		if(reagent_check[reagent_index].STATE == 0)//已经拿掉
		{
			reagent_check[reagent_index].NEED_CHECK  = FALSE;
					if (pthread_mutex_unlock(&tp_threadmarm) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
			return;
	
		}
		GetMixStationVal(5,reagent_index);//锁定
	
	
	
	
#else
	
		dwPinState = reagent_check[reagent_index].sen;
		GPIO_PinState(&dwPinState);
		if ((dwPinState & reagent_check[reagent_index].sen) == 1)//已经拿掉
		{
			if (SHELF_LOCK_WAY_NEW)
		 GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描
		else
		GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描
		
			reagent_check[reagent_index].NEED_CHECK  = FALSE;
			if (pthread_mutex_unlock(&tp_threadmarm) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
			return;
		}
#endif
	if (SHELF_LOCK_WAY_NEW)
		GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描
	else
		GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描

	ewkevent = FREE_WORK;

mb_procwashprobe(REAGENT_WATER);
wash4_aspirate();
	tp_washchange(TRUE);
	mb_probewash_c(WATERPORT);
	tp_washchange(FALSE);
	soak_work(reagent_clr[0],10);
	wash4_aspirate();

	tp_washchange(TRUE);
		mb_probewash_c(WATERPORT);
		tp_washchange(FALSE);
	soak_work(reagent_clr[1],40);
	wash4_aspirate();

	tp_washchange(TRUE);
		mb_probewash_c(WATERPORT);
		tp_washchange(FALSE);
	soak_work(reagent_clr[2],70);
	wash4_aspirate();
	tp_washchange(TRUE);
		mb_probewash_c(WATERPORT);
		tp_washchange(FALSE);
	percent = 100;
	nt_sendpacketdata(WORK_PECENT_PROBR_CLR, &percent, 1);
	if (SHELF_LOCK_WAY_NEW)
		GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描
else
		GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描


//	sleep(1);
	if (pthread_mutex_unlock(&tp_threadmarm) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
	
	reagent_check[reagent_index].NEED_CHECK  = FALSE;

	#ifdef BIG_VERSION
	GetMixStationVal(6,reagent_index);//解锁
#endif
	printf("mb_probectrl\n\n");
	

return 0;
}
#endif
int mb_clearmixstation(unsigned int Mixing_Sation[])
{
	sr_cmdstruct_t CommandElemt;
	unsigned char need_clr_num = 0, i = 0;
	char TCP_Buffer[24] ={0};
	int res = 0;
	
	BOOL DischargeLock_NEED_UNLOCK = FALSE;//确保只进行一次解锁
	mb_procwashprobe(REAGENT_WATER);

	if (!flg_lockdischargliquit)
		{
			pthread_mutex_lock(&mutex_dischargelock);
			flg_lockdischargliquit = TRUE;
			DischargeLock_NEED_UNLOCK = TRUE;
		}
	

	tp_washchange(TRUE);
	mb_probewash_c(WATERPORT); 
	
	pthread_mutex_lock(&pump_lock);//防止排液
	if (IsWashProbeStart == FALSE)//防止dowork_WashProbe 线程也锁上但是优先级这里高
	{
		if(pthread_mutex_unlock(&pump_lock) != 0)//防止排液
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
		sleep(1);
		pthread_mutex_lock(&pump_lock);
	}
	lprintf(log_my, INFO,"mb_clearmixstation\n");
		if (mb_dabaspirateclear(0XFF, TRUE, Mixing_Sation) < 0)
		{
			if (DischargeLock_NEED_UNLOCK)
			{
				if (pthread_mutex_unlock(&mutex_dischargelock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_dischargelock");
				flg_lockdischargliquit = FALSE;
			}
			
			if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
			tp_washchange(FALSE);
			return -1;
		}
		
		last_cabin_reagent = reagent_flag = REAGENT_WATER;
	//	sleep(1);
		
	//	mb_dabprobleclear();
		
		mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], DAB_ZMAX);//混合站目标位置
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dP%dO%dD%dI%dP%dO%dD%dR", SYSPEED,WATERPORT,SYFSTEP,PROBEPORT,SYFSTEP,
																		WATERPORT,SYHSTEP,PROBEPORT,SYHSTEP);	//注射器拉一下打光拉一半打光
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);	
usleep(DISPENSE_T);
	

	mb_dabprobleclear();
	
	
	mb_dabaspirateclear(2, FALSE, Mixing_Sation);
//	mb_dabaspirateclear(1, TRUE, Mixing_Sation);
	res = mb_dabaspirateclear(0XFF, TRUE, Mixing_Sation);

	if (DischargeLock_NEED_UNLOCK)
			{
				if (pthread_mutex_unlock(&mutex_dischargelock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_dischargelock");
				flg_lockdischargliquit = FALSE;
			}
			
			if (pthread_mutex_unlock(&pump_lock) != 0)//防止排液
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error pump_lock");
			tp_washchange(FALSE);

	if (res < 0)
	{	
		return -1;	
	}


	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//混合站目标位置
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
		
	for (i = 0; i < 6;i++)
	{
		if(Mixing_Sation[0] == ordArray_mixed_DAB[i][0])
			mixstation_clear_state[i].NEEDCLEAR = FALSE;
		
		if (mixstation_clear_state[i].NEEDCLEAR == TRUE)
			need_clr_num++;
	}


	if (need_clr_num == 0)
	{
		//全部清洗干净发送信息给PC
		TCP_Buffer[0] = 0;
//		nt_sendpacketdata(MIXSTATION_NEED_CLEAR, TCP_Buffer, 1);
	}
	return 0;
}

int  ReagentReArrange()//(char* reagent_table,)
{

}
#if 0
void mb_mixdilutedab(mix_t mix,char mix_len)
{
	int i = 0, j = 0, mix_cnt = 0,AS_num = 0;
	mix_t t;

	//排序
	for(i = 0; i < mix_len - 1; i++)
	{
		for(j = 0;j <mix_len - i - 1; ++j)
		{
			if (mix.ordArray[j] > mix.ordArray[j + 1])
			{
				t = mix.ordArray[j];
				mix.ordArray[j] = mix.ordArray[j+1];
				mix.ordArray[j + 1] = t;
			}
		}
	}

/************************************************************************吸取稀释液******************************************************/
mix_cnt = 0;
while(mix_cnt < mix_len)
{
	AS_num = 1;
	while( (mix.ordArray[mix_cnt] ==  mix.ordArray[mix_cnt + 1]) && mix_cnt < mix_len)
	{
		mix_cnt++;
		AS_num++;

	}
	printf("AS_num = %d, mix_cnt=%d val=%d\n",AS_num,mix_cnt,mix.ordArray[mix_cnt]);

	mix_cnt++;
}


/************************************************************************************************************************************/


//吸取浓缩液

//混合


}

#endif

int DetectReagent(char shelf_num,unsigned char* reagent_array, int liquid_stp, int aspirate_val)
{
	sr_cmdstruct_t CommandElemt;
	int res_zx = 0;
	 int CompatibleReagent=0;
	int liquid_zmaxstep=0;
	if (reagent_code[*reagent_array].special_num == 1 )//开放试剂 配置文件中读取 开放试剂瓶的截面积计算
	{
		liquid_zmaxstep = OPEN_ARMZMAX;
	}
	else if(reagent_code[*reagent_array].special_num == 3 || reagent_code[*reagent_array].special_num == 6 ||
		reagent_code[*reagent_array].special_num == FREE_REAGENT2 ||
				reagent_code[*reagent_array].special_num == AP1)//DAB浓缩液和清洗系统,7ml开放试剂
	{
		liquid_zmaxstep = OPEN_ARMZMAX;
	}
	else 
	{ 
		liquid_zmaxstep = LIQUID_ZMAX;
	}
	
	CommandElemt.srdevaddr = ARM_ADDR;
			mb_monitdoorstate(); 	
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_reagent[*reagent_array][0], ordArray_reagent[*reagent_array][1], MOV_ZH);//H2O2
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	mb_monitdoorstate();
			flg_getedserailarr = TRUE;	
			ReportArrayData[0] = 0;
			if(reagent_code[*reagent_array].special_num == 3 || reagent_code[*reagent_array].special_num == 6 ||
		reagent_code[*reagent_array].special_num == FREE_REAGENT2 ||
				reagent_code[*reagent_array].special_num == 5)	
				sprintf(CommandElemt.cmdbuf, "ZX %d %d %d",liquid_stp , LIQUID_DISTANCE_ZMAX, OPEN_ARMZMAX);//测液体
			else
				sprintf(CommandElemt.cmdbuf, "ZX %d %d %d",liquid_stp , LIQUID_DISTANCE_ZMAX, LIQUID_ZMAX);//测液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		res_zx = sb_waitingframeaswer(&CommandElemt);

		if (res_zx == -3)
			return -3;
		else if (res_zx == -9 || res_zx == -11)
		{
			flg_getedserailarr = TRUE;
			sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", liquid_stp, LIQUID_DISTANCE_ZMAX, liquid_zmaxstep);//测液体
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			if (sb_waitingframeaswer(&CommandElemt) < 0)
			{
				
				ReportArrayData[0] = 0XFFFFFFFF;//没测到		
			}
			if((serail_dataarr+liquid_stp)  > liquid_zmaxstep)//机械臂测量不足没有报警
					{
						ReportArrayData[0] = 0XFFFFFFFF;//没测到		
					}
		}
		else if (serail_dataarr < (500 - OFFSET_STEP+SHELF_OFFSET))
		{
			ReportArrayData[0] = 1;//发送最大满瓶
			res_zx = -1;
		}

		
				if (ReportArrayData[0] == 0XFFFFFFFF || res_zx == -1)
				{
				sprintf(CommandElemt.cmdbuf, "ZA %d", liquid_zmaxstep);//测液体
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					 sb_waitingframeaswer(&CommandElemt);
				}
return res_zx;
}

int mb_islockedreagent(char reagent_num)
{
	if(reagent_lock[reagent_num][0] == 0 && reagent_lock[reagent_num][1] == 0 && reagent_lock[reagent_num][2] == 0)
		return 0;
	return -1;
}
/******************
mulnum 稀释比例
mulliquid 一片几步混合液

*****************/
mb_mixdilutedab(const char* mix__concentrate, const char* mix__diluent, int reagent_cnt,unsigned int liquid_val,const float mulnum,
			const char mulliquid,unsigned int* Mixing_Sation ,const char shelf_num)
{
	sr_cmdstruct_t CommandElemt;
	float liquid_step_H2O2 = 0,liquid_step_DAB = 0, AS_num=0,sysstep_H2O2=0,sysstep_DAB=0;
	float liquid_mulnum = 0;
	int i=0, mstp = 0, index=0,aspirate_val=0,mixliqstp = 0;
	unsigned char Array_diluent=0, Array_Reagent=0,ori_Array_diluent=0,ori_Array_Reagent=0,find_num=0;
	int res_zx=0,res=0,mix_cnt=0;
	char TCP_Buffer[24] ={0};
	unsigned char reagent_num, special_num1, special_num2,H2O2_cnt;
	static BOOL NEED_CLEAR_SENDED = FALSE;

	lprintf(log_my, INFO,"mix__concentrate");
		printf("mix__concentrate");
		for(i = 0; i < reagent_cnt;i++)
			{
			printf(" %d ",mix__concentrate[i]);
			lprintf(log_my, INFO," %d ",mix__concentrate[i]);
			}
		printf("mix__diluent");
		lprintf(log_my, INFO,"mix__diluent");
		for(i = 0; i < reagent_cnt;i++)
			{
			printf(" %d ",mix__diluent[i]);
			lprintf(log_my, INFO," %d ",mix__diluent[i]);
			}

		lprintf(log_my, INFO,"liquid_val = %d, reagent_cnt = %d mulnum=%f\n", liquid_val, reagent_cnt, mulnum);
		printf("liquid_val = %d, reagent_cnt = %d mulnum=%f\n", liquid_val, reagent_cnt, mulnum);
		for(i = 0; i < reagent_cnt;i++)
		{
			reagent_check[(mix__concentrate[i] / 9)].NEED_MIX = TRUE;
			reagent_check[(mix__diluent[i] / 9)].NEED_MIX = TRUE;
		}
		sleep(1);
		for(i = 0; i < reagent_cnt;i++)
			{
				
					
				if ((mix__concentrate[i] / 9) == 0 || (mix__diluent[i] / 9) == 0)
					{
					
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK1);
					else
						GPIO_OutClear(CGLOCK1);
					}
				
				 if ((mix__concentrate[i] / 9) == 1|| (mix__diluent[i] / 9) == 1)
					{
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK2);
					else
						GPIO_OutClear(CGLOCK2);
					}

				 if ((mix__concentrate[i] / 9) == 2 || (mix__diluent[i] / 9) == 2)
					{
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK3);
					else
						GPIO_OutClear(CGLOCK3);
					}

				 if ((mix__concentrate[i] / 9) == 3|| (mix__diluent[i] / 9) == 3)
					{
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK4);
					else
						GPIO_OutClear(CGLOCK4);
					}
			}
	
	

	if (liquid_val == 100 )
	{
		liquid_mulnum = 1;
		mstp = 13;
	}
	else if (liquid_val == 150)
	{
		liquid_mulnum = 1.5;
		mstp = 20;
	}
	else if (liquid_val == 200)
		liquid_mulnum = 2;
	else perror("mb_mixdilutedab liquid_val");

	liquid_step_H2O2   = LIQUID_STEP * mulnum / (mulnum + 1) ;

	
	
	
	if (reagent_code[mix__concentrate[0]].special_num == GREEN1||
		reagent_code[mix__concentrate[0]].special_num == FR1)
		liquid_step_DAB   =  LIQUID_STEP  / (mulnum + 1) ;
	else
		liquid_step_DAB   =  LIQUID_STEPDAB  / (mulnum + 1);//dab 为7ml小瓶子


	liquid_step_H2O2 = liquid_step_H2O2 * liquid_mulnum;
	liquid_step_DAB = liquid_step_DAB * liquid_mulnum;
	
	sysstep_H2O2 = SYSTEP_LIQUID* mulnum / (mulnum + 1) * MIX_SYSTEP_MOR * liquid_mulnum;	
	sysstep_DAB = SYSTEP_LIQUID / (mulnum + 1) * MIX_SYSTEP_MOR  * liquid_mulnum;//18

	for (i = 0; i < 6;i++)
	{	//发现当前混合瓶未清洗
		if (ordArray_mixed_DAB[i][0] == Mixing_Sation[0] &&  mixstation_clear_state[i].NEEDCLEAR)
		{
			if (mb_clearmixstation(&ordArray_mixed_DAB[i][0]) < 0)
				mb_seterrorcode(MIX_STATION_CLEARERROR);		
			mixstation_clear_state[i].NEEDCLEAR = FALSE;
		}
	}
	
	index = 0;
	while(index < reagent_cnt)// 浓缩液和稀释液数量一一对应，位置可以不同一架
	{	
		AS_num = 1;
		while((mix__diluent[index] ==mix__diluent[index + 1]) && ((index+1) < reagent_cnt))
		{
			AS_num++;
			index++;
		}
		printf("index = %d\n",index);
		ori_Array_diluent = Array_diluent = mix__diluent[index];

		AS_num *= mulliquid;
		
			printf("liquid_step_H2O2 = %f AS_num = %f Array_diluent=%d mulliquid=%d\n",
				liquid_step_H2O2, AS_num, Array_diluent, mulliquid);
			lprintf(log_my, INFO,"liquid_step_H2O2 = %f AS_num = %f Array_diluent=%d mulliquid=%d\n",
				liquid_step_H2O2, AS_num, Array_diluent, mulliquid);
			index++;//指向下个试剂

		//*********************************************吸取稀释液
		aspirate_val = (int)liquid_val * AS_num * mulnum /(1+ mulnum) / 2;
		
		printf("H2O2 aspirate_val=%d AS_num=%f mulnum=%f$$$$$$$\n",aspirate_val,AS_num,mulnum);
		lprintf(log_my, INFO,"H2O2 aspirate_val=%d AS_num=%f mulnum=%f$$$$$$$\n",aspirate_val,AS_num,mulnum);
#if 1		
		res_shelf = -1;// 探到底进行吸取 马上进行清洗
		mb_procwashprobe(REAGENT_WATER);
		res_shelf = 0;
	
	for (H2O2_cnt = 0; H2O2_cnt < 2; H2O2_cnt++)// 到两个瓶子吸取两次
	{
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR_LAG);	//缓慢抽吸空气
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		usleep(ASPIRATE_T); 
			res_zx = DetectReagent(shelf_num,&Array_diluent, (int)(liquid_step_H2O2 * AS_num/2)  + LIQUID_MSTEP,  aspirate_val);

			if (ReportArrayData[0] != 0XFFFFFFFF)
				ReportArrayData[0] = serail_dataarr - (liquid_step_H2O2 * AS_num/2 + LIQUID_MSTEP) +CorrectDate[Array_diluent % 9];
				if (res_zx == -3)
					return;
				else if (res_zx < 0)
				{
					mb_seterrorcode(MIXA_DILUENT_WRONG + shelf_num);
				}
				
				memcpy(&TCP_Buffer[5],&aspirate_val,4); 
				TCP_Buffer[9] = shelf_num;
					TCP_Buffer[0] = Array_diluent;
				#ifdef BIG_VERSION
				if(ReportArrayData[0] != 0XFFFFFFFF)
				ReportArrayData[0] =ReportArrayData[0] + OFFSET_STEP  - SHELF_OFFSET;
		#endif
					memcpy(&TCP_Buffer[1],&ReportArrayData[0],sizeof(ReportArrayData[0]));
				
					nt_sendpacketdata(REAGENT_SEND_INWORK, TCP_Buffer, sizeof(ReportArrayData[0]) + 1 + 4+1);
					
			CommandElemt.srdevaddr = PUMP_ADDR;
		printf("begin asp\n");
			sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,(int)(sysstep_H2O2 * AS_num/2) ); //缓慢抽吸液体
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("mb_dabmixer]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		usleep(ASPIRATE_T);
		mb_monitdoorstate(); 
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", (int)(liquid_step_H2O2 * AS_num/2)  + LIQUID_ZS_MOR+ LIQUID_MSTEP, LIQUID_SPEED);//缓慢上升
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
								CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	sleep(1);
				sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
					
			CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_AIR);	//缓慢抽吸空气
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		usleep(ASPIRATE_T);
		mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], DAB_ZMAX);//混合站目标位置
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	
			CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_DISPENSE,SYSTEP_AIR_LAG + (int)(sysstep_H2O2 * AS_num/2));//滴加试剂
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt); 
		usleep(DISPENSE_T);
			CommandElemt.srdevaddr = ARM_ADDR;
			
		CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);
					
				sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);

					if (reagent_code[ori_Array_diluent - 1].special_num == reagent_code[ori_Array_diluent].special_num)
						Array_diluent = ori_Array_diluent -1;
					else if(reagent_code[ori_Array_diluent + 1].special_num == reagent_code[ori_Array_diluent].special_num)
						Array_diluent = ori_Array_diluent + 1;
					else
						Array_diluent = ori_Array_diluent;
	}	
	reagent_flag = Array_diluent;
		for (i = 0; i < 6;i++)
		{
			if (*Mixing_Sation == ordArray_mixed_DAB[i][0])
			{
				mixstation_clear_state[i].NEEDCLEAR = TRUE;
		//		if (!NEED_CLEAR_SENDED)
				{
					TCP_Buffer[0] = 1;
			//		nt_sendpacketdata(MIXSTATION_NEED_CLEAR, TCP_Buffer, 1);
					NEED_CLEAR_SENDED = TRUE;
				}
	
			if (shelf_num == 0 && !flg_opwork1ready)//防止在混合时PC端放弃不进行混合站清洗 
				mixstation_clear_state[i].AFTER_DISPENSE = TRUE;
			else
				mixstation_clear_state[i].AFTER_DISPENSE = FALSE;
			
			if (shelf_num == 1 && !flg_opwork2ready)//防止在混合时PC端放弃不进行混合站清洗 
				mixstation_clear_state[i].AFTER_DISPENSE = TRUE;
			else
				mixstation_clear_state[i].AFTER_DISPENSE = FALSE;

			if (shelf_num == 2 && !flg_opwork3ready)//防止在混合时PC端放弃不进行混合站清洗 
				mixstation_clear_state[i].AFTER_DISPENSE = TRUE;
			else
				mixstation_clear_state[i].AFTER_DISPENSE = FALSE;
			
			}
			
		}

	#endif
	}
		//*********************************************吸取浓缩液
		
	
		mb_procwashprobe(REAGENT_WATER);
	index = 0;
	while(index < reagent_cnt)// 浓缩液和稀释液数量一一对应，位置可以不同一架
	{	
		AS_num = 1;
		while((mix__concentrate[index] ==mix__concentrate[index + 1]) && ((index+1) < reagent_cnt))
		{
			AS_num++;
			index++;
		}
		printf("index = %d\n",index);
		Array_Reagent = mix__concentrate[index];

		AS_num *= mulliquid;
		
			printf("liquid_step_DAB = %f AS_num = %f Array_Reagent=%d mulliquid=%d\n",
				liquid_step_DAB, AS_num, Array_Reagent, mulliquid);
			lprintf(log_my, INFO,"liquid_step_DAB = %f AS_num = %f Array_Reagent=%d mulliquid=%d\n",
				liquid_step_DAB, AS_num, Array_Reagent, mulliquid);

		index++;//指向下个试剂
		aspirate_val = (int)liquid_val * AS_num /(1+ mulnum);
#if 1

		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR_LAG);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
		
		res_zx = DetectReagent(shelf_num,&Array_Reagent, (int)(liquid_step_DAB * AS_num)  + LIQUID_MSTEP,  aspirate_val);		
		if (ReportArrayData[0] != 0XFFFFFFFF)	
			ReportArrayData[0] = serail_dataarr -((liquid_step_DAB * AS_num)  + LIQUID_MSTEP)  + CorrectDate[Array_Reagent % 9]; 
				if (res_zx == -3)
					return;
				else if (res_zx < 0)
					mb_seterrorcode(MIXA_DAB_WRONG + shelf_num);
	
		memcpy(&TCP_Buffer[5],&aspirate_val,4);
				printf("DAB aspirate_val=%d AS_num=%f mulnum=%df$$$$$$$\n",aspirate_val,AS_num,mulnum);
				lprintf(log_my, INFO,"DAB aspirate_val=%d AS_num=%f mulnum=%df$$$$$$$\n",aspirate_val,AS_num,mulnum);
				TCP_Buffer[0] = Array_Reagent;
				#ifdef BIG_VERSION
				if(ReportArrayData[0] != 0XFFFFFFFF)
					ReportArrayData[0] =ReportArrayData[0] + OFFSET_STEP  - SHELF_OFFSET;
		#endif
				memcpy(&TCP_Buffer[1],&ReportArrayData[0],sizeof(ReportArrayData[0]));
				TCP_Buffer[9] = shelf_num;
				
				nt_sendpacketdata(REAGENT_SEND_INWORK, TCP_Buffer, sizeof(ReportArrayData[0]) + 1 + 4+1);

		CommandElemt.srdevaddr = PUMP_ADDR;
		if (mulnum < 5)
			sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID ,(int)(sysstep_DAB * AS_num) ); //缓慢抽吸液体
		else
			sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID + 2,(int)(sysstep_DAB * AS_num) );	//缓慢抽吸液体
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T + 2000000);
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZS -%d %d",(int)(liquid_step_DAB * AS_num) + LIQUID_ZS_MOR+ LIQUID_MSTEP, LIQUID_SPEED);//缓慢上升
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
sleep(1);
			sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
				
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_AIR,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
	mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
		if(reagent_cnt >= 8)//8片
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], DAB_ZMAX - 400);//混合站目标位置
		else
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], DAB_ZMAX);//混合站目标位置
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", SYSPEED_LIQUID ,SYSTEP_AIR_LAG +	(int)(sysstep_DAB * AS_num));//滴加试剂
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt); 
	usleep(DISPENSE_T + 2000000);
		mb_monitdoorstate();
		CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);
					
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	#endif	
	}			

		
//	while(1) sleep(1);

//*********************************************混合
	if(reagent_cnt >= 9)
		mixliqstp =  SYSTEP_LIQUID * 6 * liquid_val/100;
	else
		mixliqstp = SYSTEP_LIQUID * 5 * liquid_val/100;//大于5片使用
#if 1

		//	mb_procwashprobe(REAGENT_WATER);
			//	mb_dab1wash();
			mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Mixing_Sation[0], Mixing_Sation[1], MOV_ZH);//混合站目标位置
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
				
			CommandElemt.srdevaddr = PUMP_ADDR;
		//	sprintf(CommandElemt.cmdbuf, "S%dP%dI%dP%dR", SYSPEED,SYSTEP_AIR + 240,WATERPORT,SYHSTEP);	//缓慢抽吸空气拉部分水
		
	//	sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED,PROBEPORT,SYSTEP_AIR + 240 + SYHHSTEP);	//缓慢抽吸空气
	if(reagent_cnt >= 5)
	sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED,PROBEPORT,SYSTEP_AIR + 240 );	//缓慢抽吸空气
		else
			sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED,PROBEPORT,SYSTEP_AIR + 240 );	//缓慢抽吸空气
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		usleep(ASPIRATE_T);
		mb_monitdoorstate(); 
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d",  DAB_ZMAX);//Z轴下降
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	
#if 0 //DE_TONG
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dO%dP%dM%dD%dM%dR", SYSPEED_MIXDAB, PROBEPORT,
					reagent_cnt * SYSTEP_LIQUID,500,reagent_cnt * SYSTEP_LIQUID,500); //抽吸6下
		//	sprintf(CommandElemt.cmdbuf, "S%dO%dP%dD%dP%dD%dP%dD%dR", SYSPEED_MIXDAB, PROBEPORT,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP); //抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	/*		sprintf(CommandElemt.cmdbuf, "S%dP%dD%dP%dD%dP%dD%dR", SYSPEED_MIXDAB,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		*/	usleep(DISPENSE_T);
			mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
				sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
						
#else

//	reagent_cnt = 10;//test

	if ( reagent_cnt <= 5)//最多吸5片量
		{
			CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dO%dgP%dM%dD%dM%dG6R", SYSPEED_MIXDAB, PROBEPORT,
					reagent_cnt * mulliquid  * SYSTEP_LIQUID/2,500,reagent_cnt * mulliquid * SYSTEP_LIQUID/2,500); //抽吸6下
		//	sprintf(CommandElemt.cmdbuf, "S%dO%dP%dD%dP%dD%dP%dD%dR", SYSPEED_MIXDAB, PROBEPORT,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP); //抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	/*		sprintf(CommandElemt.cmdbuf, "S%dP%dD%dP%dD%dP%dD%dR", SYSPEED_MIXDAB,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP,SYHHSTEP);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		*/	usleep(DISPENSE_T);
			mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
				sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
			}
	else
		{
		for(mix_cnt = 0; mix_cnt < 3;mix_cnt++)
			{
	
		if(mix_cnt == 0)
			{
			sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR",	SYSPEED_MIXDAB, PROBEPORT,mixliqstp);	//抽吸6下
			}
		else
			{
				CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d",  DAB_ZMAX);//Z轴下降
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
				
			sprintf(CommandElemt.cmdbuf, "S%dO%dD%dM%dP%dR",	SYSPEED_MIXDAB, PROBEPORT,mixliqstp,500,mixliqstp);	//抽吸6下
			}
		
		CommandElemt.srdevaddr = PUMP_ADDR;
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
				
		CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d",  mstp * reagent_cnt * mulliquid*3/4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dO%dD%dM%dP%dR",
					SYSPEED_MIXDAB, PROBEPORT,mixliqstp,500,mixliqstp);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
			}	

			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d",  DAB_ZMAX);//Z轴下降
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
				
		CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dO%dD%dM%dgP%dM%dD%dM%dG3P%dR",
					SYSPEED_MIXDAB, PROBEPORT,mixliqstp,500,mixliqstp,500,mixliqstp,1500,mixliqstp);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
	
			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d",  mstp * reagent_cnt * mulliquid/2, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
	//scanf("%d", &i);
			CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dD%dM%dO%dgP%dM%dD%dM%dG3P%dR", 
					SYSPEED_MIXDAB,mixliqstp, 1000,PROBEPORT,mixliqstp,500,mixliqstp,500,mixliqstp);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
			CommandElemt.srdevaddr = ARM_ADDR;
				sprintf(CommandElemt.cmdbuf, "ZS -%d %d", mstp * reagent_cnt*mulliquid / 4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt); 
	//scanf("%d", &i);
			CommandElemt.srdevaddr = PUMP_ADDR;
			sprintf(CommandElemt.cmdbuf, "S%dD%dM%dO%dgP%dM%dD%dM%dG3R", SYSPEED_MIXDAB,mixliqstp,1000, PROBEPORT,SYSTEP_LIQUID*2,500,SYSTEP_LIQUID*2,1500);	//抽吸6下
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr ); 
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
				
			usleep(DISPENSE_T);
			mb_monitdoorstate();
			CommandElemt.srdevaddr = ARM_ADDR;
				sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
			//	sprintf(CommandElemt.cmdbuf, "ZS -%d %d", ZWASH_STEP4, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[mb_probewash_a]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[mb_probewash_a]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
		}
#endif
			usleep(DISPENSE_T); 		
			sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH );//Z轴上升
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);
		
		

#endif
reagent_flag = Array_Reagent;

	reagent_check[Array_diluent / 9].NEED_MIX = FALSE;
	reagent_check[Array_Reagent / 9].NEED_MIX = FALSE;
	
printf("mb_islockedreagent(0)=%d TRY_REAGENT_UNLOCK1=%d\n",mb_islockedreagent(0),TRY_REAGENT_UNLOCK1);
	for(i = 0; i < reagent_cnt;i++)
	{
		if ((mb_islockedreagent(0) == 0) && ((mix__concentrate[i] / 9) == 0 || (mix__diluent[i] / 9) == 0))
			if (SHELF_LOCK_WAY_NEW)
				 GPIO_OutClear(CGLOCK1);
			else
				GPIO_OutSet(CGLOCK1);
		else if ((mb_islockedreagent(1) == 0) && ((mix__concentrate[i] / 9) == 1|| (mix__diluent[i] / 9) == 1))
			if (SHELF_LOCK_WAY_NEW)
				GPIO_OutClear(CGLOCK2);
			else
				GPIO_OutSet(CGLOCK2);
		else if ((mb_islockedreagent(2) == 0) && ( (mix__concentrate[i] / 9) == 2|| (mix__diluent[i] / 9) == 2))
			if (SHELF_LOCK_WAY_NEW)
				 GPIO_OutClear(CGLOCK3);
			else
				GPIO_OutSet(CGLOCK3);
		else if ((mb_islockedreagent(3) == 0) && ((mix__concentrate[i] / 9) == 3|| (mix__diluent[i] / 9) == 3))
			if (SHELF_LOCK_WAY_NEW)
				GPIO_OutClear(CGLOCK4);
			else
				 GPIO_OutSet(CGLOCK4);
	}

	


	res_shelf = -1;
		mb_procwashprobe(Array_diluent);
	res_shelf = 0;

//	while(1) sleep(1);
}	


/**********
Dilute_num 为0 DAB, 1 RED


*****/

int mb_searchcomatiblereagentval(char plate_num,unsigned char *ordArray_reagent,reagent_t *reagent,int reagent_val)
{

	int cmp_res=0;
	char TCP_Buffer[50] = {0};
	cmp_res = mb_searchcomatiblereagent(reagent,reagent_val);
				if (cmp_res < 0 )
					TCP_Buffer[23] = 2;	
					else
						{
						printf("cmp_res=%d\n",cmp_res);
							//减去对应的试剂量
							reagent_code[cmp_res].val -= reagent_val;
							memcpy(&TCP_Buffer[10],reagent_code[cmp_res].code,9);
							*ordArray_reagent = cmp_res;
							if (cmp_res & 0X80 > 0)//不同批号
								TCP_Buffer[23] = 1; 	
							cmp_res  &= 0X7F;
						}
					TCP_Buffer[0]=plate_num;
							memcpy(&TCP_Buffer[1],reagent->code,9);
							memcpy(&TCP_Buffer[19],&reagent_val,4);
								nt_sendpacketdata(REPLACE_REAGENT, TCP_Buffer, 24);
						
	return cmp_res;
}

/****************
1.混合操作为当仪器处在一段空闲时间时去操作
2离滴加混合时间不足10分钟时无空闲时也去?  僮?
3.当需要滴加关键步骤时暂停混合，等没有关键步骤时继续
step 为混合步骤全局量的地址
***************/
int mb_dabmixer(const operate_head_list* operate_head)
{
	unsigned int* Array_mixed_DAB;
	unsigned int* Array_mixed_SECOND;
	unsigned char liquid_num = 0, same_num=0,mulDAB_num = 0,mulRED_num = 0,find_num = 0;
	unsigned int liquid_val = 0, cpm_val=0;
	operate_head_list* operate_head_p = operate_head;
	operate_t *operate_p = NULL;
	int res = 0;
//	BOOL RED_NEEDED = FALSE;
//	unsigned char ordArray_H2O2 = 0XFF ,ordArray_H2O2_RED = 0XFF,ordArray_DAB = 0XFF, ordArray_RED = 0XFF;
	char TCP_Buffer[50] = {0};
	char *which_mix_kind = 0;
	BOOL *isDAB_mixed = NULL;
	BOOL *isDAB_mixed_next = NULL;
	BOOL need_lock[4] = {0};
	char mix_DAB_concentrate[10]={0},mix_DAB_diluent[10]={0};
	char mix_SECOND_concentrate[10]={0},mix_SECOND_diluent[10]={0};
	int i = 0, j = 0,DAB_cnt = 0, SECOND_cnt = 0, mulnum=0,cmp_res=0,shelf_num;
	BOOL*  isoperate_workingp=NULL;
	BOOL HAVE_DAB = FALSE, HAVE_SECD = FALSE;
	unsigned char* mix_stp = NULL;		 
		
#if 1
		if (operate_head == NULL)
		return -1;

#if 1	

	if (operate_head == operate_head1)
	{
		which_mix_kind = which_mix_kindA;
		isDAB_mixed = &isDAB_mixedA;
		isDAB_mixed_next = &isDAB_mixedA_next;
		liquid_val = liquid_valA;
		mix_stp = &workstep_mix_a;
		shelf_num = 0;
		isoperate_workingp = &flg_opwork1ready;
	}

	if (operate_head == operate_head2)
	{
		which_mix_kind = which_mix_kindB;
			isDAB_mixed = &isDAB_mixedB;
		isDAB_mixed_next = &isDAB_mixedB_next;
		liquid_val = liquid_valB;
		mix_stp = &workstep_mix_b;
		shelf_num = 1;
		isoperate_workingp = &flg_opwork2ready;
	}
	
	if (operate_head == operate_head3)
	{
		which_mix_kind = which_mix_kindC;
			isDAB_mixed = &isDAB_mixedC;
		isDAB_mixed_next = &isDAB_mixedC_next;
		liquid_val = liquid_valC;
		mix_stp = &workstep_mix_c;
		shelf_num = 2;
		isoperate_workingp = &flg_opwork3ready;
	}
	char tst;

	printf("in  mb_dabmixer\n");
	for(i = 0; i < 10; i++)
	{
		printf(" %d ", mix_DAB[shelf_num].ordArrayA[i]);	
		printf("reagentA code=%s kind=%s \n", mix_DAB[shelf_num].reagentA[i].code, mix_DAB[shelf_num].reagentA[i].reagent_kind);
		printf(" %d ", mix_DAB[shelf_num].ordArrayB[i]);
		printf("reagentB code=%s kind=%s \n", mix_DAB[shelf_num].reagentB[i].code, mix_DAB[shelf_num].reagentB[i].reagent_kind);	
	}

	for (i = 0; i < 10;i++)
	{
		printf("i=%d\n",i);
		if(mix_DAB[shelf_num].ordArrayA[i] != 0 &&  *isDAB_mixed == FALSE)
		{
			HAVE_DAB = TRUE;
			if ((mix_DAB[shelf_num].ordArrayA[i] & 0X80) > 0)
			{
				if ((cmp_res = mb_searchcomatiblereagentval(shelf_num*10+i,&mix_DAB[shelf_num].ordArrayA[i],&mix_DAB[shelf_num].reagentA[i],liquid_val  /(mulnum+1))) < 0 )
					continue;
			}
			mix_DAB_concentrate[DAB_cnt] = mix_DAB[shelf_num].ordArrayA[i];
		}
		
		if(mix_DAB[shelf_num].ordArrayB[i] != 0 &&  *isDAB_mixed == FALSE)
		{
			if ((mix_DAB[shelf_num].ordArrayB[i] & 0X80) > 0)
			{
				if ((cmp_res = mb_searchcomatiblereagentval(shelf_num*10+i,&mix_DAB[shelf_num].ordArrayB[i],&mix_DAB[shelf_num].reagentB[i],liquid_val* mulnum /(mulnum+1))) < 0 )
					continue;
			}

			mix_DAB_diluent[DAB_cnt] = mix_DAB[shelf_num].ordArrayB[i];

			DAB_cnt++;
		}

		if(mix_SECEND[shelf_num].ordArrayA[i] != 0)
		{
			HAVE_SECD = TRUE;
			if ((mix_SECEND[shelf_num].ordArrayA[i] & 0X80) > 0)
			{
				if ((cmp_res = mb_searchcomatiblereagentval(shelf_num*10+i,&mix_SECEND[shelf_num].ordArrayA[i],&mix_SECEND[shelf_num].reagentA[i],liquid_val  /(mulnum+1))) < 0 )
					continue;
			}
			mix_SECOND_concentrate[SECOND_cnt] = mix_SECEND[shelf_num].ordArrayA[i];
		}
		
		if(mix_SECEND[shelf_num].ordArrayB[i] != 0)
		{
			if ((mix_SECEND[shelf_num].ordArrayB[i] & 0X80) > 0)
			{
				if ((cmp_res = mb_searchcomatiblereagentval(shelf_num*10+i,&mix_SECEND[shelf_num].ordArrayB[i],&mix_SECEND[shelf_num].reagentB[i],liquid_val* mulnum /(mulnum+1))) < 0 )
					continue;
			}
			mix_SECOND_diluent[SECOND_cnt] = mix_SECEND[shelf_num].ordArrayB[i];

			SECOND_cnt++;
		}
	}

	if (DAB_cnt == 0 && SECOND_cnt == 0) //流程中没有需混合的试剂
	{
		if (HAVE_DAB || HAVE_SECD)
		{
			if (shelf_num == 0)
				mb_seterrorcode(SHELF1_ABANDON);
			else if (shelf_num == 1)
				mb_seterrorcode(SHELF2_ABANDON);
			else if (shelf_num == 2)
				mb_seterrorcode(SHELF3_ABANDON);
			return -3;
		}
	}

	//*///////////////////////////////////
	printf("yyyyyyyyyy\n\n");
				
		if ((operate_head->operate.plate_num % 30) < 10)
		{	
			liquid_val = liquid_valA;
			if (DAB1Array_exchange  == FALSE)
			{
				Array_mixed_DAB1[0] = ordArray_mixed_DAB[0][0];
				Array_mixed_DAB1[1] = ordArray_mixed_DAB[0][1];
				Array_mixed_RED1[0] = ordArray_mixed_DAB[1][0];
				Array_mixed_RED1[1] = ordArray_mixed_DAB[1][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB;
				Array_mixed_SECOND = (unsigned int *)ordArray_mixed_DAB + 2;
			}
			else
			{
				Array_mixed_DAB1[0] = ordArray_mixed_DAB[1][0];
				Array_mixed_DAB1[1] = ordArray_mixed_DAB[1][1];
				Array_mixed_RED1[0] = ordArray_mixed_DAB[0][0];
				Array_mixed_RED1[1] = ordArray_mixed_DAB[0][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB + 2;
				Array_mixed_SECOND = ordArray_mixed_DAB;
				
			}
		}
		else if ((operate_head->operate.plate_num % 30) < 20)
		{
			liquid_val = liquid_valB;
			if (DAB2Array_exchange  == FALSE)
			{
				Array_mixed_DAB2[0] = ordArray_mixed_DAB[2][0];
				Array_mixed_DAB2[1] = ordArray_mixed_DAB[2][1];
				Array_mixed_RED2[0] = ordArray_mixed_DAB[3][0];
				Array_mixed_RED2[1] = ordArray_mixed_DAB[3][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB + 4;
				Array_mixed_SECOND = (unsigned int *)ordArray_mixed_DAB + 6;
				
			}
			else
			{
				Array_mixed_DAB2[0] = ordArray_mixed_DAB[3][0];
				Array_mixed_DAB2[1] = ordArray_mixed_DAB[3][1];
				Array_mixed_RED2[0] = ordArray_mixed_DAB[2][0];
				Array_mixed_RED2[1] = ordArray_mixed_DAB[2][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB + 6;
				Array_mixed_SECOND = (unsigned int *)ordArray_mixed_DAB + 4;
			}
		}
		else
		{
			liquid_val = liquid_valC;
			if (DAB3Array_exchange  == FALSE)
			{
				Array_mixed_DAB3[0] = ordArray_mixed_DAB[4][0];
				Array_mixed_DAB3[1] = ordArray_mixed_DAB[4][1];
				Array_mixed_RED3[0] = ordArray_mixed_DAB[5][0];
				Array_mixed_RED3[1] = ordArray_mixed_DAB[5][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB + 8;
				Array_mixed_SECOND = (unsigned int *)ordArray_mixed_DAB + 10;
			}
			else
			{
				Array_mixed_DAB3[0] = ordArray_mixed_DAB[5][0];
				Array_mixed_DAB3[1] = ordArray_mixed_DAB[5][1];
				Array_mixed_RED3[0] = ordArray_mixed_DAB[4][0];
				Array_mixed_RED3[1] = ordArray_mixed_DAB[4][1];
				Array_mixed_DAB = (unsigned int *)ordArray_mixed_DAB + 10;
				Array_mixed_SECOND = (unsigned int *)ordArray_mixed_DAB + 8;
			}
		}
	#endif
		printf("xxxxxxxxxxx\n\n");

		pthread_mutex_lock(&tp_threadmarm);		
		if (which_mix_kind == 1)		
			mb_mixdilutedab( mix_DAB_concentrate, mix_DAB_diluent, DAB_cnt, liquid_val, mulnum_glb[shelf_num],mix_DAB[shelf_num].tep_num / DAB_cnt,  Array_mixed_DAB, shelf_num);
		else	
			mb_mixdilutedab( mix_SECOND_concentrate, mix_SECOND_diluent, SECOND_cnt, liquid_val, mulnum_glb2[shelf_num],mix_SECEND[shelf_num].tep_num / SECOND_cnt, Array_mixed_SECOND, shelf_num);
				
		pthread_mutex_unlock(&tp_threadmarm);

		last_cabin_reagent = REAGENT_WATER;//

		if (operate_head == operate_head1)
			startmixworkid &= 0X7F;

		if (operate_head == operate_head2)
			startmixworkid &= 0XBF;
		
		if (operate_head == operate_head3)
			startmixworkid &= 0XDF;
		if (*isoperate_workingp)
		{
			if (which_mix_kind == 1)
				*isDAB_mixed = TRUE;
			else	
				*isDAB_mixed_next = TRUE;
		}
		
		//	tp_washchange(FALSE);
		if (pthread_mutex_unlock(&tp_threadmarm) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");

#endif
	return 0;
}

BOOL mb_isspecialreagent(unsigned char reagent_num)
{
printf("[mb_isspecialreagent]reagent_num = %d\n", reagent_num);

	if (reagent_code[reagent_num].special_num == 1 || reagent_code[reagent_num].special_num == 9
		|| reagent_code[reagent_num].special_num == 10)
		return TRUE;	
	
	return FALSE;	
}
int mb_procwashprobe(unsigned char reagent_num)
{
	unsigned char liquid_port = 0,last_cabin_port = 0;
	BOOL DischargeLock_NEED_UNLOCK = FALSE;//确保只进行一次解锁
//return;
	if (ewkevent == INIT_WORK)//初始化时灌注不进行清洗
		return 0;
	
	if (reagent_num == REAGENT_WATER)
		liquid_port = WATERPORT;
	else if (reagent_num == REAGENT_WASH)
		liquid_port = WASHPORT;
	else if (reagent_num == REAGENT_ER1)
		liquid_port = ER1PORT;
	else if (reagent_num == REAGENT_ER2)
		liquid_port = ER2PORT;	
	else if (reagent_num == REAGENT_DEWAX)
		liquid_port = DEWAXPORT;	
	else if (reagent_num == REAGENT_ALCOHOL)
		liquid_port = ALCOHOLPORT;
	else
	{
		//试剂架上试剂 或DDAB
	}
		if (last_cabin_reagent == REAGENT_WATER)
			last_cabin_port = WATERPORT;
		else if (last_cabin_reagent == REAGENT_WASH)
			last_cabin_port = WASHPORT;
		else if (last_cabin_reagent == REAGENT_ER1)
			last_cabin_port = ER1PORT;
		else if (last_cabin_reagent == REAGENT_ER2)
			last_cabin_port = ER2PORT;	
		else if (last_cabin_reagent == REAGENT_DEWAX)
			last_cabin_port = DEWAXPORT;	
		else if (last_cabin_reagent == REAGENT_ALCOHOL)
			last_cabin_port = ALCOHOLPORT;
			
	 //大容量且与上次使用相同不清晰
	if ((reagent_num == reagent_flag) && (reagent_num >= REAGENT_CASE) && (reagent_num <= REAGENT_ER2))
	{
	/*	pthread_mutex_lock(&mutex_dischargelock);
		tp_washchange(TRUE);
		mb_probewash_c(liquid_port);
		tp_washchange(FALSE);
		pthread_mutex_unlock(&mutex_dischargelock);
	*/		
		printf("same reagent\n");
		return 0;
	}
	if (!flg_lockdischargliquit)
	{
		pthread_mutex_lock(&mutex_dischargelock);
		flg_lockdischargliquit = TRUE;
		DischargeLock_NEED_UNLOCK = TRUE;
	}

	if (res_shelf < 0)
	{
		tp_washchange(TRUE);
		mb_probewash_a(last_cabin_port);
		tp_washchange(FALSE);
		goto WashEnd;
	}
	
//		tp_washchange(TRUE);
#if 0
	mb_probewash_c(WASHPORT);	//大仪器只用到缓冲液来清洗针，不滴加大容量试剂
	tp_washchange(FALSE);
	return;
#endif

	printf("[mb_procwashprobe]reagent_num=%d reagent_flag=%d last_cabin_reagent=%d\n",
	reagent_num,reagent_flag,last_cabin_reagent);
	
	if ((reagent_num >= REAGENT_CASE) && (reagent_num < REAGENT_DAB))	//大于REAGENT_CASE为大容量试剂小于为架试剂试剂  REAGENT_CASE值在小仪器不同
	{	
		printf("大容量试剂清洗灌注\n");	
			
		tp_washchange(TRUE);
		switch (last_cabin_reagent)	//前次使用的试剂
		{
			case REAGENT_WATER:
				if (liquid_port == DEWAXPORT)
					mb_probewash_b(ALCOHOLPORT);	
				break;
			case REAGENT_WASH:
				if (liquid_port == DEWAXPORT)
					mb_probewash_b(ALCOHOLPORT);	
				break;	
			case REAGENT_ALCOHOL:
				if ((liquid_port == ER1PORT) || (liquid_port == ER2PORT))
					mb_probewash_a(WATERPORT);	
				break;
			case REAGENT_ER1:
				if (liquid_port == ALCOHOLPORT)
					mb_probewash_a(WATERPORT);	
				else if (liquid_port == DEWAXPORT)
				{
					mb_probewash_a(WATERPORT);	
					mb_probewash_b(ALCOHOLPORT);	
				}
				break;	
			case REAGENT_ER2:
			if (liquid_port == ALCOHOLPORT)
				mb_probewash_a(WATERPORT);	
			else if (liquid_port == DEWAXPORT)
			{
				mb_probewash_a(WATERPORT);	
				mb_probewash_b(ALCOHOLPORT);	
			}
			break;	
			case REAGENT_DEWAX:
				if ((liquid_port == WATERPORT) || (liquid_port == WASHPORT))
					mb_probewash_b(ALCOHOLPORT);	
				else if ((liquid_port == ER1PORT) || (liquid_port == ER2PORT))
				{
					mb_probewash_b(ALCOHOLPORT);	
					mb_probewash_a(WATERPORT);	
				}
				break;	
			default: 
				break;
		}
		
		if ((reagent_num >= REAGENT_CASE) && (reagent_num <= REAGENT_WASH) )//前一步骤是大容量试剂进行灌注清洗
		{
			if(last_cabin_reagent != reagent_num)//WATER WASH 切换
				mb_probewash_a(liquid_port);
			else
				mb_probewash_c(last_cabin_port);//同种
		}
		else if ((reagent_num > REAGENT_WASH) && (reagent_num <= REAGENT_ER2) )
		{
//			if (reagent_num == REAGENT_DEWAX)
				mb_probewash_b(liquid_port);	
				
		}
		else //前一步骤是试剂架试剂或者DAB
		{		//前一步骤是试剂架试剂或者DAB 则管路中的大容量必定是WATER 或 WASH 可直接对下次的大容量直接灌注
				if (last_cabin_reagent != reagent_num)//前次的大容量试剂不同进行灌注清洗
			{	
					if ((reagent_num >= REAGENT_CASE) && (reagent_num <= REAGENT_WASH) )//前一步骤是大容量试剂进行灌注清洗
						mb_probewash_a(liquid_port);
					else if ((reagent_num > REAGENT_WASH) && (reagent_num <= REAGENT_ER2) )
						mb_probewash_b(liquid_port);	
			}
			else	//
			{			
					mb_probewash_c(last_cabin_port);
			}
		}
		last_cabin_reagent = reagent_flag = reagent_num;
		tp_washchange(FALSE);
	}
	else if (mb_isspecialreagent(reagent_num))
	//	else if (1)
	{
		printf("抗体清洗\n");
		
		
		if (reagent_flag < REAGENT_WATER || reagent_flag >= REAGENT_DAB)//上次步骤为试剂架上试剂 或DAB
		{
			tp_washchange(TRUE);
			mb_probewash_d(last_cabin_port);
			tp_washchange(FALSE);
		}
		else if (reagent_flag != REAGENT_WATER && reagent_flag != REAGENT_WASH)//水和缓冲液不清洗
		{
			
			if (reagent_flag == REAGENT_DEWAX)	//
			{
				tp_washchange(TRUE);
				mb_probewash_b(ALCOHOLPORT);
				mb_probewash_a(WATERPORT);
				last_cabin_reagent = REAGENT_WATER;
				tp_washchange(FALSE);
			}
			else if (reagent_flag == REAGENT_ALCOHOL || reagent_flag == REAGENT_ER1 
				|| reagent_flag == REAGENT_ER2)
			{
				tp_washchange(TRUE);
				mb_probewash_a(WATERPORT);
				last_cabin_reagent = REAGENT_WATER;
				tp_washchange(FALSE);
			}
			
			
		}
		
	}
	else	//其他试剂架试剂或者DAB
	{
		printf("其他试剂架上试剂 或DAB\n");

		
		if ( (reagent_flag < REAGENT_WATER || reagent_flag >= REAGENT_DAB) && reagent_num != reagent_flag)//上次步骤为试剂架上试剂 或DAB
		{
//#if DE_TONG
			
//#else
			tp_washchange(TRUE);
			mb_probewash_c(last_cabin_port);
			tp_washchange(FALSE);
//#endif
		}
		else if (reagent_flag != REAGENT_WATER && reagent_flag != REAGENT_WASH)//水和缓冲液不清洗
		{
			
			if (reagent_flag == REAGENT_DEWAX)	//
			{
				tp_washchange(TRUE);
				mb_probewash_b(ALCOHOLPORT);
				mb_probewash_a(WATERPORT);
				last_cabin_reagent = REAGENT_WATER;
				tp_washchange(FALSE);
			}
			else if (reagent_flag == REAGENT_ALCOHOL || reagent_flag == REAGENT_ER1 
				|| reagent_flag == REAGENT_ER2)
			{
				tp_washchange(TRUE);
				mb_probewash_a(WATERPORT);
				last_cabin_reagent = REAGENT_WATER;
				tp_washchange(FALSE);
			}
			
			
		}

	}
//	tp_washchange(FALSE);
//	sleep(1);
	WashEnd:

	if (DischargeLock_NEED_UNLOCK)
	{
		if (pthread_mutex_unlock(&mutex_dischargelock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_dischargelock");
		flg_lockdischargliquit = FALSE;
	}
	printf("\n");
	return 0;
}
/******************************************************************************
*
* Function Name  : mb_shelfaspirate
* Description    : 吸取试剂架试剂
* 					 
* Input		   :const unsigned char reagent_num 试剂位置, const unsigned char same_num 吸取的玻片数
				, unsigned char liquid_val每片玻片滴加量
* Output		   :
* Return		   :  BOOL 错误FLASE 正确TRUE
*******************************************************************************/
int mb_shelfaspirate(const unsigned char reagent_num, const unsigned char same_num, 
						const unsigned int liquid_val,const char shelf_num)
{
	sr_cmdstruct_t CommandElemt;
	int res = 0;
	unsigned int liquid_step = 0, sysstep = 0,liquid_zmaxstep = 0,i=0;
	int res_zx = 0,aspirate_val = 0;
	char TCP_Buffer[50] = {0};
	memset(ReportArrayData,0,sizeof(ReportArrayData));
	
	printf("in mb_shelfaspirate\n");
	lprintf(log_my, INFO,"in mb_shelfaspirate\n");
	if (reagent_code[reagent_num].special_num == 1 || reagent_code[reagent_num].special_num == EBER6)//开放试剂 配置文件中读取 开放试剂瓶的截面积计算
	{
		
		if (liquid_val == 100)
		{
			liquid_step = open_armstep;
			sysstep = SYSTEP_LIQUID;
		}
		else if (liquid_val == 150)
		{
			liquid_step =  open_armstep * 3 / 2;
			sysstep = SYSTEP_LIQUID * 3 / 2;
		}
		else if (liquid_val == 200)
		{
			liquid_step =  open_armstep * 2;
			sysstep = SYSTEP_LIQUID *  2;
		}
		

		liquid_zmaxstep = OPEN_ARMZMAX;
	}
	else if(reagent_code[reagent_num].special_num == 3 || reagent_code[reagent_num].special_num == 6 ||
		reagent_code[reagent_num].special_num == FREE_REAGENT2 || reagent_code[reagent_num].special_num == EBER7 )//DAB浓缩液和清洗系统,7ml开放试剂
	{
		if (liquid_val == 100)
		{
			liquid_step = open_armstep2;
			sysstep = SYSTEP_LIQUID;
		}
		else if (liquid_val == 150)
		{
			liquid_step =  open_armstep2 * 3 / 2;
			sysstep = SYSTEP_LIQUID * 3 / 2;
		}
		else if (liquid_val == 200)
		{
			liquid_step =  open_armstep2 * 2;
			sysstep = SYSTEP_LIQUID *  2;
		}
		

		liquid_zmaxstep = OPEN_ARMZMAX;
	}
	else 
	{ 
		if (liquid_val == 100)
		{
			liquid_step = LIQUID_STEP;
		
			sysstep = SYSTEP_LIQUID;
		}
		else if (liquid_val == 150)
		{
			liquid_step = LIQUID_STEP * 3 / 2;
			
			sysstep = SYSTEP_LIQUID * 3 / 2;
		}
		else if (liquid_val == 200)
		{
			liquid_step = LIQUID_STEP * 2;
			
			sysstep = SYSTEP_LIQUID * 2;
		}
		
	
		liquid_zmaxstep = LIQUID_ZMAX;
	}

	if (liquid_val > 200)
	{
		liquid_step =  LIQUID_STEP * liquid_val / 100;
		sysstep = SYSTEP_LIQUID *  liquid_val / 100;
	}
	
	liquid_step = liquid_step * SYSTEP_MOR;
//	liquid_step = liquid_step + LIQUID_STEP * 8 / 100;
//	sysstep += 8;
	printf("liquid_val=%d liquid_step=%d sysstep=%d\n",liquid_val,liquid_step,sysstep);
lprintf(log_my, INFO,"liquid_val=%d liquid_step=%d sysstep=%d\n",liquid_val,liquid_step,sysstep);

//mb_monitdoorstate();
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR_LAG);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_reagent[reagent_num][0], ordArray_reagent[reagent_num][1], MOV_ZH);//到达试剂位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
mb_monitdoorstate();
		sprintf(CommandElemt.cmdbuf, "ZA %d", 350 - OFFSET_STEP+SHELF_OFFSET);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
usleep(300000);			
	flg_getedserailarr = TRUE;
		sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", liquid_step * same_num + LIQUID_MSTEP, LIQUID_DISTANCE_ZMAX, liquid_zmaxstep);//测液体
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		res_zx = sb_waitingframeaswer(&CommandElemt);

				if (res_zx == -3)
					res = -3;
				else if (res_zx == -9 || res_zx == -11)
				{
					flg_getedserailarr = TRUE;
				res_shelf = -1;
					sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", liquid_step * same_num + LIQUID_MSTEP, LIQUID_DISTANCE_ZMAX,1+ liquid_zmaxstep);//测液体
					if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[mb_dabmixer]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[mb_dabmixer]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					if (sb_waitingframeaswer(&CommandElemt) < 0)
					{
						res = res_zx;
						ReportArrayData[0] = 0XFFFFFFFF;//没测到		
					}
					if((serail_dataarr+liquid_step * same_num + LIQUID_MSTEP)  > liquid_zmaxstep)//机械臂测量不足没有报警
					{
						ReportArrayData[0] = 0XFFFFFFFF;//没测到		
					}
				}
				else
				{
						printf("Arraydata=%d\n",serail_dataarr);
						lprintf(log_my, INFO,"Arraydata=%d\n",serail_dataarr);
						if (serail_dataarr < (500 - OFFSET_STEP+SHELF_OFFSET))
						{
							ReportArrayData[0] = 1;//发送最大满瓶
							res = -9;
						}
						ReportArrayData[0] = serail_dataarr -(liquid_step * same_num + LIQUID_MSTEP) + CorrectDate[reagent_num % 9];
						printf("ReportArrayData[0]=%x ",ReportArrayData[0]);
				}

				if(res_zx == -9)
				{

				}	
				else if(res_zx == -11)
							{
							flg_getedserailarr = TRUE;
							sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", 0, LIQUID_DISTANCE_ZMAX, 1306);//测液体
									if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
										CommandElemt.srdevaddr , 1, 0, 1) > 0)
										printf("[mb_dabmixer]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
									else
										printf("[mb_dabmixer]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
									if (sb_waitingframeaswer(&CommandElemt) == -9)//已预留打底量测液体
										res = -9;
									else
									{
									lprintf(log_my, INFO,"aspirate_notenough Arraydata=%d\n",serail_dataarr);
									printf("aspirate_notenough Arraydata=%d\n",serail_dataarr);
										 aspirate_notenough[10] = (1306 -serail_dataarr - CorrectDate[reagent_num % 9]) / liquid_step ;
										if (aspirate_notenough[10] >= same_num)//按1306测量满足所需量时按只有一片不足进行报警
											aspirate_notenough[10] = same_num - 1;
									}
										
							
							}

	//	ReportArrayData[0] = serail_dataarr;

		TCP_Buffer[0] = reagent_num;
		aspirate_val = liquid_val * same_num;
		#ifdef BIG_VERSION
		if(ReportArrayData[0] != 0XFFFFFFFF)
			ReportArrayData[0] =ReportArrayData[0] + OFFSET_STEP  - SHELF_OFFSET;
		#endif
		memcpy(&TCP_Buffer[1],&ReportArrayData[0],sizeof(ReportArrayData[0]));
		memcpy(&TCP_Buffer[5],&aspirate_val,4);
		TCP_Buffer[9] = shelf_num;
		nt_sendpacketdata(REAGENT_SEND_INWORK, TCP_Buffer, sizeof(ReportArrayData[0]) + 1 + 4 + 1);
		reagent_code[reagent_num].val -= aspirate_val;
		report_reagentinfo[shelf_num] = reagent_num;
		
		if (ReportArrayData[0] == 0XFFFFFFFF || res == -9)
		{

			CommandElemt.srdevaddr = ARM_ADDR;
			sprintf(CommandElemt.cmdbuf, "ZA %d", liquid_zmaxstep);
			if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
					CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);

		}

		CommandElemt.srdevaddr = PUMP_ADDR;
		if(reagent_code[reagent_num].special_num == EBER6 || reagent_code[reagent_num].special_num == EBER7
		|| reagent_code[reagent_num].special_num == EBER30)
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUIDEBER,(sysstep *SYSTEP_MOR)  * same_num);	//缓慢抽吸液体
		else
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,(sysstep *SYSTEP_MOR)  * same_num);	//缓慢抽吸液体
		
//		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,(syss tep *SYSTEP_MOR) * same_num + SYSTEP_LIQUID_REMAIN);	//缓慢抽吸液体		
//	sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,(sysstep ) * same_num + SYSTEP_LIQUID_REMAIN);	//缓慢抽吸液体
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

	if(reagent_code[reagent_num].special_num == EBER6 || reagent_code[reagent_num].special_num == EBER7
		|| reagent_code[reagent_num].special_num == EBER30)
		usleep(ASPIRATE_T + 2000000);	//使注射器中液体平衡
	else
		usleep(ASPIRATE_T);	//使注射器中液体平衡
		
		CommandElemt.srdevaddr = ARM_ADDR;
		if (res >= 0)
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", liquid_step * same_num + LIQUID_ZS_MOR + LIQUID_MSTEP, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		else
			sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 500, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置

		
			if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

		return res;
		
}
/******************************************************************************
*
* Function Name  : mb_aspiratedab
* Description    : 吸取试剂混合站
* 					 
* Input		   :unsigned int* Array_DAB 混合站坐标, unsigned char num 吸取的玻片数
				, unsigned char liquid_val每片玻片滴加量
* Output		   :
* Return		   :  BOOL 错误FLASE 正确TRUE
*******************************************************************************/
BOOL mb_aspiratedab(unsigned int* Array_DAB ,unsigned char num,unsigned char liquid_val)
{
	sr_cmdstruct_t CommandElemt;
	BOOL res = TRUE;
	unsigned int liquid_step = 0, sysstep = 0;
	
	if (liquid_val == 100)
	{
		liquid_step = LIQUID_STEP_MIX_STATION;
		sysstep = SYSTEP_LIQUID;
	}
	else if(liquid_val == 150)
	{
		liquid_step = LIQUID_STEP_MIX_STATION * 3 / 2;
		sysstep = SYSTEP_LIQUID * 3 / 2;
	}
	else if(liquid_val == 200)
	{
		liquid_step = LIQUID_STEP_MIX_STATION *  2;
		sysstep = SYSTEP_LIQUID * 2;
	}
		liquid_step = liquid_step * SYSTEP_MOR;
		
//	sysstep = sysstep * SYSTEP_DAB_DISPENS_PEC;
//	liquid_step = liquid_step * SYSTEP_MOR;
sysstep = (sysstep *SYSTEP_DABMOR);
lprintf(log_my, INFO,"mb_aspiratedab\n");

//mb_monitdoorstate();
	CommandElemt.srdevaddr = PUMP_ADDR;
sprintf(CommandElemt.cmdbuf, "S%dO%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR_LAG);	//缓慢抽吸空气		
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);	
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Array_DAB[0], Array_DAB[1], MOV_ZH);//到达试剂位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
mb_monitdoorstate();
		sprintf(CommandElemt.cmdbuf, "ZA %d", 350);
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
usleep(300000);

			
	//	sprintf(CommandElemt.cmdbuf, "ZA %d", DAB_ZMAX);//最底下吸排除气泡影响
		sprintf(CommandElemt.cmdbuf, "ZX %d %d %d", 0, 0, DAB_ZMAX - 4);//测液体
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		if (sb_waitingframeaswer(&CommandElemt) < 0)
		{
			res = FALSE;
		}
		sprintf(CommandElemt.cmdbuf, "ZA %d", DAB_ZMAX);//最底下吸排除气泡影响
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

		CommandElemt.srdevaddr = PUMP_ADDR;
		//sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,(sysstep *108 /100) * num);	//缓慢抽吸液体
		sprintf(CommandElemt.cmdbuf, "S%dP%dR", SYSPEED_LIQUID,sysstep  * num);	//缓慢抽吸液体
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

		usleep(ASPIRATE_T);	//使注射器中液体平衡
		CommandElemt.srdevaddr = ARM_ADDR;
	
usleep(ASPIRATE_T);

		sprintf(CommandElemt.cmdbuf, "ZS -%d %d", DAB_ZMAX - MOV_ZH - 100, LIQUID_SPEED);//缓慢上升
	//	sprintf(CommandElemt.cmdbuf, "ZA%d", 0);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_aspiratedab]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

			sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_clearmixstation]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			
	return res;
}
/******************************************************************************
*
* Function Name  : CabinAspirate
* Description    : 吸取试剂大容量
* 					 
* Input		   :unsigned int reagent_num 试剂信息, unsigned char num 吸取的玻片数
				, unsigned char liquid_val每片玻片滴加量
* Output		   :
* Return		   :  None
*******************************************************************************/
void CabinAspirate(const unsigned int reagent_num ,unsigned char num, unsigned int liquid_val)
{
	sr_cmdstruct_t CommandElemt;
	int reagent_port = 0;
	unsigned int  sysstep = 0;
	int sysspd = SYSPEED;

	;
	
	printf("in CabinAspirate\n");
	
	if (reagent_num == REAGENT_WATER)
		reagent_port = WATERPORT;
	else if (reagent_num == REAGENT_WASH)
		reagent_port = WASHPORT;
	else if (reagent_num == REAGENT_ER1)
		reagent_port = ER1PORT;
	else if (reagent_num == REAGENT_ER2)
		reagent_port = ER2PORT;	
	else if (reagent_num == REAGENT_DEWAX)
		reagent_port = DEWAXPORT;	
	else if (reagent_num == REAGENT_ALCOHOL)
	{
		reagent_port = ALCOHOLPORT;
		sysspd = SYSPEED_ALCHOLE;
	}

	
	
/*	
	if (liquid_val == 100)
		sysstep = SYSTEP_LIQUID;
	else if (liquid_val == 150)
		sysstep = SYSTEP_LIQUID * 3 / 2;
	else if (liquid_val == 200)
		sysstep = SYSTEP_LIQUID * 2;
*/
	sysstep = SYSTEP_LIQUID * liquid_val / 100;
	/************清洗步骤就是大容量灌注 如为试剂滴加中有WEATER替代清洗时亦灌注*************/
	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED,reagent_port,(sysstep) * num);	//抽液体
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[CabinAspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[CabinAspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
	sb_waitingframeaswer(&CommandElemt);
	usleep(ASPIRATE_T);	//使注射器中液体平衡
}

void DispenseSpeedChange(short speed)
{
	sr_cmdstruct_t CommandElemt;
	
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "v%dR", speed);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

}

void CutoffSpeedChange(short speed)
{
	sr_cmdstruct_t CommandElemt;
	
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "c%dR", speed);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

}


void DispenseRemain(void)
{
	sr_cmdstruct_t CommandElemt;
	
		CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", ordArray_wash[WASH1][0], ordArray_wash[WASH1][1], ZWASH_STEP1);// 1号清洗槽
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

		CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dO%dA%dR", SYSPEED,PROBEPORT,0);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_probewash_a]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_probewash_a]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
		CommandElemt.srdevaddr = ARM_ADDR;
			
					strcpy(CommandElemt.cmdbuf, "ZA 0");	
					if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
							printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
						else
							printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
						sb_waitingframeaswer(&CommandElemt);
						

}




/************整架滴加**************/
/******************************************************************************
*
* Function Name  : CabinAspirate
* Description    : 吸取试剂大容量
* 					 
* Input		   :dispense_t* dispense 滴加试剂数据,unsigned int liquid_val每片玻片滴加量
* Output		   :
* Return		   :  None
*******************************************************************************/
void 	mb_shelfnumdispenseval(dispense_t* dispense,unsigned int liquid_val)
{
	unsigned char i = 0, same_num = 1,j = 0,cab_cnt = 0,slf_cnt = 0,add_cnt = 0;
	BOOL repeat = FALSE,try_unlock1 = FALSE,try_unlock2 = FALSE,try_unlock3 = FALSE,try_unlock4 = FALSE;
	unsigned char reagent_num = NO_REAGENT;
//	dispense_t dispense_cab[10] = {0};//大容量
//	dispense_t dispense_slf[10] = {0};//试剂架
	int error_code = 0,res = 0;
	char TCP_Buffer[50] = {0};
	char shelf_num;
	ArmCabin_t cmd;
	sr_cmdstruct_t CommandElemt;
	operate_head_list* operate_head_p = NULL;
	unsigned char last_reagent;

	lprintf(log_my, INFO,"in mb_shelfnumdispenseval\n");
	printf("in mb_shelfnumdispenseval\n");
	printf("dispense=");

	if (dispense[i].plate_num % 30 < 10)  
		{
			shelf_num = 0;
			operate_head_p = operate_head1;
			last_reagent = last_reagentA;
		}
		else if (dispense[i].plate_num % 30 < 20)
		{
			shelf_num = 1;
			operate_head_p = operate_head2;
			last_reagent = last_reagentB;
		}
		else if (dispense[i].plate_num % 30 < 30)
		{
			shelf_num = 2;
			operate_head_p = operate_head3;
			last_reagent = last_reagentC;
		}
		
	while(i < 11 && dispense[i].reagent != STOP_OPERATE)
	{
		printf(" reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		lprintf(log_my, INFO," reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		if ((dispense[i].reagent & 0X80) > 0 && (dispense[i].reagent & 0X7F) <= 35)//滴加时候替换只对试剂架上试剂有效
		{
			TCP_Buffer[0] = dispense[i].plate_num % 30;
			if ( (res = mb_searchcomatiblereagent(&dispense[i].reagent_info, liquid_val)) < 0)
			{
				j++;
				TCP_Buffer[23] = 2;		
			}
			else
			{
				reagent_lock[res / 9][shelf_num] = 1;
					
				if ((res / 9) == 0 )
				{
				
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK1);
					else
						GPIO_OutClear(CGLOCK1);
				}
				else if ((res / 9) == 1 )
				{
				
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK2);
					else
						GPIO_OutClear(CGLOCK2);
				}
				else if ((res / 9) == 2 )
				{
				
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK3);
					else
						GPIO_OutClear(CGLOCK3);
				}
				else if ((res / 9) == 3 )
				{
				
					if (SHELF_LOCK_WAY_NEW)
						GPIO_OutSet(CGLOCK4);
					else
						GPIO_OutClear(CGLOCK4);
				}
				
				//减去对应的试剂量
				reagent_code[res].val -= liquid_val;
				memcpy(&TCP_Buffer[1],dispense[i].reagent_info.code,9);
				memcpy(&TCP_Buffer[10],reagent_code[res].code,9);
				memcpy(&TCP_Buffer[19],&liquid_val,4);
				if (res & 0X80 > 0)//不同批号
					TCP_Buffer[23] = 1;		
				res  &= 0X7F;
				dispense[i].reagent = res;
			}	
			nt_sendpacketdata(REPLACE_REAGENT, TCP_Buffer, 24);
			
		}
		else//混合站试剂在滴加时有试剂拿掉无影响
		{
			dispense[i].reagent &= 0X7F;
		}
		i++; 
	}
	printf("*(****************i = %d j =%d\n",i,j);
	if (i == j)//全部替换成WASH 停止此架操作
	{
		printf("compatible wash all\n");
		lprintf(log_my, INFO,"compatible wash all\n");
		if (dispense[0].plate_num % 30 < 10)
			mb_seterrorcode(SHELF1_ABANDON);
		else if (dispense[0].plate_num % 30 < 20)
			mb_seterrorcode(SHELF2_ABANDON);
		else if (dispense[0].plate_num % 30 < 30)
			mb_seterrorcode(SHELF3_ABANDON);
		

		return;
	}
	
	else
	{

	}
	i = 0;
	while(i < 11 && dispense[i].reagent != STOP_OPERATE)
	{
		printf(" reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		lprintf(log_my, INFO," reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		if ((dispense[i].reagent & 0X7F) >= REAGENT_CASE)
		{
		//	memcpy(&dispense_cab[cab_cnt], &dispense[i], sizeof(dispense_t));
			cab_cnt++;
		}
		else
		{
	//		memcpy(&dispense_slf[slf_cnt], &dispense[i], sizeof(dispense_t));
			slf_cnt++;
			if ((dispense[i].reagent & 0X7F) / 9 == 0)
				try_unlock1 = TRUE;
			else if ((dispense[i].reagent & 0X7F) / 9 == 1)
				try_unlock2 = TRUE;
			else if ((dispense[i].reagent & 0X7F) / 9 == 2)
				try_unlock3 = TRUE;
			else if ((dispense[i].reagent & 0X7F) / 9 == 3)
				try_unlock4 = TRUE;
		}
		i++;
	}
/*
	dispense_slf[slf_cnt].reagent = STOP_OPERATE;

	i = 0;
	printf("dispense_slf=");
	while(dispense_slf[i].reagent != STOP_OPERATE)
	{
		printf(" %d ", dispense_slf[i].reagent);
		i++;
	}
*/	


	i = 0;
	while(i < 11 && dispense[i].reagent != STOP_OPERATE)
	{
		while((i + same_num) < 11 && dispense[i + same_num].reagent != STOP_OPERATE)
		{
			if (dispense[i].reagent == dispense[i + same_num].reagent)
				same_num++;
			else
				break;
		}
		
		reagent_num = dispense[i].reagent;

		//清洗步骤
	//	mb_probewash_c(WATERPORT); //test
mb_procwashprobe(reagent_num);
#ifdef BIG_VERSION
//拉伸是否完成
while(!ArmCabinWork_finished[shelf_num])// 滴加前进行判断
								usleep(100000);

#endif
		error_code = reagent_num;
		reagent_flag = dispense[i].reagent;
		while(!flg_mainproexit)	//当same_num > 5时重复一吸液体
		{	
		printf("same_num = %d repeat = %d i = %d",same_num,repeat,i);
		printf("do aspirate\n");
//		if (mb_monitdoorstate() < 0)
		{	//当PC发来停止某架操作 而刚好执行的是这架的操作则退出
			if ((shelf_num == 0 && !flg_opwork1ready && !hydrateA.flage) ||
				(shelf_num == 1 && !flg_opwork2ready && !hydrateB.flage) ||
				(shelf_num == 2 && !flg_opwork3ready && !hydrateC.flage))
				return; 
		}

		if (reagent_num < REAGENT_CASE)		//试剂架上试剂吸取 对于大容量试剂已在清洗步骤中灌注
		{
			if ((res_shelf = mb_shelfaspirate(reagent_num, same_num, liquid_val,shelf_num)) < 0)
			{
				if (res_shelf == -9)
				{
				for(add_cnt = 0; add_cnt < same_num ;add_cnt++)
				aspirate_notenough[add_cnt] = (dispense[i+add_cnt].plate_num %30) + 1;
				
				aspirate_notenough[10] = same_num ;
					mb_seterrorcode(ASPIRATE_WRONG );
				}
				else	
				{
				
				printf("dispense=%d dispenseA=%d dispenseB=%d dispenseC=%d dispense[0].plate_num=%d \n",
									dispense,dispenseA,dispenseB,dispenseC,dispense[0].plate_num);

				lprintf(log_my, INFO,"same_num=%d aspirate_notenough[10]=%d i=%d\n",same_num, aspirate_notenough[10],i);
				printf("same_num=%d aspirate_notenough[10]=%d i=%d\n",same_num, aspirate_notenough[10],i);
				for(add_cnt = 0; add_cnt < same_num - aspirate_notenough[10];add_cnt++)
				aspirate_notenough[add_cnt] = (dispense[i+add_cnt].plate_num %30) + 1;
				
				aspirate_notenough[10] = same_num - aspirate_notenough[10];
				
					mb_seterrorcode(ASPIRATE_WRONG_NOT_ENOUGH );
				printf("dispense=%d dispenseA=%d dispenseB=%d dispenseC=%d dispense[0].plate_num=%d \n",
					dispense,dispenseA,dispenseB,dispenseC,dispense[0].plate_num);
				}
			}
			
		}
		else if (reagent_num == REAGENT_DAB)
		{
			if ((dispense[i].plate_num % 30) < 10)
			{
				if (!mb_aspiratedab(Array_mixed_DAB1,same_num, liquid_valA))	
					mb_seterrorcode(ASPIRATE_WRONG);
				
			}
			else if ((dispense[i].plate_num % 30) < 20)
			{
				if (!mb_aspiratedab(Array_mixed_DAB2,same_num, liquid_valB))	
					mb_seterrorcode(ASPIRATE_WRONG);		
			}
			else if ((dispense[i].plate_num % 30) < 30)
			{
				if (!mb_aspiratedab(Array_mixed_DAB3,same_num, liquid_valC))	
					mb_seterrorcode(ASPIRATE_WRONG);
			}
			
		}
		else if (reagent_num == REAGENT_SECEND)//双染滴加RED
		{
			if ((dispense[i].plate_num % 30) < 10)
			{
				if (!mb_aspiratedab(Array_mixed_RED1,same_num, liquid_valA))
					{
					aspirate_notenough[10] = 10;//整架有影响
					mb_seterrorcode(ASPIRATE_WRONG );
					}
			}
			else if ((dispense[i].plate_num % 30) < 20)
			{
				if (!mb_aspiratedab(Array_mixed_RED2,same_num, liquid_valB))
					{
					aspirate_notenough[10] = 10;//整架有影响
					mb_seterrorcode(ASPIRATE_WRONG );
					}
			}
			else if ((dispense[i].plate_num % 30) < 30)
			{
				if (!mb_aspiratedab(Array_mixed_RED3,same_num, liquid_valC))
					{
					aspirate_notenough[10] = 10;//整架有影响
					mb_seterrorcode(ASPIRATE_WRONG );
					}
			}
		}
		else	//需要在破片拉伸位置滴加大容量试剂  针对大仪器
		{		
			 if(dispense[i].plate_num < 30 || (dispense[i].plate_num >= 60 && dispense[i].plate_num < 90))
				liquid_val = 100;
			else
				liquid_val = 160;
				
			CabinAspirate(reagent_num,same_num, liquid_val);
				
		}
		
		if (reagent_num >= REAGENT_CASE)//试剂架试剂可能发生试剂替换，在吸取试剂中赋值
			report_reagentinfo[shelf_num] = reagent_num;
		
		printf("dispense=%d dispenseA=%d dispenseB=%d dispenseC=%d dispense[0].plate_num=%d \n",
					dispense,dispenseA,dispenseB,dispenseC,dispense[0].plate_num);
	#ifdef BIG_VERSION
		flg_normaldispenseliquid[shelf_num]++;
	#else
		flg_normaldispenseliquid[shelf_num] = TRUE;
	#endif
#if 1
			if (!door_open_action)
			{
				if (DOOR_OPENDED)
				{
					printf("DOOR_OPENDED***********************\n");
					if (initialize_finished)
					{
					CommandElemt.srdevaddr = ARM_ADDR;
		
				strcpy(CommandElemt.cmdbuf, "ZA 0");	
				if (sb_armpumpsend(port_arm, (unsigned char	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
						printf("[WarterPour]: Send message	to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
					else
						printf("[WarterPour]: Send message	to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
					sb_waitingframeaswer(&CommandElemt);
					}
				while(DOOR_OPENDED)
					sleep(1);
				}
			}
		
#endif
	if (shelf_num == 0)
		StartDispenseA = TRUE;
	else if (shelf_num == 1)
		StartDispenseB = TRUE;
	else if (shelf_num == 2)
		StartDispenseC = TRUE;

		CutoffSpeedChange(SYSCUTOFF_SPEED);
	//	DispenseSpeedChange(START_DISPENSE);


		first_dispense = TRUE;
#if 1
		if (dispense[0].reagent < 37 || dispense[0].reagent >= REAGENT_DAB || dispense[0].reagent == REAGENT_DEWAX)
			 dispense_spd = SYSPEED_DISPENSE_SHELF;
		else
#endif
			 dispense_spd = SYSPEED_DISPENSE;

	
		while(same_num > 0)		//滴加试剂相同的玻片架
		{	
	//		if (mb_monitdoorstate() < 0)
			{	//当PC发来停止某架操作 而刚好执行的是这架的操作则退出
				if ((shelf_num == 0 && !flg_opwork1ready && !hydrateA.flage) ||
				(shelf_num == 1 && !flg_opwork2ready && !hydrateB.flage) ||
				(shelf_num == 2 && !flg_opwork3ready && !hydrateC.flage))
				{
					DispenseRemain();
					
					CutoffSpeedChange(SYSSTARTSPD);
					goto DOSHELFDISPENSE_END;
				}
			}
	printf("dispense=%d dispenseA=%d dispenseB=%d dispenseC=%d dispense[0].plate_num=%d \n",
					dispense,dispenseA,dispenseB,dispenseC,dispense[0].plate_num);
			if (mb_dispensingliquid(dispense[i].plate_num, (unsigned char )liquid_val,same_num,reagent_num) < 0)
			{
				DispenseRemain();
				CutoffSpeedChange(SYSSTARTSPD);
				goto DOSHELFDISPENSE_END;
			}
			
			first_dispense = FALSE;
		i++;	
		same_num--;
		}	
		
		CutoffSpeedChange(SYSSTARTSPD);
		//滴加相同玻片试剂
		
		if (repeat)
		{
			same_num = 5;
			repeat = FALSE;
			mb_procwashprobe(reagent_num);
			continue;
		}
		else
			break;
	
	}//当超过5片相同吸取试剂
	
	same_num = 1;
	
	}


	printf("operate_head_p->operate.reagent=%d, dispense[0].reagent=%d\n",operate_head_p->operate.reagent,dispense[0].reagent);
	
	if (dispense[0].plate_num  < 90 &&  
		 operate_head_p->operate.reagent != STOP_OPERATE)//  拉升全部 不西风, 水合和最后一步不吸风放置按钮导致通信异常
	{
		
		if(dispense[0].reagent == REAGENT_ER1 || dispense[0].reagent == REAGENT_ER2)
		{
		//	if (operate_head_p->operate.reagent != REAGENT_ER1 && operate_head_p->operate.reagent != REAGENT_ER2)
		//		{}
		//	else
				if(last_reagent != REAGENT_ER1 && last_reagent != REAGENT_ER2)
			{
				fan[shelf_num].time = 13;
				fan[shelf_num].NORMAL_FAN = TRUE;
				
			}
		}
	#ifdef LAIYUE
		else if((dispense[0].reagent < REAGENT_CASE ) //&&  strcmp(reagent_code[dispense[0].reagent].reagent_kind, "*Hem") != 0
			|| (dispense[0].reagent == REAGENT_DAB) || (dispense[0].reagent == REAGENT_SECEND))
			//|| dispense[0].reagent == REAGENT_WATER)
		{
		//	fan[shelf_num].time = 6;
		//	fan[shelf_num].NORMAL_FAN = TRUE;
		}
		#else
			else if(dispense[0].reagent < REAGENT_CASE || dispense[0].reagent == REAGENT_DAB || (dispense[0].reagent == REAGENT_SECEND)
					|| dispense[0].reagent == REAGENT_WATER)
				{
					fan[shelf_num].time = 6;
					fan[shelf_num].NORMAL_FAN = TRUE;
				}

	#endif
	

		else if((dispense[0].reagent == REAGENT_DEWAX) || (dispense[0].reagent == REAGENT_ALCOHOL))
		{
		#ifdef LAIYUE
			if(dispense[0].reagent == REAGENT_DEWAX && operate_head_p->operate.reagent == REAGENT_ALCOHOL)
				{}
			else
		#endif
				{
				fan[shelf_num].time = 1;
				fan[shelf_num].NORMAL_FAN = TRUE;
				}
		}
		else
		{
			if(( (dispense[0].reagent == REAGENT_WATER) || (dispense[0].reagent == REAGENT_WASH)) &&  
				( (operate_head_p->operate.reagent < REAGENT_CASE ) || (operate_head_p->operate.reagent == REAGENT_DAB)
				|| (operate_head_p->operate.reagent == REAGENT_SECEND) ))
				{}
				else
				{
					
					if(strcmp(&lastt_kind[shelf_num][0], "*Hem") == 0)
						fan[shelf_num].time = 13;
					else if(lastt_kind[shelf_num][0] == 0)
						fan[shelf_num].time = 13;
					else
						fan[shelf_num].time = 6;
					fan[shelf_num].NORMAL_FAN = TRUE;
				}
				
		}
	}

	if (res_shelf < 0 || (dispense[0].reagent == REAGENT_DAB) || (dispense[0].reagent == REAGENT_SECEND))// 探到底进行吸取 马上进行清洗
	{
		mb_procwashprobe(last_cabin_reagent);
		res_shelf = 0;
		
	}
		
/*
	if(dispense[0].reagent == REAGENT_DEWAX || dispense[0].reagent == REAGENT_ALCOHOL)
			tp_fanworkproce(shelf_num + 1, 0);
	*/	
	DOSHELFDISPENSE_END:
	if (try_unlock1)
		reagent_lock[0][shelf_num] = 0;//滴加结束尝试解锁对应试剂架
	if (try_unlock2)
		reagent_lock[1][shelf_num] = 0;
	if (try_unlock3)
		reagent_lock[2][shelf_num] = 0;
	if (try_unlock4)
		reagent_lock[3][shelf_num] = 0;
	

	
}




void ZRaise(void)
{
	sr_cmdstruct_t CommandElemt;
	
	CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);

}


/******************************************************************************
*
* Function Name  : mb_dispensingliquid
* Description    : 滴加一片玻片操作
* 					 
* Input		   :unsigned char plate_num 滴加玻片位置,unsigned int liquid_val每片玻片滴加量
* Output		   :
* Return		   :  None
*******************************************************************************/
int  mb_dispensingliquid(unsigned char plate_num,unsigned char liquid_val,unsigned char  same_num,char reagent_num)
{
	sr_cmdstruct_t CommandElemt;
	unsigned int* ordArray_plate;
	unsigned int* dispense_step_p;
	unsigned int dispense_step = 0, sysstep = 0;
	int sysspd = dispense_spd;
	
/*	
	if (liquid_val == 100)
		sysstep = SYSTEP_LIQUID;
	else if (liquid_val == 150)
		sysstep = SYSTEP_LIQUID * 3 / 2;
	else if (liquid_val == 200)
		sysstep = SYSTEP_LIQUID * 2;
*/
//	sysstep = SYSTEP_LIQUID * liquid_val / 100 *SYSTEP_MOR;//多滴加百分之10
	sysstep = SYSTEP_LIQUID * liquid_val / 100;

	if (liquid_val < 100)
	{
		flg_mainproexit = TRUE;
		return -1;
	}
//	printf("in mb_dispensingliquid\n");
//	printf("flg_opwork1ready=%d,hydrateA.flage=%d\n",flg_opwork1ready,hydrateA.flage);
		
	if (plate_num% 30 < 10)
		dispense_step_p = dispense_stepA;
	else if (plate_num% 30 < 20)
		dispense_step_p = dispense_stepB;
	else
		dispense_step_p = dispense_stepC;

	
		if (plate_num < 30) //初始位置
		{
			ordArray_plate = (unsigned int *)ordArray_plate1;
			dispense_step = dispense_step_p[0];
		}
		else if (plate_num < 60)//150ul位置
		{
			plate_num = plate_num - 30;
			ordArray_plate = (unsigned int *)ordArray_plate2;
			dispense_step = dispense_step_p[1];
		}
		else if (plate_num < 90)//100ul位置
		{
			plate_num = plate_num - 60;
			ordArray_plate = (unsigned int *)ordArray_plate3;
			dispense_step = dispense_step_p[2];
		}
		else if (plate_num < 120)//组织位置
		{
			plate_num = plate_num - 90;
			ordArray_plate = (unsigned int *)ordArray_plate4;
			dispense_step = dispense_step_p[0] + DISPENSE_INTERVAL_ALL;
		//	dispense_spd = SYSPEED_DISPENSEFUL;
		}


#ifdef BIG_VERSION
	dispense_step = dispense_step - OFFSET_STEP;	
#endif
		//	printf("do dispense\n");


//	dispense_step = MOV_ZH;
#if 0
	if (reagent_num == REAGENT_DEWAX || reagent_num == REAGENT_ALCOHOL)
	{
		if (self_pump)
			sysspd = 10 ;
		else
			sysspd = 15 ;
	}
	#endif	
	if (first_dispense)
//	if (0)
	{
		CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	}
///	usleep(ASPIRATE_T);
//	mb_monitdoorstate();
	//滴加 只检测门
#if 0
	if (!door_open_action)
	{
		if (DOOR_OPENDED)
		{
			printf("DOOR_OPENDED***********************\n");
			if (initialize_finished)
			{
			CommandElemt.srdevaddr = ARM_ADDR;

		strcpy(CommandElemt.cmdbuf, "ZA 0");	
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[WarterPour]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[WarterPour]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
			}
		while(DOOR_OPENDED)
			sleep(1);
		}
	}

#endif
#if 1
		if ((plate_num % 30) < 10)
		{
			if( !flg_opwork1ready&& !hydrateA.flage)
				return -1;
				
		}
		else if ((plate_num % 30) < 20)
		{
			if( !flg_opwork2ready&& !hydrateB.flage)
				return -1;
		}
		else
		{
			if( !flg_opwork3ready&& !hydrateC.flage)//水合时玻片已经抬升
				return -1;
		}
	
#endif

printf("ordArray_plate1=%d ordArray_plate2=%d ordArray_plate3=%d ordArray_plate4=%d par.ordArray_plate=%d\n",
		ordArray_plate1,ordArray_plate2, ordArray_plate3,ordArray_plate4, par.ordArray_plate);
printf("plate_num=%d ordArray_plate=%d dispense_step=%d\n", plate_num, ordArray_plate, dispense_step);
#if 1
		CommandElemt.srdevaddr = ARM_ADDR;
		
	//		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",*( ordArray_plate + plate_num * 2 + 0), *( ordArray_plate + plate_num * 2 + 1), MOV_ZH);//到达玻片位置

		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",*( ordArray_plate + plate_num * 2 + 0), *( ordArray_plate + plate_num * 2 + 1), dispense_step);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
#endif
#if 1			
		if ((plate_num % 30) < 10)
		{
			if( !flg_opwork1ready&& !hydrateA.flage)
				return -1;
				
		}
		else if ((plate_num % 30) < 20)
		{
			if( !flg_opwork2ready&& !hydrateB.flage)
				return -1;
		}
		else
		{
			if( !flg_opwork3ready&& !hydrateC.flage)//水合时玻片已经抬升
				return -1;
		}
#endif
	//	sleep(3);
	//	mb_monitdoorstate();
#if 1
		CommandElemt.srdevaddr = PUMP_ADDR;
	if (reagent_num < 37)
	{
		if (first_dispense)
			sprintf(CommandElemt.cmdbuf, "S%dD%dR", sysspd,sysstep + SYSTEP_AIR / 2);//滴加试剂
		else	
			sprintf(CommandElemt.cmdbuf, "S%dD%dR", sysspd,sysstep * SYSTEP_DISPENSMOR );
	}
	else
	{
	if (first_dispense)
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", sysspd,sysstep + SYSTEP_AIR );
	else
		sprintf(CommandElemt.cmdbuf, "S%dD%dR", sysspd,sysstep );
	}
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);	
	#endif	
//usleep(DISPENSE_T);
//usleep(100000);

#if 0
	CommandElemt.srdevaddr = PUMP_ADDR;
		sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	mb_monitdoorstate();	
#endif

		if (same_num == 1)//最后一次上升
		{
		CommandElemt.srdevaddr = ARM_ADDR;
		sprintf(CommandElemt.cmdbuf, "ZA %d",  MOV_ZH);//Z轴上升
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_dispensingliquid]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		}

	return 0;
	
}

void doArmCabinDispense(char sel, char pos, char reagent, char val )
{
	ArmCabinCmdList[sel].dispense_pos = pos;
				ArmCabinCmdList[sel].reagent_sel = reagent;
				ArmCabinCmdList[sel].reagent_val = val;
				ArmCabinCmdList[sel].cmd = ArmCabinWork;//命令最后赋值dowork_Arm_cabinA以此判断

}

#ifdef BIG_VERSION
void do_work_hydration(void)
{	
	struct timeval  now;
	dispense_t dispense[11]; 
	unsigned char i = 0, plate_num = 0;
	stminibd_sendpacket cmd;
	static BOOL isReload_setedA = TRUE;
	static BOOL isReload_setedB = TRUE;
	static BOOL isReload_setedC = TRUE;
	char TCP_Buffer[4] = {0};
	
	gettimeofday(&now, NULL);
			
//#if BIG_VERSION
//	printf("hydrateA.flage=%d flg_mianarmstop_a=%d isReload_setedA=%d\n",hydrateA.flage,flg_mianarmstop_a,isReload_setedA);

	if (hydrateA.flage)
	{
		if ( (now.tv_sec - hydrateA.start_time) > 30 * (60))//15分钟
	//	if ( (now.tv_sec - hydrateA.start_time) > 60 )//15分钟
		{
			doArmCabinDispense(0, 0, REAGENT_WASH, 150);
			mb_dischargeshelfwateliquid(1);
			
			hydrateA.start_time = now.tv_sec;
				flg_mianarmstop_a = TRUE;
			TCP_Buffer[0] = 1;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
		}
		
	}


	if (hydrateB.flage)
	{
		if ( (now.tv_sec - hydrateB.start_time) > 30 * (60))//15分钟
	//	if ( (now.tv_sec - hydrateB.start_time) > 60 )//15分钟
		{
			doArmCabinDispense(1, 0, REAGENT_WASH, 150);
			mb_dischargeshelfwateliquid(2);
			
			hydrateB.start_time = now.tv_sec;
				flg_mianarmstop_b = TRUE;
			TCP_Buffer[0] = 2;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
		}
	}
	
	if (hydrateC.flage)
	{
		if ( (now.tv_sec - hydrateC.start_time) > 30 * (60))//15分钟
	//	if ( (now.tv_sec - hydrateC.start_time) > 60 )//15分钟
		{
			doArmCabinDispense(2, 0, REAGENT_WASH, 150);
			mb_dischargeshelfwateliquid(3);
			
			hydrateC.start_time = now.tv_sec;
				flg_mianarmstop_c = TRUE;
			TCP_Buffer[0] = 3;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
		}
		
	}


}


#else
void do_work_hydration(void)
{	
	struct timeval  now;
	dispense_t dispense[11]; 
	unsigned char i = 0, plate_num = 0;
	stminibd_sendpacket cmd;
	static BOOL isReload_setedA = TRUE;
	static BOOL isReload_setedB = TRUE;
	static BOOL isReload_setedC = TRUE;
	char TCP_Buffer[4] = {0};
	
	gettimeofday(&now, NULL);
			
//#if BIG_VERSION
//	printf("hydrateA.flage=%d flg_mianarmstop_a=%d isReload_setedA=%d\n",hydrateA.flage,flg_mianarmstop_a,isReload_setedA);

	if (hydrateA.flage && flg_mianarmstop_a)
	{
		if ( (now.tv_sec - hydrateA.start_time) > 30 * (60))//15分钟
	//	if ( (now.tv_sec - hydrateA.start_time) > 2*60 )//15分钟
		{
			
			bs_packetshelfstreach(0,&cmd); //此命令使玻片架按键失效(待验证)
		
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			while(mini_work_finished[0])//确保miniBoard线程已置FALSE
				usleep(1000);
			sleep(1);
			while(!mini_work_finished[0])
				usleep(200000);
			mini_work_finished[0] = FALSE; //防止上次拉伸对这次 mini_finished的干扰
			mb_dischargeshelfwateliquid(1);
			sleep(3);//防止按键刚好按下
			if (hydrateA.flage == FALSE)
			{
					memset(&cmd,0,sizeof(cmd));
					#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
					cmd.minicmd_buffer[4] = 1;
					cmd.minicmd_num=2;
					pthread_mutex_lock(&mutex_mlock);
					set_minicmd(pcmd_head,cmd);
					if (pthread_mutex_unlock(&mutex_mlock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
					return ;
			}
	//		hydrateA.start_time = now.tv_sec;
			printf("hydrateA=");
#ifdef BIG_VERSION
			{
			//	SendArmCabinWork(ArmCabinShuiHe, 0, REAGENT_WASH, 2, 150);
				flg_mianarmstop_a = TRUE;
			}
			#else
			{
				for (i = 0; i < 11;i++)
				{
					{
						dispenseA[i] = hydrateA.hydrate_plate[i];
						printf(" %d-%d ",dispenseA[i].reagent,dispenseA[i].plate_num);
					}
				}
			}
		#endif
			TCP_Buffer[0] = 1;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
			if (hydrateA.flage)	//防止在发送doStrechShelf之前已经上台玻片架，
			{
				
#ifndef BIG_VERSION
				//  大仪器主臂不动作
					flg_mianarmstop_a = FALSE;
			#endif
				isReload_setedA = FALSE;
			}
		}
		else if (flg_mianarmstop_a && (!isReload_setedA))	//由于主臂在动作时可能发送拉伸动作导致不能RELOAD
		{
			memset(&cmd,0,sizeof(cmd));
			#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
			cmd.minicmd_buffer[4] = 1;
			cmd.minicmd_num=2;
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			isReload_setedA = TRUE;
		}
		
	}

	if (hydrateB.flage && flg_mianarmstop_b)
	{
		if ( (now.tv_sec - hydrateB.start_time) >  30 * (60))
	//if ( (now.tv_sec - hydrateB.start_time) >  60)
		{
			
			bs_packetshelfstreach(10,&cmd); //此命令使玻片架按键失效
		
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			while(mini_work_finished[1])//确保miniBoard线程已置FALSE
				usleep(1000);
			sleep(1);
			while(!mini_work_finished[1])
				usleep(200000);
			mini_work_finished[1] = FALSE; //防止上次拉伸对这次 mini_finished的干扰
			mb_dischargeshelfwateliquid(2);
	//		hydrateB.start_time = now.tv_sec;
			sleep(3);//防止按键刚好按下
			if (hydrateB.flage == FALSE)
			{
					memset(&cmd,0,sizeof(cmd));
					#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
					cmd.minicmd_buffer[4] = 2;
					cmd.minicmd_num=2;
					pthread_mutex_lock(&mutex_mlock);
					set_minicmd(pcmd_head,cmd);
					if (pthread_mutex_unlock(&mutex_mlock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
					return ;
			}
			
			printf("hydrateB=");
#ifdef BIG_VERSION
			{
			//	SendArmCabinWork(ArmCabinShuiHe, 1, REAGENT_WASH, 2, 150);
				flg_mianarmstop_b = TRUE;
			}
			#else
			{
				for (i = 0; i < 11;i++)
				{
					dispenseB[i] = hydrateB.hydrate_plate[i];

					printf(" %d-%d ",dispenseB[i].reagent,dispenseB[i].plate_num);
				}
			}
		#endif
			TCP_Buffer[0] = 2;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
			if (hydrateB.flage)	//防止在发送doStrechShelf之前已经上台玻片架，
			{
				
#ifndef BIG_VERSION
				//  大仪器主臂不动作
					flg_mianarmstop_b = FALSE;
#endif
				isReload_setedB = FALSE;
			}
		}
		else if (flg_mianarmstop_b && (!isReload_setedB))	//由于主臂在动作时可能发送拉伸动作导致不能RELOAD
		{
			memset(&cmd,0,sizeof(cmd));
			#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
			cmd.minicmd_buffer[4] = 2;
			cmd.minicmd_num=2;
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			isReload_setedB = TRUE;
		}
		
	}

	if (hydrateC.flage && flg_mianarmstop_c)
	{
		if ( (now.tv_sec - hydrateC.start_time) >  30 * (60))
	//	if ( (now.tv_sec - hydrateC.start_time) > (60))
		{
			
			bs_packetshelfstreach(20,&cmd); //此命令使玻片架按键失效
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			while(mini_work_finished[2])//确保miniBoard线程已置FALSE
				usleep(1000);
			sleep(1);
			while(!mini_work_finished[2])
				usleep(200000);
			mini_work_finished[2] = FALSE; //防止上次拉伸对这次 mini_finished的干扰
			mb_dischargeshelfwateliquid(3);
			sleep(3);//防止按键刚好按下
			if (hydrateC.flage == FALSE)
			{
					memset(&cmd,0,sizeof(cmd));
					#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
					cmd.minicmd_buffer[4] = 3;
					cmd.minicmd_num=2;
					pthread_mutex_lock(&mutex_mlock);
					set_minicmd(pcmd_head,cmd);
					if (pthread_mutex_unlock(&mutex_mlock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
					return ;
			}
		//	hydrateC.start_time = now.tv_sec;
			printf("hydrateC=");
#ifdef BIG_VERSION
			{
			//	SendArmCabinWork(ArmCabinShuiHe, 2, REAGENT_WASH, 2, 150);
				flg_mianarmstop_c = TRUE;
			}
			#else
			{
				for (i = 0; i < 11;i++)
				{
					dispenseC[i] = hydrateC.hydrate_plate[i];

					printf(" %d-%d ",dispenseC[i].reagent,dispenseC[i].plate_num);
				}
			}
		#endif
			TCP_Buffer[0] = 3;
			nt_sendpacketdata(HYDRATE_WORK, TCP_Buffer, 1);
		//	sleep(3);
			if (hydrateC.flage)	//防止在发送doStrechShelf之前已经上台玻片架，
			{
				
#ifndef BIG_VERSION
				//  大仪器主臂不动作
					flg_mianarmstop_c = FALSE;
#endif
				isReload_setedC = FALSE;
			}
		}
		else if (flg_mianarmstop_c && (!isReload_setedC))	//由于主臂在动作时可能发送拉伸动作导致不能RELOAD
		{
			memset(&cmd,0,sizeof(cmd));
			#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
			cmd.minicmd_buffer[4] = 3;
			cmd.minicmd_num=2;
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
			isReload_setedC = TRUE;
		}
	
	}
	

}

#endif

void mb_lockallregent(char shelf_num)
{
	reagent_lock[0][shelf_num] =reagent_lock[1][shelf_num]=reagent_lock[2][shelf_num]=reagent_lock[3][shelf_num]= 1;
	if (SHELF_LOCK_WAY_NEW)
	{
		GPIO_OutSet(CGLOCK1);
		GPIO_OutSet(CGLOCK2);
		GPIO_OutSet(CGLOCK3);
		GPIO_OutSet(CGLOCK4);
	}
	else
	{
		GPIO_OutClear(CGLOCK1);
		GPIO_OutClear(CGLOCK2);
		GPIO_OutClear(CGLOCK3);
		GPIO_OutClear(CGLOCK4);
	}

}

int md_lockreagentshelf(void) //这个函数中发送段错误 多为流程中没有DAB
{
	unsigned char i = 0;
//	unsigned char lock_counter = 0;
	BOOL lock_contorl1 = FALSE,lock_contorl2 = FALSE,lock_contorl3 = FALSE,lock_contorl4 = FALSE;//为TURE时必定上锁
	struct timeval now;
	operate_head_list* operate_head = NULL, *operate_head_p = NULL;
	operate_t * operate_p = NULL;
//	operate_t * operate_DABp = NULL;
	volatile unsigned char * reagent_lock_num_p = NULL;
//	unsigned char reagent_DAB = 0XFF;
//	unsigned char reagent_RED = 0XFF;
	char TCP_Buffer[24] ={0};
	BOOL mainarm_finished = FALSE;
	 char Isunlock[4] = {0};
	static char Issetgreen[4] = {0};

	pthread_mutex_lock(&head_lock);
	
	gettimeofday(&now, NULL);
		
	for (i = 0; i < 3;i++)
	{
		if (i == 0)
		{
			operate_head_p = operate_head = operate_head1;
		//	mainarm_finished = flg_mianarmstop_a;
		}
		else if (i == 1)
		{
			operate_head_p = operate_head = operate_head2;
		//	mainarm_finished = flg_mianarmstop_b;
		}
		else if (i == 2)
		{
			operate_head_p = operate_head = operate_head3;
		//	mainarm_finished = flg_mianarmstop_c;
		}

		
//		printf("in md_lockreagentshelf\n");
		do
		{
			operate_p = &operate_head_p->operate;

		//根据操作规程 同一架流程中 不同玻片滴加试剂架上试剂时可能全是不同的瓶子(抗体)
			while (operate_p != NULL && operate_p->reagent != STOP_OPERATE)  //在一张玻片的流程中找小于N分钟的要用到的试剂
			{	
				if (operate_p->reagent >= REAGENT_DAB)
				{
					operate_p = operate_p->next;
					continue;
				}
				//小于N分钟锁定
			//	printf("operate_p->time=%d now.tv_sec - begin_time.tv_sec=%d\n",
			//	operate_p->time,now.tv_sec - begin_time.tv_sec);
				
				if ((operate_p->time <= (now.tv_sec - begin_time.tv_sec)) || 
					( (operate_p->time- (now.tv_sec - begin_time.tv_sec) ) <= 300 ) )
				{
	//break;
			//		printf("operate_p->reagent =%d\n",operate_p->reagent);
					//试剂信息无效  说明被拿掉 直接报警
					if ((operate_p->reagent & 0X80) > 0)
					{
							printf("reagent has been removed&&&&&&&&&&&&&&&&&&&&&&\n");
			
							//发送被拿掉的试剂码
							TCP_Buffer[0] = 0;
							memcpy(&TCP_Buffer[1],operate_p->reagent_info.code,sizeof(operate_p->reagent_info.code));

							nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
							if (pthread_mutex_unlock(&head_lock) != 0)
								lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
							return -1;
						
					}

					
					{	
		
						if (operate_p->reagent  < 9  )	
						{
							reagent_lock_num_p = &reagent_lock_num1;
							lock_contorl1 = TRUE;
							reagent_lock[0][i] = 1;
						}
						else if (operate_p->reagent < 18 )
						{
							reagent_lock_num_p = &reagent_lock_num2;
							lock_contorl2 = TRUE;	
							reagent_lock[1][i] = 1;
						}
						else if (operate_p->reagent < 27 )
						{
							reagent_lock_num_p = &reagent_lock_num3;
							lock_contorl3 = TRUE;
							reagent_lock[2][i] = 1;
						}
						else if (operate_p->reagent < 36 )
						{
							reagent_lock_num_p = &reagent_lock_num4;
							lock_contorl4 = TRUE;
							reagent_lock[3][i] = 1;
						}	
						else if ( operate_p->reagent == REAGENT_ER1			
								|| operate_p->reagent == REAGENT_ER2)
						{
							//混合在混合操作函数中锁定	
							operate_p = operate_p->next;
								continue;
						}
						else			//其他试剂但是不用锁定
						{
							operate_p = operate_p->next;
								continue;
						}
						
						if (operate_head == operate_head1)
								*reagent_lock_num_p |= 0X01;
							else if (operate_head == operate_head2)
								*reagent_lock_num_p |= 0X02;
							else if (operate_head == operate_head3)
								*reagent_lock_num_p |= 0X04;				
					}
				}
				else	//大于N分钟退出
					break;

				operate_p = operate_p->next;
			}
		
			operate_head_p = operate_head_p->next_head;
		}
		while(operate_head_p != NULL);
		
		if (operate_head->operate.reagent < REAGENT_CASE)//只有当前操作为滴加试剂架上试剂时才 
		{												//等待主臂滴加完成给信号解锁
			pthread_mutex_lock(&mutex_tryworklock);
			if (lock_contorl1)
				TRY_REAGENT_UNLOCK1 = FALSE;
			if (lock_contorl2)
				TRY_REAGENT_UNLOCK2 = FALSE;
			if (lock_contorl3)
				TRY_REAGENT_UNLOCK3 = FALSE;
			if (lock_contorl4)
				TRY_REAGENT_UNLOCK4 = FALSE;
			if (pthread_mutex_unlock(&mutex_tryworklock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_tryworklock");
		}
	//	if ( operate_head->operate.reagent == STOP_OPERATE)
	
	}

	
	
if (SHELF_LOCK_WAY_NEW)
{
	if (lock_contorl1 == TRUE)
		GPIO_OutSet(CGLOCK1);
	else if ((mb_islockedreagent(0) == 0) && reagent_check[0].NEED_SCAN == FALSE
			&& reagent_check[0].NEED_MIX == FALSE  && reagent_check[0].NEED_CHECK == FALSE)
		{
		Isunlock[0] = 1;
		GPIO_OutClear(CGLOCK1);
				}
	
	if (lock_contorl2 == TRUE)
		GPIO_OutSet(CGLOCK2);
	else if ((mb_islockedreagent(1) == 0) && reagent_check[1].NEED_SCAN == FALSE
			&& reagent_check[1].NEED_MIX == FALSE && reagent_check[1].NEED_CHECK == FALSE)
		{Isunlock[1] = 1;
		GPIO_OutClear(CGLOCK2);
				}
	if (lock_contorl3 == TRUE)
		GPIO_OutSet(CGLOCK3);
	else if ((mb_islockedreagent(2) == 0) && reagent_check[2].NEED_SCAN == FALSE
			&& reagent_check[2].NEED_MIX == FALSE && reagent_check[2].NEED_CHECK == FALSE)
		{Isunlock[2] = 1;
		GPIO_OutClear(CGLOCK3);
				}
	
	if (lock_contorl4 == TRUE)
		GPIO_OutSet(CGLOCK4);
	else if ((mb_islockedreagent(3) == 0) && reagent_check[3].NEED_SCAN == FALSE
			&& reagent_check[3].NEED_MIX == FALSE && reagent_check[3].NEED_CHECK == FALSE)
		{Isunlock[3] = 1;
		GPIO_OutClear(CGLOCK4);
				}
}
else
{
	if (lock_contorl1 == TRUE)
		GPIO_OutClear(CGLOCK1);
	else if ((mb_islockedreagent(0) == 0) && reagent_check[0].NEED_SCAN == FALSE
			&& reagent_check[0].NEED_MIX == FALSE  && reagent_check[0].NEED_CHECK == FALSE)
		{Isunlock[0] = 1;
		GPIO_OutSet(CGLOCK1);
				}
	
	if (lock_contorl2 == TRUE)
		GPIO_OutClear(CGLOCK2);
	else if ((mb_islockedreagent(1) == 0) && reagent_check[1].NEED_SCAN == FALSE
			&& reagent_check[1].NEED_MIX == FALSE && reagent_check[1].NEED_CHECK == FALSE)
		{Isunlock[1] = 1;
		GPIO_OutSet(CGLOCK2);
				}
	if (lock_contorl3 == TRUE)
		GPIO_OutClear(CGLOCK3);
	else if ((mb_islockedreagent(2) == 0) && reagent_check[2].NEED_SCAN == FALSE
			&& reagent_check[2].NEED_MIX == FALSE && reagent_check[2].NEED_CHECK == FALSE)
		{
		Isunlock[2] = 1;
		GPIO_OutSet(CGLOCK3);
		}
	
	if (lock_contorl4 == TRUE)
		GPIO_OutClear(CGLOCK4);
	else if ((mb_islockedreagent(3) == 0) && reagent_check[3].NEED_SCAN == FALSE
			&& reagent_check[3].NEED_MIX == FALSE && reagent_check[3].NEED_CHECK == FALSE)
		{Isunlock[3] = 1;
		GPIO_OutSet(CGLOCK4);
				}
}
#ifdef BIG_VERSION
if(lock_contorl1 && Issetgreen[0])
{
	GetMixStationVal(5,0);//锁定
	Issetgreen[0] = 0;
}
	if(lock_contorl2 && Issetgreen[1])
		{
			GetMixStationVal(5,1);//锁定
			Issetgreen[1] = 0;
		}
	if(lock_contorl3 && Issetgreen[2])
		{
			GetMixStationVal(5,2);//锁定
			Issetgreen[2] = 0;
		}
	if(lock_contorl4 && Issetgreen[3])
		{
			GetMixStationVal(5,3);//锁定
			Issetgreen[3] = 0;
		}
for(i=0;i < 4; i++)
{
//	printf("Isunlock[i]=%d  reagent_check[i].STATE=%d Issetgreen[i]=%d\n",Isunlock[i], reagent_check[i].STATE, Issetgreen[i]);
	if(Isunlock[i] == 1 && reagent_check[i].STATE && !Issetgreen[i])		
	{
		GetMixStationVal(6,i);//
		Issetgreen[i] = 1;
	}
}
#endif

if (pthread_mutex_unlock(&head_lock) != 0)
	lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
	return 0;
	
}


  
  static double Get30Milimeter(int steps)
		 {
			 int maxStep = 1300;
			 double oneStepHeight = 0.098;//0.098 mm per step
			 return (maxStep - steps) * oneStepHeight;
		 }
  
		  static double Get30S1(double mm)
		 {
			 return 63.05 * pow(mm, 2) / 56.0 + 493.25 * mm;
		 }
  
		  static double Get30S2(double mm)
		 {
			 return 15.1 * pow(mm, 2) / 4.0 + 344.9 * mm;
		 }
  
		  static double Get30S3(double mm)
		 {
			 return 26.3 * pow(mm, 2) / 80.0 + 551.2 * mm;
		 }
		 

  static double Get30Result(int steps)
		 {
			 double mm = Get30Milimeter(steps);
			 if (mm >= 0 && mm <= 28)
				 return Get30S1(mm);
			 else if (mm > 28 && mm <= 31)
			 {
				 double ret = 0;
				 ret += Get30S1(28);
				 ret += Get30S2(mm) - Get30S2(28);
 
				 return ret;
			 }
			 else
			 {
				 if (mm > 71)
					 mm = 71;
				 double ret = 0;
				 ret += Get30S1(28);
				 ret += Get30S2(31) - Get30S2(28);
				 ret += Get30S3(mm) - Get30S3(31);
				 return ret;
			 }
		 }




// int _7mLMaxStepCount = 1311; //理论值
// int _7mLcolumnCount = 1261;

//  int _7mLMaxStepCount = 1315;//卡尺测量值
// int _7mLcolumnCount = 1265;

#define M_PI 3.14159265358979323846 
#define mis_val 20 //机械臂和试剂仓底座误差
#define leave_val  367.8; //理论367.8球冠体积//实际值400
  int _7mLcolumnCount = 1276 - mis_val;//到达球冠表面液面
 double oneStepHeight = 0.098;
 int _6mLcolumnCount = 1285 - mis_val;//到达球冠表面液面
#define _6mLleave_val  241.8;

 double GetVolume7(int steps)
 {
 	int _7mLMaxStepCount = _7mLcolumnCount + 50;//探针测量值
 	double h = oneStepHeight *  (_7mLMaxStepCount - steps - 50) ;//圆台高
 	double qgh = oneStepHeight *  (_7mLMaxStepCount - steps) ;//圆台高
	double R = 6.35 + 0.25 / 72.8 * h;
	double r = 6.35;

	 if (steps >= _7mLMaxStepCount) return 0;

	if (steps >= _7mLcolumnCount) 

		return M_PI * qgh * qgh * (6.35 - qgh / 3);//球冠体积
	
	double c = M_PI * h *( R * R + R * r + r * r) / 3;//圆台体积

	 return c + leave_val; //
 }


 static double GetVolume6(int step)
{
 	int mainMaxStepCount = _6mLcolumnCount + 50;//探针测量值
// 	int error_step = _6mLcolumnCount  - 35 / oneStepHeight;//929
	int error_step = 907;
 	double h = oneStepHeight *  (mainMaxStepCount - step - 50) ;//圆台高
 	double qgh = oneStepHeight *  (mainMaxStepCount - step) ;//圆台高
	double R = 5 + 0.001745 * h;
	double r = 5;
	double error_val = 0;
	double error_R = 4.5 + 0.014285 * h;
	double error_r = 4.5;
	
	
	 if (step >= mainMaxStepCount) return 0;

	if (step >= _6mLcolumnCount) 

		return M_PI * qgh * qgh * (5 - qgh / 3);//球冠体积

	if (step > error_step)
	{
		 error_val =  M_PI * h *( error_R * error_R + error_R * error_r + error_r * error_r) / 3;
		return error_val + _6mLleave_val;
	}

	error_val = M_PI * oneStepHeight*(_6mLcolumnCount - error_step) *( error_R * error_R + error_R * error_r + error_r * error_r) / 3;
	double good_val =  M_PI * oneStepHeight*(error_step - step) *25;
	return  error_val + good_val + _6mLleave_val;
 }	
	//double c = M_PI * h *( R * R + R * r + r * r) / 3;//圆台体积
//	double c = M_PI * h *25;//按圆柱算70mm高度少130ul
	// return c + _6mLleave_val; //




//#define M_VAL(S) ( (1307 - S) * 0.098 ) //高度mm S为步数 1311
//#define M_VAL(S) ( (1292 - S) * 0.098 ) //高度mm S为步数 理论值1292
#define M_VAL(S) ( (1288 - S) * 0.098 )// 2ML打底后取最低高度值为1288


#define XJ(h) ( (0.00785*h)*2 ) //底边长度变化h 为高度
#define SJ(x) ( (x + 26.68) * (x + 20.66))//截面积变化x为底边长度

//以上为试剂瓶不考虑槽

#define C_X1J(h) ((0.565 - 0.02123*h)*2 ) //底边长度变化h 为高度 (上底)
#define C_X2J(h) ((0.37486 - 0.0213*h)*2 ) //底边长度变化h 为高度(下底)
#define C_SJ(x1,x2,h) ( (x1 + 7.32 + x2 + 2.37) * h / 2)//截面积变化x为底边长度,h高度
//以上为槽

#define TV(s,sd,h) ( s + sd +  sqrt(s * sd)) * h / 3 

/*
double TV(double s,double sd,double h) 
{

	//double val = pow(s + sd,0.5); 

return ( ( s + sd +  sqrt(s + sd)) * h / 3 );//台体体积s为变化的截面积sd为底部截面积
}
*/
/*
  static double TV(double s, double sd, double h)
        {
            return (s + sd + sqrt(s * sd)) * h / 3; //台体体积s为变化的截面积sd为底部截面积
        }

*/
  static double GetVolume30other(int steps, int subtracts, double originals, BOOL batching)
		 {
			 if (steps >= 1292) return 0;
			 double h = (1292 - steps) * oneStepHeight;
			 double res = 0;
 
			 double x = 0.00785 * h * 2; //底边长度变化h 为高度
			 double y = (x + 26.68) * (x + 20.66); //截面积变化x为底边长度
			 double s_sj = y;//试剂瓶截面积变
			 double a = (0.565 - 0.02123 * h) * 2; //底边长度变化h 为高度 (上底)
			 double b = (0.37486 - 0.0213 * h) * 2; //底边长度变化h 为高度(下底)
			 double c_sj = (a + 7.32 + b + 2.37) * h / 2;//槽截面积变化 //截面积变化x为底边长度,h高度
 
 
			 if (h <= 30.79)//有槽
			 {
				 double hc = TV(c_sj, 14.4625, h);
				 if (hc > 276) hc = 276;
				 res = TV(s_sj, 551.2088, h) - hc;
			 }
			 else //槽以上
			 {
				 res = TV(s_sj, 551.2088, h) - 276;//槽体积276
			 }
 
	//		 LogHelper.LogDebug(string.Format("试剂吸液测量命令【2】:步骤{0}；", steps), string.Format("试剂计算后值：{0}", res));
 			printf("试剂吸液测量命令 steps=%d  试剂计算后值 res=%lf\n",steps,res);
			 if (res > 30000)
				 res = 30000;
 
			
		 }



 double GetVal30(int step)
{
	
	double h = M_VAL(step),hc,res = 0;
	if (h < 0) return 0;
	double s_sj = SJ(XJ(h));//试剂瓶截面积变
	double c_sj = C_SJ(C_X1J(h),C_X2J(h),h);//槽截面积变化
	
	printf("XJ(h)=%lf\n",XJ(h));

	printf("C_X1J(h)=%lf\n",C_X1J(h));
	printf("C_X2J(h)=%lf\n",C_X2J(h));

	printf("s_sj  = %lf  c_sj =%lf h =%lf\n",s_sj ,c_sj ,h);
	printf("TV(s_sj, 551.2088 ,h)=%lf TV(c_sj, 14.4625 ,h)=%f",TV(s_sj, 551.2088 ,h),TV(c_sj, 14.4625 ,h));
	if (h <= 30.79)//有槽
	{	
		hc = TV(c_sj, 14.4625 ,h);
		if(hc > 276) hc = 276;
		
		res = ( TV(s_sj, 551.2088 ,h) - hc);
	}
	else //槽以上
	{
		res = TV(s_sj, 551.2088 ,h) - 276 ;//槽体积276
	}

//	if (res > 30000)
	//	return 30000;
	
	return res;
}


/******************************************************************************
*
* Function Name  : mb_checkshelfreagent
* Description    : 测试剂架试剂量
* 					 
* Input		   :unsigned int reagent_num 试剂架次,unsigned int ordArray_plate[][2]试剂坐标
				,unsigned char *check_reagent 需要测试剂的标识数据
* Output		   :
* Return		   :  None
*******************************************************************************/
void mb_checkshelfreagent(unsigned int reagent_num,unsigned int ordArray_plate[][2],unsigned char *check_reagent)
{
	sr_cmdstruct_t CommandElemt;
	int i=0, check_cnt = 0,ZX_res = 0;
	CommandElemt.srdevaddr = ARM_ADDR;
//	unsigned int eenetevent=REAGENT_SEND;
	char TCP_Buffer[50] = {0};

sleep(1);
//return;
	printf("in mb_checkshelfreagent\n");
	memset(ReportArrayData,0,sizeof(ReportArrayData));
	//ReportArrayData[0] = reagent_num;



	/*
	 if (i >= 9)
		return;
 
	
	if (last_cabin_reagent != REAGENT_WATER && last_cabin_reagent != REAGENT_WASH)
		mb_procwashprobe(REAGENT_WATER);
	else
	{	
		tp_washchange(TRUE);
		if (last_cabin_reagent == REAGENT_WATER)
			mb_probewash_c(WATERPORT);
		else if (last_cabin_reagent == REAGENT_WASH )
			mb_probewash_c(WASHPORT);
		tp_washchange(FALSE);
	}
*/	

	for(i = 0;i < 9; i++)
	{	
		mb_monitdoorstate();
	//	 printf("check_reagent[check_cnt]=\n");
		
	//		printf(" %d ",check_reagent[check_cnt]);
/*	
		//不需要测或没扫到
		if (check_reagent[i] == 0)
			continue;
		
		if ((ordArray_plate[i][0] == 0) && (ordArray_plate[i][1] == 0))
			continue;
	*/	
//if (i <6 )	//TEST
//	continue;
/*
	CommandElemt.srdevaddr = PUMP_ADDR;
	sprintf(CommandElemt.cmdbuf, "S%dI%dP%dR", SYSPEED_AIR,PROBEPORT,SYSTEP_AIR);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
	*/
	usleep(ASPIRATE_T);
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_plate[i][0], ordArray_plate[i][1], MOV_ZH);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		
			sprintf(CommandElemt.cmdbuf, "ZA %d", MOV_ZH + 100);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
//usleep(300000);			
		
		flg_getedserailarr = TRUE;
		sprintf(CommandElemt.cmdbuf, "ZX 0 0 %d", 1320);
		//sprintf(CommandElemt.cmdbuf, "ZX 0 0 %d", LIQUID_ZMAX);////	sprintf(CommandElemt.cmdbuf, "ZA 500");
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		if ((ZX_res = sb_waitingframeaswer(&CommandElemt)) < 0)
		{
			if (ZX_res == -3)
			{
				sprintf(CommandElemt.cmdbuf, "ZI");
				if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
							CommandElemt.srdevaddr , 1, 0, 1) > 0)
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
				else
					printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
				sb_waitingframeaswer(&CommandElemt);

				return;
			}
			else
				ReportArrayData[i] = 0XFFFFFFFF;//没测到
		}
		else
			ReportArrayData[i] = serail_dataarr;
			
		printf("Arraydata=%d\n",serail_dataarr);
	
		CommandElemt.srdevaddr = ARM_ADDR;
		if (ReportArrayData[i] != 0XFFFFFFFF)
		{
		sprintf(CommandElemt.cmdbuf, "ZS -%d %d", 200, LIQUID_SPEED);//缓慢上升 当>500步时z轴回到500步位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
						CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfaspirate]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		}
		sprintf(CommandElemt.cmdbuf, "ZA %d",MOV_ZH);
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_checkshelfreagent]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);

			TCP_Buffer[0] = i + (reagent_num-1)*9;
			memcpy(&TCP_Buffer[1],&ReportArrayData[i],4);
//	nt_sendpacketdata(REAGENT_SEND, TCP_Buffer, sizeof(ReportArrayData) + 1);
	
#if 0		
		if (last_cabin_reagent != REAGENT_WATER && last_cabin_reagent != REAGENT_WASH)
			mb_procwashprobe(REAGENT_WATER);
		else
		{
			tp_washchange(TRUE);
			if (last_cabin_reagent == REAGENT_WATER)
				mb_probewash_c(WATERPORT);
			else if (last_cabin_reagent == REAGENT_WASH )
				mb_probewash_c(WASHPORT);
			tp_washchange(FALSE);
		}
#endif
}
	return ;
	/*
	ReportArrayData[0] = 1288;
	ReportArrayData[1] = 1285;
	ReportArrayData[2] = 1286;
	ReportArrayData[3] = 1288;
	ReportArrayData[4] = 1282;
	ReportArrayData[5] = 1282;
	ReportArrayData[6] = 1288;
	ReportArrayData[7] = 1284;
	ReportArrayData[8] = 1289;
	
*/
//	for (i = 0; i < 9;i++)
	{
	//	ReportArrayData[i] += i;
		printf("ReportArrayData[%d]=%d ",i,ReportArrayData[i]);
		printf(" reagent_val=%lf ",GetVal30(ReportArrayData[i]));//+ i 每隔加误差1
		GetVolume30other(ReportArrayData[i],0,0,0);
//	printf(" reagent_val=%lf ",GetVolume6(ReportArrayData[i]));
//	printf(" reagent_val=%lf ",GetVolume7(ReportArrayData[i]));

//	printf(" reagent_val=%lf ",GetVolume6(ReportArrayData[i]));
	}


	
//	while(1) sleep(1);
	
//	nt_sendpacketdata(REAGENT_SEND, TCP_Buffer, sizeof(ReportArrayData) + 1);
	printf("out of mb_checkshelfreagent\n");

}

void mb_shelfscanning(unsigned int shelf_num)//,unsigned char* mini_recieve_code)
{
	sr_cmdstruct_t CommandElemt;
	int i=0;
	unsigned int ordArray_plate[10][2];
	stminibd_sendpacket cmd;
	unsigned int X_Array = 0;


//	stminibd_cmdlist* pcmd_head_p = NULL;
//	pthread_mutex_t* mlock_temp = NULL;
//	unsigned int eenetevent=SCANNER_SEND;
//	return;
	if(flg_intosleep)
		return 0;

	printf("in mb_shelfscanning %d\n",shelf_num);

#ifndef BIG_VERSION
				sleep(2);
		#endif

 /*
while(i++ < 100)
{
	bs_packetshelfstreach(80 + shelf_num * 10,&cmd);
	
	pthread_mutex_lock(&mutex_mlock);
	set_minicmd(pcmd_head,cmd); 
	if (pthread_mutex_unlock(&mutex_mlock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
	while((*mini_work_finished))//确保miniBoard线程已置FALSE
		usleep(1000);
		sleep(1);
	while(!(*mini_work_finished))//动作完成
		usleep(200000);

	bs_packetshelfstreach(  shelf_num * 10 - 1,&cmd);
	
	pthread_mutex_lock(&mutex_mlock);
	set_minicmd(pcmd_head,cmd); 
	if (pthread_mutex_unlock(&mutex_mlock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
	while((*mini_work_finished))//确保miniBoard线程已置FALSE
		usleep(1000);
		sleep(1);
	while(!(*mini_work_finished))//动作完成
		usleep(200000);
	
}

*/
/*
	sleep(5);
	while(i++ < 200)
	{	
	if ((i % 10) == 0)
		mb_probewash_c(WATERPORT);
	testslide(&mini_work_finished[2]);
	}

	*/
	if (shelf_num == 1)
	{

	//	X_Array = 400;tecan
	X_Array = 350 + scanoffset;//430;
		memcpy(ordArray_plate,ordArray_plate1,(sizeof(ordArray_plate1)) / 3);
	}
	else if (shelf_num == 2)
	{
		memcpy(ordArray_plate,&ordArray_plate1[10],(sizeof(ordArray_plate1)) / 3);
		
	//	X_Array = 1165;//tecan
	#ifdef BIG_VERSION
	X_Array = 1165 + scanoffset;
	#else
	X_Array = 1115 + scanoffset;
	#endif
	}
	else if (shelf_num == 3)
	{
	//	X_Array = 1930;//tecan
		#ifdef BIG_VERSION
	X_Array = 1980 + scanoffset;
	#else
		X_Array =1880 + scanoffset; //1945;
		#endif
		memcpy(ordArray_plate,&ordArray_plate1[20],(sizeof(ordArray_plate1)) / 3);
	}
	else
		return;

#ifdef BIG_VERSION
	
	
//	ArmCabinCmdList[2].cmd = ArmCabinKey;
	
#else

	
//	bs_packetshelfstreach( (shelf_num - 1) * 10,&cmd);//lock
	bs_packetshelfstreach( (shelf_num + 2) * 10,&cmd);//150ul 凸轮误差先到150ul位置扫描结束再回去
	pthread_mutex_lock(&mutex_mlock);	//1.29号补的
	set_minicmd(pcmd_head,cmd);
	if (pthread_mutex_unlock(&mutex_mlock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");

#endif
	sleep(1);
	nt_sendpacketdata(SHELF_SCAN__START, (char*)&shelf_num, 1);

	
	pthread_mutex_lock(&tp_threadmarm);
	CommandElemt.srdevaddr = ARM_ADDR;

#if 1
	for(i = 0;i < 10; i++)
{	
	mb_monitdoorstate();
	
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d",X_Array, ordArray_plate[i][1], MOV_ZH);//到达玻片位置
//		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_plate[i][0] + distance_scan, ordArray_plate[i][1], MOV_ZH);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_shelfscanning]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_shelfscanning]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	//	usleep(500000);
		sc_getscode(i + (shelf_num-1) * 10,FALSE);
		usleep(100000);//扫描时间久给其他线程分配CPU资源
	}
	
	/*
	memcpy(TCP_Buffer,&eenetevent,4); 
	memcpy(&TCP_Buffer[4],scan_OCR_data,scan_OCR_len);
	while(flg_netdisconnect) sleep(1);
	pthread_mutex_lock(&netsend_lock);
	if (send(local_fd, TCP_Buffer, sizeof(eenetevent) + scan_OCR_len, 0) < 0)
		perror("write net\n");
	pthread_mutex_unlock(&netsend_lock);
*/

	//	usleep(100000);
	
#endif
nt_sendpacketdata(SHELF_SCAN_END, (char*)&shelf_num, 1);

#ifdef BIG_VERSION


ArmCabinCmdList[shelf_num-1].cmd = ArmCabinKey;

#else
		bs_packetshelfstreach( (shelf_num - 1) * 10,&cmd);//150ul 凸轮误差先到150ul位置扫描结束再回去
		pthread_mutex_lock(&mutex_mlock); //1.29号补的
		set_minicmd(pcmd_head,cmd);
		if (pthread_mutex_unlock(&mutex_mlock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");

		

	sleep(2);

		while(!mini_work_finished[shelf_num - 1])
		usleep(10000);

		memset(&cmd,0,sizeof(cmd));
		cmd.cmd = RELOAD;
		cmd.minicmd_buffer[3] = (unsigned char)RELOAD;
		cmd.minicmd_buffer[4] = shelf_num;
		cmd.minicmd_num=2;
		
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		if (pthread_mutex_unlock(&mutex_mlock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
		printf("RELOAD finished\n");
#endif

/*		
	memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = 37;	
		cmd.minicmd_buffer[5] = 0;	
		cmd.minicmd_buffer[1 + 5] = 1;
		cmd.minicmd_num = 13;
		pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
		pthread_mutex_unlock(&mutex_mlock3);
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);
		sleep(1);



	memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = 37;	
		cmd.minicmd_buffer[5] = 2;	
		cmd.minicmd_buffer[3 + 5] = 1;
		cmd.minicmd_num = 13;
	pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
		pthread_mutex_unlock(&mutex_mlock3);
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);
		
	memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = 37;	
		cmd.minicmd_buffer[5] = 4;	
		cmd.minicmd_buffer[4 + 5] = 1;
		cmd.minicmd_num = 13;
	pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
		pthread_mutex_unlock(&mutex_mlock3);
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);

		memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = 37;	
		cmd.minicmd_buffer[5] = 5;	
		cmd.minicmd_buffer[5 + 5] = 1;
		cmd.minicmd_num = 13;
		pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
		pthread_mutex_unlock(&mutex_mlock3);
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);

		memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = 37;	
		cmd.minicmd_buffer[5] = 0;	
		cmd.minicmd_buffer[6 + 5] = 1;
		cmd.minicmd_num = 13;
		pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
		pthread_mutex_unlock(&mutex_mlock3);
		pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);
	sleep(1);
	memset(&cmd,0,sizeof(cmd));
	cmd.cmd = WORK_FINISH;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;
	cmd.minicmd_num=1;
	pthread_mutex_lock(&mutex_mlock3);
		set_minicmd(pcmd_head3,cmd);
	pthread_mutex_unlock(&mutex_mlock3);
	pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);
	

	
	memset(&cmd,0,sizeof(cmd));
	cmd.cmd = RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;
	cmd.minicmd_num=1;
	pthread_mutex_lock(&mutex_mlock3);
	set_minicmd(pcmd_head3,cmd);
	pthread_mutex_unlock(&mutex_mlock3);
	pthread_mutex_lock(&mutex_mlock);
		set_minicmd(pcmd_head,cmd);
		pthread_mutex_unlock(&mutex_mlock);
	*/
	if (pthread_mutex_unlock(&tp_threadmarm) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
	printf("scanner_test finished*********************\n");
}

/****************将流程中的试剂信息最高位置1***由于锁定时候判断***并将有效试剂加入outside***********/
void mb_cancelreagentwork(unsigned char reagent_num)
{
	operate_head_list* 	operate_head = NULL;
	operate_t* operate_p = NULL;
	unsigned char i = 0,j=0, regt_cnt = 0,start_reagent=0;
//	unsigned int eenetevent=SET_REAGENT_DISABLE;
	char TCP_Buffer[20] = {0};
	reagentoutside_list * reagentoutside_head_tmp = reagentoutside_head, *reagentoutside_head_lst = NULL;

	start_reagent = (reagent_num -1) * 9;
	
	for (i = 0; i < 9;i++)
	{
		if (strlen(reagent_code[start_reagent + i].code) != 0)//有试剂
		{
			reagentoutside_head_tmp = reagentoutside_head;
			do
			{	//already exist
				if (strcmp(reagent_code[(reagent_num -1) * 9 + i].code, reagentoutside_head_tmp->reagent_info.code) == 0)
					break;

				reagentoutside_head_lst = reagentoutside_head_tmp;
				reagentoutside_head_tmp = reagentoutside_head_tmp->next;
			}
			while(reagentoutside_head_tmp != NULL);

			if (reagentoutside_head_tmp == NULL)//not exist
			{
				while((reagentoutside_head_tmp = reagentoutside_head_lst->next 
					= (reagentoutside_list*)malloc(sizeof(reagentoutside_list))) == NULL)
				{
					sleep(1);
					printf("malloc error reagentoutside_list\n");
				}
				memcpy(&reagentoutside_head_tmp->reagent_info, &reagent_code[start_reagent + i], sizeof(reagent_t));
				reagentoutside_head_tmp->next = NULL;
			}
		}
	}
		
	reagentoutside_head_tmp = reagentoutside_head;
	printf("outside code \n");
		do
		{
			printf(" %s ", reagentoutside_head_tmp->reagent_info.code);
			reagentoutside_head_tmp = reagentoutside_head_tmp->next;
		}
		while(reagentoutside_head_tmp != NULL);
		
	printf("In mb_cancelreagentwork***************\n");
	pthread_mutex_lock(&head_lock);
	for (i = 0; i < 3;i++)
	{
		if (i == 0)
			operate_head = operate_head1;
		else if (i == 1)
			operate_head = operate_head2;
		else if (i == 2)
			operate_head = operate_head3;

		if (operate_head->operate.reagent == STOP_OPERATE)
			continue; 
		for (regt_cnt = 0; regt_cnt < 9; regt_cnt++)
		{
			
			for(j = 0; j < 10; j++)
			{
				if (mix_DAB[i].ordArrayA[j] != 0)
				{
				  if (strcmp(mix_DAB[i].reagentA[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_DAB[i].ordArrayA[j] |= 0X80; 
				}
				if (mix_DAB[i].ordArrayB[j] != 0)
				{
					if (strcmp(mix_DAB[i].reagentB[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  		mix_DAB[i].ordArrayB[j] |= 0X80;
				}
				 
				if (mix_SECEND[i].ordArrayA[j] != 0)
				{
				  if (strcmp(mix_SECEND[i].reagentA[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_SECEND[i].ordArrayA[j] |= 0X80;
				  
				}
				if ((mix_SECEND[i].ordArrayB[j] != 0))
					{
				  if (strcmp(mix_SECEND[i].reagentB[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_SECEND[i].ordArrayB[j] |= 0X80;
					}
				
			
			}
		}
		while(operate_head != NULL)
		{
			operate_p = &(operate_head->operate);
			while(operate_p != NULL && operate_p->reagent != STOP_OPERATE)
			{
		//		if (operate_p->reagent < REAGENT_CASE)
				{
					for (regt_cnt = 0; regt_cnt < 9; regt_cnt++)
					{
						
						if (strcmp(operate_p->reagent_info.code, reagent_code[start_reagent + regt_cnt].code) == 0
							&& reagent_code[start_reagent + regt_cnt].code[0]!=0  && operate_p->reagent < REAGENT_CASE)
						{
							printf(" reagechaned %d ",operate_p->reagent);		
							 operate_p->reagent |= 0X80;
							 break;
						}
					}
				}

		
				
				operate_p = operate_p->next;
			}
			
			operate_head = operate_head->next_head;
		}
	}

//	mb_printfoperatelist(operate_head);
	if (pthread_mutex_unlock(&head_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");

	TCP_Buffer[0] = reagent_num;	
	nt_sendpacketdata(SET_REAGENT_DISABLE, TCP_Buffer, 1);
	memset(&reagent_code[start_reagent], 0,(sizeof(reagent_t)) * 9);


for (i = 0; i < 36;i++)
	printf(" %s ", reagent_code[i].code);

printf("Out of mb_cancelreagentwork***************\n");
}

int CheckRemove(char reagent_index,reagent_t* p_r,reagent_t* s_r)
{
	char TCP_Buffer[24] ={0};
	
	if (reagent_code[ reagent_index].reagent_kind[0] == 0)
	{
		printf("reagent shelf removed reagent num=%d\n",reagent_index);
		
		TCP_Buffer[0] = 0;
		memcpy(&TCP_Buffer[1],0,0);
		nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
		return -1;
	}
	else
		memcpy(p_r,s_r,sizeof(reagent_t));
	
	return 0;
}
int nt_recvchangereagentinfo( char *netbuf_read,int netread_len)
{
	operate_head_list* operate_head_p;
	operate_t * operate_p = NULL;
	int reagent_index = 2,i;
	char shelf_num = netbuf_read[0];
	char plate_num = netbuf_read[1];//玻片序号0~9
		char TCP_Buffer[24] ={0};
	char reagent_cnt = 0;
	/*
	char temp[20] = {0};
	memcpy(temp, &netbuf_read[2],10);
	netbuf_read[2] = 9;
	memcpy(&netbuf_read[3],temp,10);
		netread_len++;
	*/
	
		printf("in nt_recvchangereagentinfo netread_len=%d\n", netread_len);
	lprintf(log_my, INFO,"in nt_recvchangereagentinfo netread_len=%d\n", netread_len);
		{
					for (i = 0; i < netread_len; i++)
						{
							printf(" %d ", netbuf_read[i]); 
							lprintf(log_my, INFO," %d ", netbuf_read[i]);
						}
						printf("\n");
			}
		

		if (netbuf_read[0] == 0)
		operate_head_p = operate_head1;
	else if (netbuf_read[0] == 1)
		operate_head_p = operate_head2;
	else if (netbuf_read[0] == 2)
		operate_head_p = operate_head3;
	else
		perror("nt_recvchangereagentinfo\n");
	mb_printfoperatelist(operate_head_p);

	while(operate_head_p!= NULL)//找玻片位子
	{
		if ((operate_head_p->operate.plate_num) % 10 == netbuf_read[1])
		{
			break;
		}
		operate_head_p = operate_head_p->next_head;
	}

	if (operate_head_p == NULL)
		perror("nt_recvchangereagentinfo position not found\n");

	operate_p = &(operate_head_p->operate);


	reagent_index = 2;
	while(operate_p != NULL)
	{
		
			
				if (operate_p->reagent == REAGENT_DAB)
				{
					printf("dabfind reagent_index=%d\n", reagent_index);
					 memcpy(&mix_DAB[shelf_num].reagentA[plate_num],
						&reagent_code[ netbuf_read[reagent_index]] ,sizeof(reagent_t));	
						mix_DAB[shelf_num].ordArrayA[plate_num] =netbuf_read[reagent_index];		
						memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
					reagent_index++;	
				}
				else if (operate_p->reagent == REAGENT_SECEND)
				{
					
						
					printf("secendfind reagent_index=%d\n", reagent_index);
					memcpy(&mix_SECEND[shelf_num].reagentA[plate_num],
								   &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));  
					  mix_SECEND[shelf_num].ordArrayA[plate_num] =netbuf_read[reagent_index];	   
					  memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
					reagent_index++;
				}	
				else if ((operate_p->reagent & 0X7F) < REAGENT_CASE  )
				{
					printf("operate_p->reagent=%d\n", operate_p->reagent);
					
					printf("reagentfind reagent_index=%d\n", reagent_index);
					memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
					operate_p->reagent = netbuf_read[reagent_index];
					reagent_index++;
				}

				if(reagent_index > netread_len)
					perror("reagent_index over\n");
			  
		operate_p = operate_p->next;
	}
		
#if 0
	while(reagent_index < netread_len)
	{
			if (reagent_code[ netbuf_read[reagent_index]].reagent_kind[0] == 0)
			{
				while(operate_p != NULL)
				{
					if (((operate_p->reagent & 0X7F) < REAGENT_CASE || operate_p->reagent == REAGENT_DAB
						||operate_p->reagent == REAGENT_SECEND) && operate_p->reagent_info.special_num != H2O2
						 && operate_p->reagent_info.special_num != RED2&& operate_p->reagent_info.special_num != FR2
						  && operate_p->reagent_info.special_num != GREEN2 
						   && operate_p->reagent_info.special_num != AP2)
						reagent_cnt++;
					operate_p = operate_p->next;
				}
				lprintf(log_my, INFO,"reagent_cnt=%d reagent_index=%d\n", reagent_cnt,reagent_index);

				printf("reagent_cnt=%d reagent_index=%d\n", reagent_cnt,reagent_index);
				if (reagent_cnt >= (netread_len - reagent_index))
				{
					printf("reagent shelf removed reagent_index=%d\n",reagent_index);
					
					TCP_Buffer[0] = 0;
					memcpy(&TCP_Buffer[1],0,0);
					nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
					return -1;
				}
			}
			reagent_index++;
	}

	
	

	operate_p = &(operate_head_p->operate);
	while(operate_p != NULL)//找试剂信息并替换
	{
		
			reagent_index = 2;
		if (operate_p->reagent == REAGENT_DAB)
		{
			while(reagent_code[netbuf_read[reagent_index]].special_num != DAB)	
				if(reagent_index++ > netread_len)
					lprintf(log_my, INFO,"REAGENT_DAB over");
			printf("dabfind reagent_index=%d\n", reagent_index);
			 memcpy(&mix_DAB[shelf_num].reagentA[plate_num],
				&reagent_code[ netbuf_read[reagent_index]] ,sizeof(reagent_t));	
				mix_DAB[shelf_num].ordArrayA[plate_num] =netbuf_read[reagent_index];		
				memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
				
		}
		else if (operate_p->reagent == REAGENT_SECEND)
		{
			while(reagent_code[netbuf_read[reagent_index]].special_num != RED1 &&
				reagent_code[netbuf_read[reagent_index]].special_num != GREEN1 &&
				reagent_code[netbuf_read[reagent_index]].special_num != FR1 &&
				reagent_code[netbuf_read[reagent_index]].special_num != AP1)
					if(reagent_index++ > netread_len)
					lprintf(log_my, INFO,"REAGENT_SECEND over");
				
			printf("secendfind reagent_index=%d\n", reagent_index);
			memcpy(&mix_SECEND[shelf_num].reagentA[plate_num],
						   &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));  
			  mix_SECEND[shelf_num].ordArrayA[plate_num] =netbuf_read[reagent_index];	   
			  memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
		}	
		else if ((operate_p->reagent & 0X7F) < REAGENT_CASE  )
		{
			printf("operate_p->reagent=%d\n", operate_p->reagent);
			while (1 )
				{
				printf("%s--%s--%d--%d\n",reagent_code[netbuf_read[reagent_index]].reagent_kind,
					operate_p->reagent_info.reagent_kind,reagent_index,netbuf_read[reagent_index]);
				if(strcmp(reagent_code[netbuf_read[reagent_index]].reagent_kind,
				operate_p->reagent_info.reagent_kind) == 0)
				break;
				if(reagent_index++ > netread_len)
					lprintf(log_my, INFO,"REAGENT_CASE over");
					}
			printf("reagentfind reagent_index=%d\n", reagent_index);
			memcpy(&(operate_p->reagent_info), &reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
			operate_p->reagent = netbuf_read[reagent_index];
		}

		operate_p = operate_p->next;
	}
#endif

//	printf(" after reagent_index=%d\n", reagent_index);
//	lprintf(log_my, INFO," after reagent_index=%d\n", reagent_index);
	/*********************稀释液******************************/
	reagent_index = 2;

	while(reagent_index < netread_len)
	{
		if (reagent_code[netbuf_read[reagent_index]].special_num == H2O2	)// 稀释液
		{
			mix_DAB[shelf_num].ordArrayB[plate_num] = netbuf_read[reagent_index]; 
			memcpy(&mix_DAB[shelf_num].reagentB[plate_num],
			&reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
		}
		else if (reagent_code[netbuf_read[reagent_index]].special_num == RED2	||
			reagent_code[netbuf_read[reagent_index]].special_num == FR2 ||
			reagent_code[netbuf_read[reagent_index]].special_num == GREEN2 ||
			reagent_code[netbuf_read[reagent_index]].special_num == AP2)// 稀释液
		{
			mix_SECEND[shelf_num].ordArrayB[plate_num] = netbuf_read[reagent_index]; 
			memcpy(&mix_SECEND[shelf_num].reagentB[plate_num],
			&reagent_code[ netbuf_read[reagent_index]],sizeof(reagent_t));
		}
			reagent_index++;
	}
	if(reagent_index >= netread_len)
					lprintf(log_my, INFO,"H2O2 over");

		mb_printfoperatelist(operate_head_p);

	return 0;
		
}
# if 0
int nt_recvchangereagentinfo(operate_head_list* operate_head,const char *netbuf_read,
						int netread_len,char shelf_num)
{
	int i=0;
	operate_t * operate_p = NULL;
	operate_head_list* operate_head_p = operate_head;
	char TCP_Buffer[24] ={0};
	if (netread_len < 10)	
		return 0;
printf("in nt_recvchangereagentinfo netread_len=%d\n", netread_len);
//	if (NEED_PRINTF)
		{
			for (i = 0; i < netread_len; i++)
					printf(" %d ", netbuf_read[i]); 
				printf("\n");
		}
	mb_printfoperatelist(operate_head);


	i = 0;
	while(operate_head_p != NULL)
	{
		operate_p = &(operate_head_p->operate); 
		printf("netbuf_read[i + 6]=%d operate_p->plate_num=%d", netbuf_read[i + 6],operate_p->plate_num);
		if ( (netbuf_read[i + 6] % 10) == ((operate_p->plate_num) % 10))//同一片
		{
			while(operate_p != NULL)
			{
				printf("REAGENT_CASENetReadBuffer[i]=%d\n", netbuf_read[i]);
				if (netbuf_read[i] >= REAGENT_CASE)
				{
					i += 7;
					continue;
				}

				if ((operate_p->reagent & 0X7F) >=REAGENT_CASE && (operate_p->reagent & 0X7F) < REAGENT_DAB)
				{
					operate_p = operate_p->next;
					continue;
				}
				
				
				{
				/************************稀释液******************************/
					if (reagent_code[netbuf_read[i]].special_num == H2O2 	)// 稀释液
					{
						mix_DAB[shelf_num].ordArrayB[netbuf_read[i + 6] % 10] = netbuf_read[i];	
						memcpy(&mix_DAB[shelf_num].reagentB[netbuf_read[i + 6] % 10],
								&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
						i += 7; 
					}

					 if(reagent_code[netbuf_read[i]].special_num == RED2 ||
					reagent_code[netbuf_read[i]].special_num == FR2 ||
					reagent_code[netbuf_read[i]].special_num == GREEN2)
					{
						mix_SECEND[shelf_num].ordArrayB[netbuf_read[i + 6] % 10] = netbuf_read[i];	
						memcpy(&mix_SECEND[shelf_num].reagentB[netbuf_read[i + 6] % 10],
								&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
						i += 7;
					}
					/******************************************************/
					printf("operate_p->reagent=%d,(operate_p->reagent & 0X7F)=%d,",operate_p->reagent,(operate_p->reagent & 0X7F));
					
				if (strcmp(operate_p->reagent_info.reagent_kind, reagent_code[netbuf_read[i]].reagent_kind) != 0)//是否同种
					{
						printf("operate_p->reagent_info.reagent_kind=%s\n",operate_p->reagent_info.reagent_kind);
					//	operate_p = operate_p->next;
						if(strlen(reagent_code[ netbuf_read[i]].reagent_kind) == 0)//防止所替换的试剂架拔出
							operate_p = operate_p->next;
						
							i += 7;
							continue;
						
					}
				
						memset(&(operate_p->reagent_info), 0, sizeof(reagent_t));				
						operate_p->reagent = netbuf_read[i];

							
					 if (reagent_code[netbuf_read[i]].special_num == DAB)	
				 	{
				 		
						mix_DAB[shelf_num].ordArrayA[netbuf_read[i + 6] % 10] = netbuf_read[i];
						memcpy(&mix_DAB[shelf_num].reagentA[netbuf_read[i + 6] % 10],
							&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
						operate_p->reagent = REAGENT_DAB;
				//		mix_DAB[shelf_num].tep_num++;
				 	}
					if (reagent_code[netbuf_read[i]].special_num == RED1 ||
					reagent_code[netbuf_read[i]].special_num == FR1 ||
					reagent_code[netbuf_read[i]].special_num == GREEN1)
					{
					mix_SECEND[shelf_num].ordArrayA[netbuf_read[i + 6] % 10] = netbuf_read[i];
					memcpy(&mix_SECEND[shelf_num].reagentA[netbuf_read[i + 6] % 10],
						&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
					operate_p->reagent = REAGENT_SECEND;
				//	mix_SECEND[shelf_num].tep_num++;
					}

					
					if (strlen(reagent_code[ netbuf_read[i]].reagent_kind) != 0)//接收时试剂被拿掉
						memcpy(&(operate_p->reagent_info),&reagent_code[ netbuf_read[i]],sizeof(reagent_t));
					else
					{
						printf("reagent shelf removed reagent num=%d\n",netbuf_read[i]);
						
						TCP_Buffer[0] = 0;
						memcpy(&TCP_Buffer[1],operate_p->reagent_info.code,sizeof(operate_p->reagent_info.code));
						nt_sendpacketdata(REAGENT_REMOVED, TCP_Buffer, 21);
					}			
				i += 7;
				operate_p = operate_p->next;
				}
				
			}

			
		}

	 operate_head_p = operate_head_p->next_head;
	}
	printf("after \n");
		mb_printfoperatelist(operate_head);
	return 0;
}
#endif

/*************试剂扫描后调用 用于修正流程中试剂信息***************/
void ChangeReagentInOperate(unsigned char reagent_num)
{
	operate_head_list* 	operate_head = operate_head1;
	unsigned char i = 0,j = 0,regt_cnt=0,start_reagent=0;
	operate_t* operate_p = NULL;

return;

	start_reagent =(reagent_num -1) * 9;
	printf("In ChangeReagentInOperate*******************\n");
	lprintf(log_my, INFO,"In ChangeReagentInOperate*******************\n");
	pthread_mutex_lock(&head_lock);
	//mb_printfoperatelist(operate_head3);
	for (i = 0; i < 3; i++)
	{
		printf("iiiiiiiiiiiiii =%d\n",i);
		if (i == 0)
			operate_head = operate_head1;
		else if (i == 1)
			operate_head = operate_head2;
		else if (i == 2)
			operate_head = operate_head3;

		if (operate_head->operate.reagent == STOP_OPERATE)
			continue;
		for (regt_cnt = 0; regt_cnt < 9; regt_cnt++)
		{
			for(j = 0; j < 10; j++)
			{
				if (mix_DAB[i].ordArrayA[j] != 0)
				{
				  if (strcmp(mix_DAB[i].reagentA[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_DAB[i].ordArrayA[j] = start_reagent + regt_cnt;
				   if (strcmp(mix_DAB[i].reagentB[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_DAB[i].ordArrayB[j] = start_reagent + regt_cnt;
				}
				if (mix_SECEND[i].ordArrayA[j] != 0)
				{
				  if (strcmp(mix_SECEND[i].reagentA[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_SECEND[i].ordArrayA[j] = start_reagent + regt_cnt;
				   if (strcmp(mix_SECEND[i].reagentB[j].code, reagent_code[start_reagent + regt_cnt].code) == 0) 
				  	mix_SECEND[i].ordArrayB[j] = start_reagent + regt_cnt;
				}
				
			}
		}
		while(operate_head != NULL)
		{
			
			operate_p = &(operate_head->operate);
			printf("operate_p->reagent=%d operate_head =%d operate_head->next_head=%d\n\n",operate_p->reagent,operate_head,operate_head->next_head);
			while(operate_p != NULL && operate_p->reagent != STOP_OPERATE)
			{
				printf("operate_p->reagent=%d ",operate_p->reagent);
				if ((operate_p->reagent & 0X7F) < REAGENT_CASE)
				{
					 
					// for (regt_cnt = 0; regt_cnt < 9; regt_cnt++)
					 for(j = 0; j < 36;j++)	
					{		
						if ( (strcmp(operate_p->reagent_info.code, reagent_code[j].code ) == 0))
						{
								operate_p->reagent = j;
							
							break;
						}				
					}

				
				
				}
				

				operate_p = operate_p->next;
			//	printf("next operate_p->reagent=%d ",operate_p->reagent);
			}
			
			operate_head = operate_head->next_head;
			printf("operate_head=%d NULL=%d hereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",(int)operate_head,NULL);
		}


	
	}
	mb_printfoperatelist(operate_head3);
	if (pthread_mutex_unlock(&head_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
	
	printf("Out of ChangeReagentInOperate*******************\n");
	
}

void mb_reagentstationscanner(unsigned int reagent_num)
{
	sr_cmdstruct_t CommandElemt;
	int i=0;
	
	char TCP_Buffer[50] = {0};
	unsigned int ordArray_plate[9][2] = {0};
//	stminibd_sendpacket cmd;
	reagentoutside_list * reagentoutside_p = reagentoutside_head;
	unsigned char check_reagent[9] = {0}; //0 无效 1 需要测量
	unsigned int dwPinState, reagent_index = reagent_num - 1;

	reagentoutside_list * reagentoutside_head_tmp = reagentoutside_head, *reagentoutside_head_lst = NULL;
	//return;


	if(flg_intosleep)
		return 0;


	
	printf("in mb_reagentstationscanner %d\n", reagent_num);
	
	

/*
	sleep(5);
	reagent_check[reagent_index].NEED_SCAN = FALSE;
	GPIO_OutSet(reagent_check[reagent_index].lock);
	printf("scan reagent end  %d\n",reagent_num);
	return;
	*/
	
	if (reagent_num == 1)
		memcpy(ordArray_plate,ordArray_reagent,(sizeof(ordArray_reagent)) / 4);
	else if (reagent_num == 2)
		memcpy(ordArray_plate,&ordArray_reagent[9],(sizeof(ordArray_reagent)) / 4);
	else if (reagent_num == 3)
		memcpy(ordArray_plate,&ordArray_reagent[18],(sizeof(ordArray_reagent)) / 4);
	else if (reagent_num == 4)
		memcpy(ordArray_plate,&ordArray_reagent[27],(sizeof(ordArray_reagent)) / 4);
	else
		return;

	nt_sendpacketdata(REAGENT_SCAN_START, (char*)&reagent_num, 1);

//	mb_checkshelfreagent(reagent_num,ordArray_plate, check_reagent);
//	return;
	pthread_mutex_lock(&tp_threadmarm);

	if (SHELF_LOCK_WAY_NEW)
		GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描
	else
		GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描

#ifdef BIG_VERSION 


	GetMixStationVal(4,reagent_index);
	if(reagent_check[reagent_index].STATE == 0)//已经拿掉
	{
		reagent_check[reagent_index].NEED_SCAN = FALSE;
				if (pthread_mutex_unlock(&tp_threadmarm) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
		return;

	}
	GetMixStationVal(5,reagent_index);//锁定




#else

	dwPinState = reagent_check[reagent_index].sen;
	GPIO_PinState(&dwPinState);
	if ((dwPinState & reagent_check[reagent_index].sen) == 1)//已经拿掉
	{
		if (SHELF_LOCK_WAY_NEW)
	 GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描
	else
	GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描
	
		reagent_check[reagent_index].NEED_SCAN = FALSE;
		if (pthread_mutex_unlock(&tp_threadmarm) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
		return;
	}
#endif

//	sleep(1);
	
	  
	
	CommandElemt.srdevaddr = ARM_ADDR;
	for(i = (reagent_num - 1) * 9;i < (reagent_num * 9); i++)
	{
	if(flg_intosleep)
		break;
	
		mb_monitdoorstate();
		//高的40 低的70
		if (new_scaner)
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_reagent[i][0] - 10, ordArray_reagent[i][1], MOV_ZH);//到达玻片位置
		else
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_reagent[i][0] + 22, ordArray_reagent[i][1], MOV_ZH);//到达玻片位置
	//	sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_reagent[i][0] + 70, ordArray_reagent[i][1], MOV_ZH);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
	 			printf("[mb_reagentstationscanner]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_reagentstationscanner]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
	
	
		if (!sc_getscode(i,TRUE)) //表示此坐标没放试剂//试剂序号30以后
		{
		//	ordArray_plate[i][0] = 0;
		//	ordArray_plate[i][1] = 0;
		}
	//	usleep(200000);
	}

	usleep(200000);
	nt_sendpacketdata(REAGENT_SCAN_END, (char*)&reagent_num, 1);


	printf("begin to do check work*********\n");
	//while (!special_reagent_recieved && !flg_netdisconnect)
	//	sleep(1);
	memset(check_reagent, 1, sizeof(check_reagent));
#if 1
	for (i = (reagent_num - 1) * 9;i < reagent_num * 9;i++)
	{
		printf("i =%d %s --",i, &reagent_code[i].code);
		reagentoutside_p = reagentoutside_head;
		do
		{
			if (strcmp(reagent_code[i].code, reagentoutside_p->reagent_info.code) == 0)
			{
				check_reagent[i % 9] = 0;
				break;
			}
			reagentoutside_p = reagentoutside_p->next;
		}
		while(reagentoutside_p != NULL);
		
	}
	
	ChangeReagentInOperate(reagent_num);
#endif	
	if (!flg_netdisconnect)	//网络正常进行扫描
	{
	//	while(1)
//		mb_checkshelfreagent(reagent_num,ordArray_plate, check_reagent);
	}
	sleep(3);//等待接收灌注信息
if (SHELF_LOCK_WAY_NEW)
		GPIO_OutClear(reagent_check[reagent_index].lock);//锁住进行扫描
else
		GPIO_OutSet(reagent_check[reagent_index].lock);//锁住进行扫描


//	sleep(1);
	if (pthread_mutex_unlock(&tp_threadmarm) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mainarm_lock");
	
	reagent_check[reagent_index].NEED_SCAN = FALSE;

	#ifdef BIG_VERSION
	GetMixStationVal(6,reagent_index);//解锁
#endif

	
/*	
	printf("reagent_code=");
	
	char TCP_Buffer[4] ={0},str[20] = {0};		//测试兼容试剂选择
eenetevent = REAGENT_REPLACED;
	
scanf("%d",&i);
printf("i == %d\n",i);
if (i == 0)
{
	memcpy(TCP_Buffer,&eenetevent,4);
	TCP_Buffer[2] = 1;

	if (reagent_num == 1)
		TCP_Buffer[3] = 0;
	else if (reagent_num == 2)
		TCP_Buffer[3] = 9;
	else if (reagent_num == 3) 
		TCP_Buffer[3] = 18;
	else if (reagent_num == 4)
		TCP_Buffer[3] = 27;

		while(flg_netdisconnect) sleep(1);
		pthread_mutex_lock(&netsend_lock);
		if (send(local_fd, TCP_Buffer, sizeof(TCP_Buffer), 0) < 0)
			perror("write net\n");
		pthread_mutex_unlock(&netsend_lock);



	while (replace_reagent == 0xFF)	//等待接收PC端发送的代替试剂号
	{
			sleep(1);
			printf("wait for replace_reagent****\n");
	}
	printf("**replace_reagent = %d**\n", replace_reagent);
	replace_reagent = 0xFF;
}	
*/	
		//	sleep(20);//等待PC发送抗体 双氧水 DAB信息
	printf("OUT OF mb_reagentstationscanner %d\n", reagent_num);
}

void mb_mixstationscanner(void)
{
	sr_cmdstruct_t CommandElemt;

	
	CommandElemt.srdevaddr = ARM_ADDR;
	mb_monitdoorstate();
		sprintf(CommandElemt.cmdbuf, "PA %d %d %d",ordArray_mixed_DAB[0][0] + SCAN_DISTANC_MIXSTATION, ordArray_mixed_DAB[0][1], 0);//到达玻片位置
		if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
				CommandElemt.srdevaddr , 1, 0, 1) > 0)
				printf("[mb_mixstationscanner]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
			else
				printf("[mb_mixstationscanner]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
			sb_waitingframeaswer(&CommandElemt);
		sc_getscode( 0XEE,FALSE ); //混合站序号100

	
}

/**********
针对小仪器，检测大容量试剂是否兼容
当为试剂架上试剂时传入参数值为-1
reagentA为当前滴加的试剂
return 1
return -1 不匹配
*********/

int mb_checkbakreagent(emREAGENT reagentA,emREAGENT reagentB)
{
	if (reagentA == -1 && reagentB != REAGENT_WASH && reagentB != REAGENT_WATER)
		return -1;

	if (reagentB == STOP_OPERATE || reagentB == NO_REAGENT  || reagentB > REAGENT_DAB)
		return -1;

	if (reagentA == NO_REAGENT || reagentA > REAGENT_DAB)
		return 1;
	
	switch (reagentA)
	{
	case REAGENT_DEWAX:
		if (reagentB != REAGENT_ALCOHOL)
			return -1;
		break;
	case REAGENT_ALCOHOL:
		if (reagentB == REAGENT_ER1 || reagentB == REAGENT_ER2)
			return -1;
		break;
	case REAGENT_ER1:
		if (reagentB == REAGENT_DEWAX || reagentB == REAGENT_ALCOHOL || reagentB == -1)
			return -1;
		break;
	case REAGENT_ER2:
		if (reagentB == REAGENT_DEWAX || reagentB == REAGENT_ALCOHOL || reagentB == -1)
			return -1;
	break;
	case REAGENT_WASH:
		if (reagentB == REAGENT_ER1 || reagentB == REAGENT_ER2)// 脱蜡分开操作
			return -1;
	break;
	case REAGENT_WATER:
		if (reagentB == REAGENT_DEWAX)
			return -1;
	break;
	case NO_REAGENT:
		return 1;
	break;
	default: return -2;
	}
return 1;
}

int IsCompatibleReagentAvaliable(char i, int val )
{
	printf("val1=%d val2=%d\n", reagent_code[i].val, val);
	if (reagent_code[i].val >= val)//DAB大于100ul可用于替换
				return i;

	return -1;
}
/**********
liquid_num 片数量
reagent 试剂类型
return 位置信息
return i || 0X80; 不同批号
return -1 当匹配到WASH
val 需要的试剂两

*********/
int mb_searchcomatiblereagent(reagent_t * reagent, int val)
{
	int i = 0,reg_cnt = 0;
	
	lprintf(log_my, INFO,"in mb_searchcomatiblereagent, reagent->code=%s reagent_kind=%s\n",reagent->code,reagent->reagent_kind);

	printf("in mb_searchcomatiblereagent, reagent->code=%s reagent_kind=%s\n",reagent->code,reagent->reagent_kind);
		for (i = 0; i < 36;i++)
			{
			printf(" %s %s*", reagent_code[i].code,reagent_code[i].reagent_kind);
			lprintf(log_my, INFO," %s %s*", reagent_code[i].code,reagent_code[i].reagent_kind);
			}
	for (i = 0; i < 36;i++)//找同一试剂系统
	{	
		if (strcmp(reagent->code, reagent_code[i].code) == 0 && reagent_code[i].code[0] != 0)
			break;
	}
	reg_cnt = i;
	if (i != 36)//同一试剂系统上找
	{	printf("search in the same reagent system\n");
		for (i = reg_cnt / 9 * 9; i < (reg_cnt / 9 + 1) * 9 ;i++)
		{
			if (strcmp(reagent->reagent_kind,reagent_code[i].reagent_kind) == 0 )
			{
				if (IsCompatibleReagentAvaliable(i, val) >= 0)
					return i;
			}
		}
	}
	
	printf("search as the same lot\n");
	for (i = 0; i < 36;i++)//同批号
	{	
		if ((strcmp(reagent->reagent_kind,reagent_code[i].reagent_kind) == 0)
			&& (strcmp(reagent_code[i].lot_num,reagent->lot_num) == 0) )
		{
			if (IsCompatibleReagentAvaliable(i, val) >= 0)
					return i;
		}
			
	}

	
	
	printf("search as the different lot\n");
	for (i = 0; i < 36;i++)//不同批号
	{	
		if ((strcmp(reagent->reagent_kind,reagent_code[i].reagent_kind) == 0))
		{
			if (IsCompatibleReagentAvaliable(i, val) >= 0)
				return i;
		}
	}
	printf("not find\n");
	return -1;
}

/******************可能同时滴加大容量和试剂架试剂，试剂架试剂可能同时滴加10种不同抗体*******************/
int mb_aspiratedispensework(dispense_t* dispense)
{
	unsigned char reagent_num = 0,  reagent_num2 = 0, plate_num = 0;
	unsigned char plate_num_cmd = 0;//用来确定发送至哪个minibcmd
	unsigned char i = 0 ,cab_cnt = 0, slf_cnt = 0;
	stminibd_sendpacket cmd;
	dispense_t dispense_cab[10] = {0};//大容量
	dispense_t dispense_slf[10] = {0};//试剂架
	BOOL *mini_finished_p;
	char shelf_num;
	unsigned char* last_reagent = NULL;
	
	printf("in mb_aspiratedispensework\n");
	printf("dispense=");
	
		lprintf(log_my, INFO,"in mb_aspiratedispensework\n");
	

		while(i < 11 && dispense[i].reagent != STOP_OPERATE)
		{
		i++;
		}
		
	plate_num_cmd = dispense[0].plate_num;
	
#if 0
	while(i < 11 && dispense[i].reagent != STOP_OPERATE)
	{
	//lprintf(log_my, INFO," reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		printf(" reagent=%d plate=%d", dispense[i].reagent,dispense[i].plate_num);
		if (dispense[i].reagent & 0X7F >= REAGENT_CASE && dispense[i].reagent & 0X7F < REAGENT_DAB)
		{
		printf("in memcab\n");
			memcpy(&dispense_cab[cab_cnt], &dispense[i], sizeof(dispense_t));
			cab_cnt++;
		}
		else	//包括DAB
		{
		printf("in memslf\n");
			memcpy(&dispense_slf[slf_cnt], &dispense[i], sizeof(dispense_t));
			slf_cnt++;
		}
		i++;
	}
	dispense_cab[cab_cnt].reagent = dispense_slf[slf_cnt].reagent = STOP_OPERATE;
	i=0;
	while(dispense_slf[i++].reagent != STOP_OPERATE)
		printf(" %d %d ",dispense_slf[i].reagent, dispense_slf[i].plate_num);
	printf("cabbbbbbbbbbb\n");
	i=0;
	while(dispense_cab[i++].reagent != STOP_OPERATE)
		printf(" %d %d ",dispense_cab[i].reagent, dispense_cab[i].plate_num);
	printf("\n");
	
#endif

		
	//此延时确保主函数中ExcuteOperate退出后 mb_checksensorproce()已经执行一遍
	
//#if BIG_VERSION
#if 0
	//大容量试剂
	if ( (dispense_cab[0].reagent != 0) && (dispense_cab[0].reagent <= (REAGENT_CASE + 5)) )	//针对大仪器需要添加这一步 
	{

		//发送mini板滴加命令	(reagent_num, dispense_t* dispense)
		printf("*********************send dispense cmd to miniboard************************\n");
		sleep(1);
		memset(&cmd,0,sizeof(cmd));
		cmd.cmd = DO_DISPENSE;
		cmd.minicmd_buffer[3] = (unsigned char)DO_DISPENSE;
		cmd.minicmd_buffer[4] = dispense_cab[0].reagent;
		cmd.minicmd_buffer[5] = 0;//玻片拉伸
		
		i = 0;
		while(i < 11 && dispense_cab[i].reagent != 0)
		{
			plate_num = dispense_cab[i].plate_num % 10 + 1;
			cmd.minicmd_buffer[plate_num + 5] = 1;
			i++;
		}
		cmd.minicmd_num = 13;

		
		if ((plate_num_cmd % 30) < 10)
		{
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			pthread_mutex_unlock(&mutex_mlock);
			mini_finished_p = &mini_finished;
		}
		else if ((plate_num_cmd % 30) < 20)
		{
			pthread_mutex_lock(&mutex_mlock2);
			set_minicmd(pcmd_head2,cmd);
			pthread_mutex_unlock(&mutex_mlock2);
			mini_finished_p = &mini_finished2;
		}
		else
		{
			pthread_mutex_lock(&mutex_mlock3);
			set_minicmd(pcmd_head3,cmd);
			pthread_mutex_unlock(&mutex_mlock3);
			mini_finished_p = &mini_finished3;
		}
	
		if (dispense_slf[0].reagent != STOP_OPERATE)//还有试剂架试剂要滴加 只在酶处理中出现
		{
			sleep(1);
			while(!*mini_finished_p)
				sleep(1);
		}
		else
		{
			printf("mb_aspiratedispensework finished \n");
			return 0;
		}
		
	}
#endif


		
	//*************试剂架试剂 被拿掉**************// 混合试剂被拿掉再前面混合时已经等待所以要滴加时已经混合好
	
#ifdef BIG_VERSION

		
		if (dispense[0].plate_num % 30 < 10)
		{
			shelf_num = 0;
			last_reagent = &last_reagentA;
		}
		else if (dispense[0].plate_num % 30 < 20)
		{
			shelf_num = 1;
			last_reagent = &last_reagentB;
		}
		else if (dispense[0].plate_num % 30 < 30)
		{
			shelf_num = 2;
			last_reagent = &last_reagentC;
		}

		
		if( dispense[0].reagent >= REAGENT_CASE && dispense[0].reagent < NO_REAGENT && ( dispense[0].reagent == dispense[--i].reagent))//修复液有不同的情况,需要考虑
		{
		printf("go armcabin\n");
			while(!ArmCabinWork_finished[shelf_num])
									usleep(100000);
				
			ArmCabinCmdList[shelf_num].dispense_pos = dispense[0].plate_num / 30;
	//		if(ArmCabinCmdList[shelf_num].dispense_pos == 3)//拉片架与清洗站有干涉暂时改变
	//			ArmCabinCmdList[shelf_num].dispense_pos = 1;
			
			ArmCabinCmdList[shelf_num].reagent_sel = dispense[0].reagent;
	if( dispense[0].plate_num  >= 60 && dispense[0].plate_num < 90)
		ArmCabinCmdList[shelf_num].reagent_val = 100;
	else
		ArmCabinCmdList[shelf_num].reagent_val = 150;
			ArmCabinCmdList[shelf_num].cmd = ArmCabinWork;//命令最后赋值dowork_Arm_cabinA以此判断
				#ifdef BIG_VERSION
				flg_normaldispenseliquid[shelf_num]++;
			#else
				flg_normaldispenseliquid[shelf_num] = TRUE;
			#endif
				*last_reagent = dispense[0].reagent;
		return 0;
		//	goto enddispense;
		}
		else //主臂滴加需让位
		{
		printf("go armcabin rangwei\n");
			while(!ArmCabinWork_finished[shelf_num])
									usleep(100000);
			ArmCabinCmdList[shelf_num].dispense_pos = 5;
							ArmCabinCmdList[shelf_num].cmd = ArmCabinArm ;//命令最后赋值dowork_Arm_cabinA以此判断
							ArmCabinWork_finished[shelf_num] = FALSE;
							
							

		}
	#endif	

	
	if (((plate_num_cmd % 30) < 10) && (flg_mianarmstop_a))	//主臂操作完成
	{
		printf("copy dispense to dispenseA\n");
		memcpy(dispenseA,dispense,sizeof(dispense_t)*11);
		flg_mianarmstop_a = FALSE;
	}
	else if (((plate_num_cmd % 30) < 20) && (flg_mianarmstop_b))	//主臂操作完成
	{
		printf("copy dispense to dispenseB\n");
		memcpy(dispenseB,dispense,sizeof(dispense_t)*11);
		flg_mianarmstop_b = FALSE;
	}
	else if (((plate_num_cmd % 30) < 30) && (flg_mianarmstop_c))	//主臂操作完成
	{
		printf("copy dispense to dispenseC\n");
		memcpy(dispenseC,dispense,sizeof(dispense_t)*11);
		flg_mianarmstop_c = FALSE;
	}
	

	
		
/*
	

*/
	printf("mb_aspiratedispensework finished \n");
	printf("\n");
	return 0;
}

void mb_mainworkstop(unsigned char shelf_num)
{
	stminibd_sendpacket cmd;
	struct timeval now;
	ArmCabin_t arm_cabin_cmd;
	
	assert(shelf_num <= 3 && shelf_num > 0);

	pthread_mutex_lock(&mutex_mneedworked);
	
	printf("stop_mini_work %d finished*********************\n",shelf_num);
	lprintf(log_my, INFO,"stop_mini_work %d finished*********************\n",shelf_num);
	memset (&mix_DAB[shelf_num-1], 0, sizeof(mix_t));
	memset (&mix_SECEND[shelf_num-1], 0, sizeof(mix_t));

	shelf_stirmode[shelf_num - 1] = 0;
			bzero(&shelf_stirtime[shelf_num - 1][0], 12);

	reagent_lock[0][shelf_num - 1] = 0;
	reagent_lock[1][shelf_num-1] = 0;
	reagent_lock[2][shelf_num-1] = 0;
	reagent_lock[3][shelf_num-1] = 0;
				
	gettimeofday(&now, NULL);
	#ifdef BIG_VERSION
			ArmCabinCmdList[shelf_num -1].dispense_pos = 5;
							ArmCabinCmdList[shelf_num -1].cmd = ArmCabinArm;//命令最后赋值dowork_Arm_cabinA以此判断
							ArmCabinWork_finished[shelf_num -1] = FALSE;
							while(!ArmCabinWork_finished[shelf_num -1])
								usleep(100000);
				//			ArmCabinCmdList[shelf_num -1].dispense_pos = 0;
				ArmCabinCmdList[shelf_num -1].cmd = ArmCabinKey;//命令最后赋值dowork_Arm_cabinA以此判断
			//	while(!ArmCabinWork_finished[shelf_num -1])
				//	usleep(100000);
				;
	#endif
	if (shelf_num == 1)
	{
		flg_opwork1ready = FALSE;
		if (operate_pri == operate_head1)
			operate_pri = NULL;
		pthread_mutex_lock(&head_lock);
		mb_setoperateheaddisable((operate_t**)&operate_head1,TRUE);
		if (pthread_mutex_unlock(&head_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
		tc_packettempcmd(STOP_CONTROL1);
		
	
		
		
		#ifndef BIG_VERSION
			bs_packetshelfstreach(0,&cmd);	
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error m_lock");
		//	pthread_mutex_lock(&mutex_mneedworked);
			while((mini_work_finished[0]))//确保miniBoard线程已置FALSE
				usleep(1000);
				sleep(1);
			while(!(mini_work_finished[0]))//动作完成
				usleep(200000);
		//	pthread_mutex_unlock(&mutex_mneedworked);
		
			memset(&mini_cmd,0,sizeof(mini_cmd));
				mini_cmd.cmd = MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[3] = (unsigned char)MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[4] = 4;
				mini_cmd.minicmd_num=2;
				pthread_mutex_lock(&mutex_mlock);
				set_minicmd(pcmd_head,mini_cmd);
				if (pthread_mutex_unlock(&mutex_mlock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
	#endif
	//		mb_dischargeshelfwateliquid(1);	
		 which_mix_kindA=0;
		isDAB_mixedA = FALSE;
		isDAB_mixedA_next = FALSE;
		workstep_mix_a = 0;
		mixstation_clear_state[0].AFTER_DISPENSE = TRUE;	
		mixstation_clear_state[1].AFTER_DISPENSE = TRUE;	
		startmixworkid &= 0X7F; 
		if (DAB1Array_exchange)
				DAB1Array_exchange = FALSE;
			else
				DAB1Array_exchange = TRUE;
		
		HEAD1_STEP_SENDED = TRUE;
		ewkeventA = STOP_WORK;
		workstep_state_a = 0X01110000;
		last_reagentA = NO_REAGENT;
		CriticalWork &= 0X7F;
		flg_mianarmstop_a = TRUE;
		StartDispenseA = FALSE;
		bzero(&lastt_kind[0][0], 9);
	}
	else if (shelf_num == 2)
	{
	if (operate_pri == operate_head2)
			operate_pri = NULL;
		flg_opwork2ready = FALSE;
		
		pthread_mutex_lock(&head_lock);
		mb_setoperateheaddisable((operate_t**)&operate_head2,TRUE);
		if (pthread_mutex_unlock(&head_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_Lock");
		tc_packettempcmd(STOP_CONTROL2);

		#ifndef BIG_VERSION
		bs_packetshelfstreach(10,&cmd);
			
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
		//	pthread_mutex_lock(&mutex_mneedworked);
			while((mini_work_finished[1]))//确保miniBoard线程已置FALSE
				usleep(1000);
				sleep(1);
			while(!(mini_work_finished[1]))//动作完成
				usleep(200000);
		//	pthread_mutex_unlock(&mutex_mneedworked);
		
				memset(&mini_cmd,0,sizeof(mini_cmd));
				mini_cmd.cmd = MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[3] = (unsigned char)MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[4] = 5;
				mini_cmd.minicmd_num=2;
				pthread_mutex_lock(&mutex_mlock);
				set_minicmd(pcmd_head,mini_cmd);
				if (pthread_mutex_unlock(&mutex_mlock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
//	mb_dischargeshelfwateliquid(2);
#endif
		which_mix_kindB=0;
		isDAB_mixedB = FALSE;
		isDAB_mixedB_next = FALSE;
		workstep_mix_b = 0;
		mixstation_clear_state[2].AFTER_DISPENSE = TRUE;	
		mixstation_clear_state[3].AFTER_DISPENSE = TRUE;
		startmixworkid &= 0XBF; 
		if (DAB2Array_exchange)
				DAB2Array_exchange = FALSE;
			else
				DAB2Array_exchange = TRUE;
		
		HEAD2_STEP_SENDED = TRUE;
		ewkeventB = STOP_WORK;
		workstep_state_b = 0X01110000;
		last_reagentB = NO_REAGENT;
		CriticalWork &= 0XBF;
		flg_mianarmstop_b= TRUE;
		StartDispenseB = FALSE;
		bzero(&lastt_kind[1][0], 9);
	}
	else if (shelf_num == 3)
	{
	if (operate_pri == operate_head3)
			operate_pri = NULL;
		flg_opwork3ready = FALSE;
		
		pthread_mutex_lock(&head_lock);
		mb_setoperateheaddisable((operate_t**)&operate_head3,TRUE);
		if (pthread_mutex_unlock(&head_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_Lock");
		
		tc_packettempcmd(STOP_CONTROL3);
		#ifndef BIG_VERSION
		bs_packetshelfstreach(20,&cmd);
			
			pthread_mutex_lock(&mutex_mlock);
			set_minicmd(pcmd_head,cmd);
			if (pthread_mutex_unlock(&mutex_mlock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
		//	pthread_mutex_lock(&mutex_mneedworked);
			while((mini_work_finished[2]))//确保miniBoard线程已置FALSE
				usleep(1000);
				sleep(1);
			while(!(mini_work_finished[2]))//动作完成
				usleep(200000);
		//	pthread_mutex_unlock(&mutex_mneedworked);
			
			if (pthread_mutex_unlock(&head_lock) !=0 )
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
			
			memset(&mini_cmd,0,sizeof(mini_cmd));
				mini_cmd.cmd = MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[3] = (unsigned char)MAINTAIN_FAN_WORK;
				mini_cmd.minicmd_buffer[4] = 6;
				mini_cmd.minicmd_num=2;
				pthread_mutex_lock(&mutex_mlock);
				set_minicmd(pcmd_head,mini_cmd);
				if (pthread_mutex_unlock(&mutex_mlock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
	//			mb_dischargeshelfwateliquid(3);
	#endif
		which_mix_kindC=0;
		isDAB_mixedC = FALSE;
		isDAB_mixedC_next = FALSE;
		workstep_mix_c = 0;
		mixstation_clear_state[4].AFTER_DISPENSE = TRUE;	
		mixstation_clear_state[5].AFTER_DISPENSE = TRUE;
		startmixworkid &= 0XDF; 
		if (DAB3Array_exchange)
				DAB3Array_exchange = FALSE;
			else
				DAB3Array_exchange = TRUE;
		
		HEAD3_STEP_SENDED = TRUE;
		ewkeventC = STOP_WORK;
		workstep_state_c = 0X01110000;
		last_reagentC = NO_REAGENT;
		CriticalWork &= 0XDF;
		flg_mianarmstop_c = TRUE;
		StartDispenseC = FALSE;
		bzero(&lastt_kind[2][0], 9);
		
	}
	#ifndef BIG_VERSION

	
	memset(&cmd,0,sizeof(cmd));
	#ifdef glint
	cmd.cmd = WORK_FINISH;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)WORK_FINISH;//RELOAD;
	#else
	cmd.cmd = RELOAD;//RELOAD;
	cmd.minicmd_buffer[3] = (unsigned char)RELOAD;//RELOAD;
	#endif
	cmd.minicmd_buffer[4] = shelf_num;
	cmd.minicmd_num=2;
	
	{
	pthread_mutex_lock(&mutex_mlock);
	set_minicmd(pcmd_head,cmd);
	if (pthread_mutex_unlock(&mutex_mlock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mlock");
	}
	#endif
	pthread_mutex_unlock(&mutex_mneedworked);

	
}


/*****************运行步骤前检测当前时间是否超过此步骤的运行时间 超过则补起返回TRUE*********************
******************超时原因:1当仪器执行加热操作时时间超出预设值；2当仪器执行滴加操作时间过长*******/
BOOL ct_patchtime(operate_head_list* operate_head)
{
	unsigned int  maxtime = 0;
	int patch_time=0;
	unsigned char i = 0;
	operate_head_list* operate_head_p = NULL;
	operate_t* operate_p = NULL;
	struct timeval now;
	BOOL res = FALSE;
	unsigned int *head_step = NULL;
	unsigned int head_start_time = 0;
	char have_mix_reangent1st = 0,have_mix_reangent2sd = 0;
	char temper_state = 0;

	gettimeofday(&now, NULL);
	

	//执行搅拌动作
	for(i=0; i < 3;i++)
	{
		if (NEED_PRINTF)
		{
			printf("shelf_stirtime[i][0]=%d shelf_stirtime[i][1]=%d shelf_stirtime[i][2]=%d\n",shelf_stirtime[i][0],shelf_stirtime[i][1],shelf_stirtime[i][2]);
		}
		if(shelf_stirtime[i][0] > 0 && shelf_stirtime[i][0] <= now.tv_sec - begin_time.tv_sec)
		{
			shelf_stirmode[i] = 3;
			shelf_stirtime[i][0] = 0;
		}

		if(shelf_stirtime[i][1] > 0 && shelf_stirtime[i][1] <= now.tv_sec - begin_time.tv_sec)
		{
			shelf_stirmode[i] = 3;
			shelf_stirtime[i][1] = 0;
		}
		if(shelf_stirtime[i][2] > 0 && shelf_stirtime[i][2] <= now.tv_sec - begin_time.tv_sec)
		{
			shelf_stirmode[i] = 3;
			shelf_stirtime[i][2] = 0;
		}
	}
	
	
//	printf("\nin ct_patchtime work\n");
//printf("[ct_patchtime]operate_head->operate.time = %d\n",operate_head->operate.time);
	if (operate_head->operate.next == NULL && operate_head->operate_work_time == 0)//动作结束
		return res;
	
	if (operate_head == operate_head1)
	{
		head_step = &workstep_state_a;
		head_start_time = head1_start_time;
		temper_state = temper_control1[0].state;
	}
	else if (operate_head == operate_head2)
	{
		head_step = &workstep_state_b;
		head_start_time = head2_start_time;
		temper_state = temper_control2[0].state;
	}
	else if (operate_head == operate_head3)
	{
		head_step = &workstep_state_c;
		head_start_time = head3_start_time;
		temper_state = temper_control3[0].state;
	}
	else return FALSE;
	
	operate_head_p = operate_head;
		while (operate_head_p != NULL)
		{
			maxtime = maxtime < operate_head_p->operate.time ? operate_head_p->operate.time : maxtime;
			operate_head_p = operate_head_p->next_head;
		}

	gettimeofday(&now, NULL);
	if (NEED_PRINTF)
	printf("now.tv_sec - begin_time.tv_sec=%d maxtime = %d operate_p->time=%d\n",
	now.tv_sec - begin_time.tv_sec, maxtime,operate_head->operate.time);
	
	{								//max补齐	
		operate_head_p = operate_head;
		
		while (operate_head_p != NULL)
		{	
				patch_time = maxtime - operate_head_p->operate.time;	
				operate_p = &(operate_head_p->operate);
				while (operate_p != NULL)
				{
					operate_p->time += patch_time;//将执行操作时间补齐	
					operate_p = operate_p->next;
			
				}
			operate_head_p = operate_head_p->next_head;
		}
	}
	if (NEED_PRINTF)	
	printf("*head_step=%x operate_head->operate_work_time=%d temper_state=%d operate_p->time=%d\n",
		*head_step,operate_head->operate_work_time,temper_state,operate_head->operate.time);
	if ( (temper_state < REACH_TEMP))//滴加未结束时间全部推移 //温度加热是否完成以在ExcuteOperate 中执行
	{
		operate_head_p = operate_head;
		while (operate_head_p != NULL)
		{		
			if (operate_head_p->operate.time > (now.tv_sec - begin_time.tv_sec))
			{
				patch_time = operate_head_p->operate_work_time - 
				(operate_head_p->operate.time - (now.tv_sec - begin_time.tv_sec) );
			}
			else
			{
				patch_time = operate_head_p->operate_work_time +
				( (now.tv_sec - begin_time.tv_sec) - operate_head_p->operate.time );
			}
			operate_p = &(operate_head_p->operate);
		//	printf("operate_head_p->operate.time=%d, patch_time=%d operate_p->time=%d\n", 
			//	operate_head_p->operate.time,patch_time,operate_head->operate.time);
			while (operate_p != NULL)
			{
				operate_p->time += patch_time;
				operate_p = operate_p->next;
		
			}
			operate_head_p = operate_head_p->next_head;
		}
		res = TRUE;
	}
	/*
	else if (operate_head->operate.time <= (now.tv_sec - begin_time.tv_sec))
	{
		pthread_mutex_lock(&head_step_lock);
		*head_step = (*head_step) | 0X00010000;
		if (pthread_mutex_unlock(&head_step_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
		operate_head->operate_work_time = 0;
	}
	*/
	if (NEED_PRINTF)	
		printf("operate_p->time=%d ",operate_head->operate.time);
	if ((now.tv_sec - begin_time.tv_sec) >= maxtime)								//now.tv_sec - begin_time.tv_sec补齐
	{
		operate_head_p = operate_head;
		while (operate_head_p != NULL)
		{		
			patch_time = now.tv_sec - begin_time.tv_sec - operate_head_p->operate.time;
			operate_p = &(operate_head_p->operate);
		//	printf("operate_head_p->operate.time=%d, patch_time=%d\n", operate_head_p->operate.time,patch_time);
			while (operate_p != NULL)
			{
				operate_p->time += patch_time;
				operate_p = operate_p->next;
		
			}
			operate_head_p = operate_head_p->next_head;
		}
		res = TRUE;
	}
	if (NEED_PRINTF)	
		printf("222operate_p->time=%d ",operate_head->operate.time);

	operate_p = &(operate_head->operate);
	while (operate_p != NULL)		//找出滴加混合试剂的时间
	{
		if ( (operate_p->reagent & 0X7F) == REAGENT_DAB && !have_mix_reangent1st)
		{
			if (operate_head == operate_head1 && !isDAB_mixedA)
				dispense_mixreagent_timeA = operate_p->time;
			if (operate_head == operate_head2 && !isDAB_mixedB)
				dispense_mixreagent_timeB = operate_p->time;
			if (operate_head == operate_head3 && !isDAB_mixedC)
				dispense_mixreagent_timeC = operate_p->time;
			have_mix_reangent1st = 1;

		//	break;
		}
	//	printf("have_mix_reangent2sd=%d\n", have_mix_reangent2sd);
		if ( (operate_p->reagent & 0X7F) == REAGENT_SECEND && !have_mix_reangent2sd)
		{
			if (operate_head == operate_head1 && !isDAB_mixedA_next)
				dispense_mixreagent_timeA_next = operate_p->time;
			if (operate_head == operate_head2 && !isDAB_mixedB_next)
				dispense_mixreagent_timeB_next = operate_p->time;
			if (operate_head == operate_head3 && !isDAB_mixedC_next)
				dispense_mixreagent_timeC_next = operate_p->time;
			have_mix_reangent2sd = 1;

		//	break;
		}
		
		operate_p = operate_p->next;
	}
	if(have_mix_reangent1st == 0)//没有混合试剂
	{
		if (operate_head == operate_head1 )
				dispense_mixreagent_timeA = 0;
		if (operate_head == operate_head2 )
				dispense_mixreagent_timeB = 0;
		if (operate_head == operate_head3 )
				dispense_mixreagent_timeC = 0;
	}
	if(have_mix_reangent2sd == 0)//没有混合试剂
	{
		if (operate_head == operate_head1 )
				dispense_mixreagent_timeA_next = 0;
		if (operate_head == operate_head2 )
				dispense_mixreagent_timeB_next = 0;
		if (operate_head == operate_head3 )
				dispense_mixreagent_timeC_next = 0;
	}
	
//	mb_printfoperatelist(operate_head);
//	printf("\nPatchTime work finished\n");
	return res;
}

void mb_mixprogressintime(unsigned int work_time, operate_head_list* next_head)
{
	BOOL isoperate_working = FALSE;
	operate_head_list* operate_head_Mix = NULL;
	unsigned char i = 0;
	int pre_time = 20*60;
	unsigned char reagentA = 0,reagentB = 0,reagentC = 0;
//if ((startmixworkid & 0XFE) == 0)//有混合操作的无需找是否有时间
//	if (!flg_opwork1ready && !flg_opwork2ready && !flg_opwork3ready)
/*
Array_mixed_DAB2[0] = ordArray_mixed_DAB[2][0];
	Array_mixed_DAB2[1] = ordArray_mixed_DAB[2][1];
	isDAB_mixedB = TRUE;
	Array_mixed_DAB3[0] = ordArray_mixed_DAB[4][0];
	Array_mixed_DAB3[1] = ordArray_mixed_DAB[4][1];
	isDAB_mixedC = TRUE;
		return;
*/

//return;
reagentA = operate_head1->operate.reagent;	
	reagentB = operate_head2->operate.reagent;	
	reagentC = operate_head3->operate.reagent;

{
#if 0 

		if (next_head == operate_head1 && !flg_opwork1ready)
			return;
		else if (next_head == operate_head2 && !flg_opwork2ready)
			return;
		else if (next_head == operate_head3 && !flg_opwork3ready)
			return;

 //前20分钟进行混合空闲不进行混合	
		if (next_head->operate.time > (work_time + 600) || 
			(next_head == operate_head1 && temper_control1[0].state == START_FAN) ||
			(next_head == operate_head2 && temper_control2[0].state == START_FAN) ||
			(next_head == operate_head3 && temper_control3[0].state == START_FAN)
			)
			startmixworkid |= 0X01;
		else
			startmixworkid &= 0XFE;
#endif
	/*		
		printf("operate_head1->operate.time=%d operate_head2->operate.time=%d operate_head3->operate.time=%d work_time=%d",
			operate_head1->operate.time,operate_head2->operate.time,operate_head3->operate.time,work_time);
		
		if ( (!flg_opwork1ready || operate_head1->operate.time > (work_time + 30)) &&
			(!flg_opwork2ready || operate_head2->operate.time > (work_time + 30)) &&
			(!flg_opwork3ready || operate_head3->operate.time > (work_time + 30)) )
		{
			startmixworkid |= 0X01;
		}
		else 
		{
			startmixworkid &= 0XFE;
		}
		*/
}	
//printf("dispense_mixreagent_timeB_next=%d work_time=%d ,isDAB_mixedB_next=%d which_mix_kindB=%d isDAB_mixedB=%d\n", 
	//dispense_mixreagent_timeB_next,work_time,isDAB_mixedB_next,which_mix_kindB,isDAB_mixedB);

#ifdef BIG_VERSION
	if( (reagentA < REAGENT_CASE && !flg_opwork1ready) || (reagentB < REAGENT_CASE && !flg_opwork2ready) || 
		(reagentC < REAGENT_CASE&& !flg_opwork3ready) )
		return;

		if( reagentA == REAGENT_DAB && !isDAB_mixedA)
			{}
		else if( reagentB == REAGENT_DAB && !isDAB_mixedB)
			{}
		else if( reagentC == REAGENT_DAB && !isDAB_mixedC)
			{}
		else if( reagentA == REAGENT_SECEND && !isDAB_mixedA_next)
			{}
		else if( reagentB == REAGENT_SECEND && !isDAB_mixedB_next)
			{}
		else if( reagentC == REAGENT_SECEND && !isDAB_mixedC_next)
			{}
		else if( (last_reagentA >= REAGENT_CASE && last_reagentA != NO_REAGENT) || 
			(last_reagentB >= REAGENT_CASE&& last_reagentB != NO_REAGENT) ||
			(last_reagentC >= REAGENT_CASE&& last_reagentC != NO_REAGENT))//只在赋予二抗系统时混合
			return;

		pre_time=20*60;
#endif
#if DE_TONG
//	printf("headsel reagentB=%d, reagentC=%d\n",reagentB,reagentC);
	if ((reagentA == REAGENT_DAB && isDAB_mixedA) || (reagentA == REAGENT_SECEND && isDAB_mixedA_next))
		{
		return;
		}
	if ((reagentB == REAGENT_DAB && isDAB_mixedB) || (reagentB == REAGENT_SECEND && isDAB_mixedB_next))
		{
		return;
		}
	if ((reagentC == REAGENT_DAB && isDAB_mixedC) || (reagentC == REAGENT_SECEND && isDAB_mixedC_next))
		{
		return;
		}
#endif


//滴加混合试剂前20分钟必须进行混合
	if (dispense_mixreagent_timeA != 0 && (dispense_mixreagent_timeA - work_time) <= pre_time 
		&& !isDAB_mixedA && flg_opwork1ready)
		{
		startmixworkid = startmixworkid | 0X80;
		which_mix_kindA = 1;
		}
	else if (dispense_mixreagent_timeB != 0 && (dispense_mixreagent_timeB - work_time) <= pre_time 
		&& !isDAB_mixedB && flg_opwork2ready)
		{
		startmixworkid = startmixworkid | 0X40;
		which_mix_kindB = 1;
		}
	else if (dispense_mixreagent_timeC != 0 && (dispense_mixreagent_timeC - work_time) <= pre_time 
		&& !isDAB_mixedC && flg_opwork3ready)
		{
		startmixworkid = startmixworkid | 0X20;
		which_mix_kindC = 1;
		}
#ifdef LAIYUE
		pre_time = 5*60;
#else 
		pre_time = 5;
#endif

if (dispense_mixreagent_timeA_next != 0 && (dispense_mixreagent_timeA_next - work_time) <= pre_time 
			 && !isDAB_mixedA_next && flg_opwork1ready )
			{
			startmixworkid = startmixworkid | 0X80;
			which_mix_kindA = 2;
			}
		else if (dispense_mixreagent_timeB_next != 0 && (dispense_mixreagent_timeB_next - work_time) <= pre_time 
			 && !isDAB_mixedB_next && flg_opwork2ready)
			{
			startmixworkid = startmixworkid | 0X40;
			which_mix_kindB = 2;
			}
		else if (dispense_mixreagent_timeC_next != 0 && (dispense_mixreagent_timeC_next - work_time) <= pre_time  
			 && !isDAB_mixedC_next && flg_opwork3ready)
			{
			startmixworkid = startmixworkid | 0X20;
			which_mix_kindC = 2;
			}

/*
	if (workstep_mix_a == 4 || ewkeventA == STOP_WORK)
		startmixworkid &= 0X7F;

	if (workstep_mix_b == 4 || ewkeventB == STOP_WORK)
		startmixworkid &= 0XBF;
	
	if (workstep_mix_c == 4 || ewkeventC == STOP_WORK)
		startmixworkid &= 0XDF;
*/	
//	printf("startmixworkid =%x\n",startmixworkid);
}

char mb_getminnumber(unsigned int a,unsigned int b, unsigned int c)
{
	char numtem = 0;
	unsigned int data[3] = {268435455,268435455,268435455};
	
	if (flg_opwork1ready)
		data[0] =a;
	if (flg_opwork2ready)
	data[1]=b;
	if (flg_opwork3ready)
	data[2]=c; 
	
		numtem =  data[0] < data[1] ? 0 : 1;
		numtem = data[numtem] < data[2] ? numtem : 2;

	if (NEED_PRINTF)
		printf("data[0] =%d data[1] =%d data[2] =%d mb_getminnumber numtem=%d\n", data[0],data[1],data[2],numtem);
	return numtem;
}

int mb_opheadheaterpriorit(operate_head_list* operate_head_table[])
{
	int i=0;
	BOOL in_temper_control;

	if (operate_pri == operate_head1)
		in_temper_control = flg_temperheating1;
	else if (operate_pri == operate_head2)
		in_temper_control = flg_temperheating2;
	if (operate_pri == operate_head3)
		in_temper_control = flg_temperheating3;
	
	for (i = 0; i < 3;i++)
	{
		if (operate_pri == operate_head_table[i] && operate_pri != NULL && !in_temper_control)
		{
			operate_head_table[0] = operate_head_table[1] =operate_head_table[2] =NULL;
			memset(operate_head_table,0,sizeof(operate_head_table));
			operate_head_table[i] = operate_pri;
			return 0;
		}
	}
	
	if(operate_head_table[0] != NULL || operate_head_table[1] != NULL ||
			operate_head_table[2] != NULL)
	return 0;

	return -1;
}

#ifdef BIG_VERSION
int mb_opprocepriorit(operate_head_list* operate_head_table[])
{
	unsigned char reagentA = 0,reagentB = 0,reagentC = 0;
	char reagent_tstA = 0,reagent_tstB = 0,reagent_tstC = 0;
	struct timeval now;
	unsigned int tolerate_time = 0;
	char cmpcnt = 0;
	
//	printf("in mb_opprocepriorit\n");
	reagentA = operate_head1->operate.reagent;	
	reagentB = operate_head2->operate.reagent;	
	reagentC = operate_head3->operate.reagent;
	gettimeofday(&now, NULL);
	tolerate_time = now.tv_sec - begin_time.tv_sec +  30;
	
	if (NEED_PRINTF)
	printf("tolerate_time %d operate_head1->operate.time = %d operate_head2->operate.time = %d operate_head3->operate.time = %d\n",
		tolerate_time,operate_head1->operate.time,operate_head2->operate.time,operate_head3->operate.time);


	if (reagentA ==  STOP_OPERATE && ewkeventA == BUSY_WORK)//还没执行停止操作
	{
		operate_head_table[0] = operate_head1;
		
	}

	if (reagentB ==  STOP_OPERATE && ewkeventB == BUSY_WORK)
	{
		operate_head_table[1] = operate_head2;
	}

	if (reagentC ==  STOP_OPERATE && ewkeventC == BUSY_WORK)
	{
		operate_head_table[2] = operate_head3;
	}

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
#if DE_TONG
//	printf("headsel reagentB=%d, reagentC=%d\n",reagentB,reagentC);
	if (reagentA >= REAGENT_SECEND)
		{
		operate_head_table[0] = operate_head1;
		return 1;
		}
	if (reagentB >= REAGENT_SECEND)
		{
		operate_head_table[1] = operate_head2;
		return 2;
		}
	if (reagentC >= REAGENT_SECEND)
		{
		operate_head_table[2] = operate_head3;
		return 3;
		}
#endif
if (NEED_PRINTF)	
printf("mb_opprocepriorit first\n");
	//小仪器关键试剂在这里判断
	/*
	if ((last_reagentA == REAGENT_DEWAX || last_reagentA == REAGENT_ALCOHOL )
		&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready)
	{
		operate_head_table[0] = operate_head1;
	}
	if ((last_reagentB == REAGENT_DEWAX || last_reagentB == REAGENT_ALCOHOL )
		&& (operate_head2->operate.time <= tolerate_time) 
		 && flg_opwork2ready)
	{
		operate_head_table[1] = operate_head2;
	}
	if ((last_reagentC == REAGENT_DEWAX  || last_reagentC == REAGENT_ALCOHOL )
		&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
	{
		operate_head_table[2] = operate_head3;
	}
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
*/
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit first agian\n");

	if (( last_reagentA < REAGENT_CASE  || last_reagentA >= REAGENT_DAB)
		&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready)
	{
		operate_head_table[0] = operate_head1;
	}
	if (( last_reagentB < REAGENT_CASE  || last_reagentB >= REAGENT_DAB)
		&& (operate_head2->operate.time <= tolerate_time) 
		 && flg_opwork2ready)
	{
		operate_head_table[1] = operate_head2;
	}
	if ((last_reagentC < REAGENT_CASE  || last_reagentC >= REAGENT_DAB)
		&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
	{
		operate_head_table[2] = operate_head3;
	}
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
	if (NEED_PRINTF)	
	printf("reagent_flag = %d reagentA = %d reagentB = %d, reagentC = %d\n",reagent_flag,reagentA,reagentB,reagentC);
	
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit secend\n");
	if (reagentA == NO_REAGENT&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready) 
		 operate_head_table[0] = operate_head1;
	if (reagentB == NO_REAGENT&& (operate_head2->operate.time <= tolerate_time) 
		&& flg_opwork2ready)
		operate_head_table[1] = operate_head2;
	if (reagentC == NO_REAGENT&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
		 operate_head_table[2] = operate_head3;
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit third\n");

		//下次为大容量试剂和试剂架试剂首先滴加试剂架试剂
	if((reagentA < 37 ||reagentA >= REAGENT_DAB )  && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready)
		operate_head_table[0] = operate_head1;
	if((reagentB < 37 ||reagentB >= REAGENT_DAB )  && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready)
		operate_head_table[1] = operate_head2;
	if((reagentC < 37 ||reagentC >= REAGENT_DAB ) && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready)
		operate_head_table[2] = operate_head3;
	
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit forth\n");
	//在允许等待的时间内找同种试剂
	if (reagent_flag == reagentA && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	if (reagent_flag == reagentB && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	if (reagent_flag == reagentC && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;

	if (NEED_PRINTF)	
	printf("mb_opprocepriorit fifth\n");
	reagent_tstA = reagentA < 37 ? -1 : reagentA;
	reagent_tstB = reagentB < 37 ? -1 : reagentB;
	reagent_tstC = reagentC < 37 ? -1 : reagentC;
	//下次为大容量试剂找与上次使用过的大容量试剂相同
	if(last_cabin_reagent == reagent_tstA  && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	if(last_cabin_reagent == reagent_tstB  && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	if(last_cabin_reagent == reagent_tstC  && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;
	
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;


	if (NEED_PRINTF)	
	printf("mb_opprocepriorit sexth\n");
	//在允许等待的时间内找配伍的试剂
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstA) > 0) && 
		(operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstB) > 0) && 
		(operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstC) > 0) && 
		(operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
/*
	//按优先级
	if (NEED_PRINTF)
		printf("mb_opprocepriorit seventh\n");
	if (operate_pri == operate_head1)
		operate_head_table[0] = operate_head1;
	if (operate_pri == operate_head2)
		operate_head_table[1] = operate_head2;
	if (operate_pri == operate_head3)
		operate_head_table[2] = operate_head3;
	if (operate_head_table[0] != NULL || operate_head_table[1] != NULL ||
		operate_head_table[2] != NULL)//有配伍试剂
		return 0;
	*/
	//按时间顺序
	if (NEED_PRINTF)
		printf("mb_opprocepriorit eighth\n");
		cmpcnt = mb_getminnumber(operate_head1->operate.time,operate_head2->operate.time,operate_head3->operate.time);
	if (cmpcnt == 0)
		operate_head_table[0] = operate_head1;
	else if(cmpcnt == 1)
		operate_head_table[1] = operate_head2;
	else if (cmpcnt == 2)
		operate_head_table[2] = operate_head3;

	
	return 0;
}

#else
int mb_opprocepriorit(operate_head_list* operate_head_table[])
{
	unsigned char reagentA = 0,reagentB = 0,reagentC = 0;
	char reagent_tstA = 0,reagent_tstB = 0,reagent_tstC = 0;
	struct timeval now;
	unsigned int tolerate_time = 0,now_time, dest_time;
	char cmpcnt = 0;
	static char have_first_str[3] = {0};
	unsigned char last_reagent = 0,i;	
//	printf("in mb_opprocepriorit\n");
	reagentA = operate_head1->operate.reagent;	
	reagentB = operate_head2->operate.reagent;	
	reagentC = operate_head3->operate.reagent;
	gettimeofday(&now, NULL);
	tolerate_time = now.tv_sec - begin_time.tv_sec +  10;
	now_time = now.tv_sec - begin_time.tv_sec;
	if (NEED_PRINTF)
	printf("tolerate_time %d operate_head1->operate.time = %d operate_head2->operate.time = %d operate_head3->operate.time = %d\n",
		tolerate_time,operate_head1->operate.time,operate_head2->operate.time,operate_head3->operate.time);
	
		
	
		
	if (reagentA ==  STOP_OPERATE && ewkeventA == BUSY_WORK)//还没执行停止操作
	{
		operate_head_table[0] = operate_head1;
		
	}

	if (reagentB ==  STOP_OPERATE && ewkeventB == BUSY_WORK)
	{
		operate_head_table[1] = operate_head2;
	}

	if (reagentC ==  STOP_OPERATE && ewkeventC == BUSY_WORK)
	{
		operate_head_table[2] = operate_head3;
	}

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
#if DE_TONG
//	printf("headsel reagentB=%d, reagentC=%d\n",reagentB,reagentC);
	if (reagentA >= REAGENT_SECEND)
		{
		operate_head_table[0] = operate_head1;
		return 1;
		}
	if (reagentB >= REAGENT_SECEND)
		{
		operate_head_table[1] = operate_head2;
		return 2;
		}
	if (reagentC >= REAGENT_SECEND)
		{
		operate_head_table[2] = operate_head3;
		return 3;
		}
#endif
if (NEED_PRINTF)	
printf("mb_opprocepriorit first\n");
	//小仪器关键试剂在这里判断
	if ((last_reagentA == REAGENT_DEWAX || last_reagentA == REAGENT_ALCOHOL )
		&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready)
	{
		operate_head_table[0] = operate_head1;
	}
	if ((last_reagentB == REAGENT_DEWAX || last_reagentB == REAGENT_ALCOHOL )
		&& (operate_head2->operate.time <= tolerate_time) 
		 && flg_opwork2ready)
	{
		operate_head_table[1] = operate_head2;
	}
	if ((last_reagentC == REAGENT_DEWAX  || last_reagentC == REAGENT_ALCOHOL )
		&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
	{
		operate_head_table[2] = operate_head3;
	}
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit first agian\n");

	if (( last_reagentA < REAGENT_CASE  || last_reagentA >= REAGENT_DAB)
		&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready)
	{
		operate_head_table[0] = operate_head1;
	}
	if (( last_reagentB < REAGENT_CASE  || last_reagentB >= REAGENT_DAB)
		&& (operate_head2->operate.time <= tolerate_time) 
		 && flg_opwork2ready)
	{
		operate_head_table[1] = operate_head2;
	}
	if ((last_reagentC < REAGENT_CASE  || last_reagentC >= REAGENT_DAB)
		&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
	{
		operate_head_table[2] = operate_head3;
	}
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
	if (NEED_PRINTF)	
	printf("reagent_flag = %d reagentA = %d reagentB = %d, reagentC = %d\n",reagent_flag,reagentA,reagentB,reagentC);
	
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit secend\n");
	if (reagentA == NO_REAGENT&& (operate_head1->operate.time <= tolerate_time)
		 && flg_opwork1ready) 
		 operate_head_table[0] = operate_head1;
	if (reagentB == NO_REAGENT&& (operate_head2->operate.time <= tolerate_time) 
		&& flg_opwork2ready)
		operate_head_table[1] = operate_head2;
	if (reagentC == NO_REAGENT&& (operate_head3->operate.time <= tolerate_time)
		 && flg_opwork3ready)
		 operate_head_table[2] = operate_head3;
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit third\n");

		//下次为大容量试剂和试剂架试剂首先滴加试剂架试剂
	if((reagentA < 37 ||reagentA >= REAGENT_DAB )  && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready)
		operate_head_table[0] = operate_head1;
	if((reagentB < 37 ||reagentB >= REAGENT_DAB )  && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready)
		operate_head_table[1] = operate_head2;
	if((reagentC < 37 ||reagentC >= REAGENT_DAB ) && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready)
		operate_head_table[2] = operate_head3;
	
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
	
	if (NEED_PRINTF)	
	printf("mb_opprocepriorit forth\n");
	//在允许等待的时间内找同种试剂
	if (reagent_flag == reagentA && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	if (reagent_flag == reagentB && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	if (reagent_flag == reagentC && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;

	if (NEED_PRINTF)	
	printf("mb_opprocepriorit fifth\n");
	reagent_tstA = reagentA < 37 ? -1 : reagentA;
	reagent_tstB = reagentB < 37 ? -1 : reagentB;
	reagent_tstC = reagentC < 37 ? -1 : reagentC;
	//下次为大容量试剂找与上次使用过的大容量试剂相同
	if(last_cabin_reagent == reagent_tstA  && (operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	if(last_cabin_reagent == reagent_tstB  && (operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	if(last_cabin_reagent == reagent_tstC  && (operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;
	
	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;


	if (NEED_PRINTF)	
	printf("mb_opprocepriorit sexth\n");
	//在允许等待的时间内找配伍的试剂
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstA) > 0) && 
		(operate_head1->operate.time <= tolerate_time)&& flg_opwork1ready && temper_control1[0].state != START_FAN)
		operate_head_table[0] = operate_head1;
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstB) > 0) && 
		(operate_head2->operate.time <= tolerate_time)&& flg_opwork2ready && temper_control2[0].state != START_FAN)
		operate_head_table[1] = operate_head2;
	
	if ((mb_checkbakreagent(reagent_flag, reagent_tstC) > 0) && 
		(operate_head3->operate.time <= tolerate_time)&& flg_opwork3ready && temper_control3[0].state != START_FAN)
		operate_head_table[2] = operate_head3;

	if (mb_opheadheaterpriorit(operate_head_table) >= 0)
		return 0;
/*
	//按优先级
	if (NEED_PRINTF)
		printf("mb_opprocepriorit seventh\n");
	if (operate_pri == operate_head1)
		operate_head_table[0] = operate_head1;
	if (operate_pri == operate_head2)
		operate_head_table[1] = operate_head2;
	if (operate_pri == operate_head3)
		operate_head_table[2] = operate_head3;
	if (operate_head_table[0] != NULL || operate_head_table[1] != NULL ||
		operate_head_table[2] != NULL)//有配伍试剂
		return 0;
	*/
	//按时间顺序
	if (NEED_PRINTF)
		printf("mb_opprocepriorit eighth\n");
		cmpcnt = mb_getminnumber(operate_head1->operate.time,operate_head2->operate.time,operate_head3->operate.time);
	if (cmpcnt == 0)
		operate_head_table[0] = operate_head1;
	else if(cmpcnt == 1)
		operate_head_table[1] = operate_head2;
	else if (cmpcnt == 2)
		operate_head_table[2] = operate_head3;

	
	return 0;
}
#endif



int ct_calateimeonehshelftime(operate_head_list* operate_head_p, unsigned char last_reagent,
	time_cal_t* work_time)
{
	char reagent_shelf_cnt = 0,stp_cnt = 0;
	BOOL have_dewax = FALSE,have_ER = FALSE;
	//int time_tmp = 0, max_time = 0,exchange_reagent_time = 0,
	//	tem_time = 0,reagent_shelf_time =0, fan_time = 10*60;
	operate_t* operate_p;
	struct timeval now;

	if (operate_head_p->operate.reagent == STOP_OPERATE)//刚好运行到最后一步
		return 0;
	
/*
	if (last_reagent == REAGENT_WASH && 
		(operate_head_p->operate.reagent == REAGENT_ER1 || operate_head_p->operate.reagent == REAGENT_ER2))
		work_time->fan_time = 5 * 60;

	if ((last_reagent == REAGENT_ER1 || last_reagent == REAGENT_ER2) &&
		operate_head_p->operate.reagent == REAGENT_WASH )
		work_time->fan_time = 0;
	*/	
		operate_p = &(operate_head_p->operate) ;
		while(operate_p->next->reagent != STOP_OPERATE)//轮询一片玻片
		{
			//试剂切换时间
			if (operate_p->reagent != operate_p->next->reagent)
			{
				if (operate_p->next->reagent == REAGENT_WATER || 
					operate_p->next->reagent == REAGENT_WASH)
					work_time->exchange_reagent_time += 35;
				else if (operate_p->next->reagent > REAGENT_WASH && 
					operate_p->next->reagent <= REAGENT_ER2)
					work_time->exchange_reagent_time += 30;
				else
					work_time->exchange_reagent_time += 15;
			}

			//试剂架试剂统计
			if(operate_p->reagent < 37 || operate_p->reagent >= REAGENT_DAB)
				reagent_shelf_cnt++;

			if (operate_p->reagent == REAGENT_DEWAX)
				have_dewax = TRUE;
			if (operate_p->reagent == REAGENT_ER1 || operate_p->reagent == REAGENT_ER2)
				have_ER = TRUE;			
			
			//加热温度时间
			if (operate_p->temp >= 90)
				work_time->tem_time += 60 * 7;			
			else if (operate_p->temp >= 70)
				work_time->tem_time += 60;
			else if (operate_p->temp >= 30)
				work_time->tem_time += 30;

	
				
			stp_cnt++;
			operate_p = operate_p->next;
		}
	//	printf("first_cac&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n");
		//风机时间
		work_time->fan_time = 5 * 60 * (have_ER);
		//全部孵育时间
		gettimeofday(&now, NULL);
		while(operate_head_p != NULL)	//轮询一架玻片
		{	
			
			operate_p = &(operate_head_p->operate);
			while(operate_p->next->reagent != STOP_OPERATE)//轮询一片玻片
			{
			if (operate_p->time > work_time->max_time)//修复时间可以不同取最大
				work_time->max_time = operate_p->time;
			operate_p = operate_p->next;
			}
			work_time->slide_cnt++;
			operate_head_p = operate_head_p->next_head;
		}
		
		work_time->max_time -= now.tv_sec - begin_time.tv_sec;
		

	//	if (work_time->slide_cnt >5)//试剂架试剂清洗
	//		work_time->reagent_shelf_time = reagent_shelf_cnt * 15;
				
		work_time->mov_time = work_time->slide_cnt * stp_cnt * 3;
	//	work_time->discharge_time= stp_cnt * 7 + stp_cnt * 5;//排液和风机时间

	printf("work_time->exchange_reagent_time=%d ,work_time->reagent_shelf_time=%d,work_time->tem_time=%d.work_time->max_time=%d , work_time->fan_time=%d,work_time->mov_time=%d,work_time->discharge_time=%d\n",
		work_time->exchange_reagent_time,work_time->reagent_shelf_time,work_time->tem_time,
		work_time->max_time, work_time->fan_time,work_time->mov_time, work_time->discharge_time);
	
return work_time->exchange_reagent_time + work_time->reagent_shelf_time + work_time->tem_time + 
	work_time->max_time + work_time->fan_time + work_time->mov_time + work_time->discharge_time;
		
}

//指定时间中查出步数
int ct_getdesttimestp(operate_head_list* comp_head_p,int des_time)
{
	operate_t* operate_p;
	int stp_cnt = 0;
	struct timeval now;
	
	gettimeofday(&now, NULL);
//printf("des_time=%d,",des_time);	
		operate_p = &(comp_head_p->operate);
		while(operate_p->reagent != STOP_OPERATE)//轮询一片玻片
		{
	//		printf("operate_p->time=%d\n",operate_p->time);
			if ((operate_p->time - (now.tv_sec - begin_time.tv_sec)) >= des_time)//修复时间可以不同取最大
			{
				printf("stp_cnt=%d\n",stp_cnt);
				return stp_cnt;
			}
			stp_cnt++;	
			operate_p = operate_p->next;
		}
		printf("stp_cnt=%d\n",stp_cnt);
		return stp_cnt;
}
int ct_patchstptime(const time_cal_t des_time,const time_cal_t comp_time1,
	const time_cal_t comp_time2,operate_head_list* comp_head_p1,operate_head_list* comp_head_p2)
{
	int all_time_add1 = 0,all_time_add2 = 0;

	printf("des_time.all_time=%d,comp_time1.all_time=%d,comp_time2.all_time=%d, comp_time1.slide_cnt=%d, comp_time2.slide_cnt=%d\n",
		des_time.max_time,comp_time1.max_time,comp_time2.max_time, comp_time1.slide_cnt, comp_time2.slide_cnt);
	if (des_time.max_time <= comp_time1.max_time)
		all_time_add1 = ct_getdesttimestp(comp_head_p1,des_time.max_time) *
							(comp_time1.slide_cnt *3 + 7);
	else if (comp_time1.max_time != 0)
		all_time_add1 = comp_time1.mov_time +  comp_time1.discharge_time;

	if (des_time.max_time <= comp_time2.max_time)
		all_time_add2 =  ct_getdesttimestp(comp_head_p2,des_time.max_time) *( comp_time2.slide_cnt *3 + 7);
	else if (comp_time2.max_time != 0)
		all_time_add2 = comp_time2.mov_time + comp_time2.discharge_time;

	printf("all_time_add1=%d,all_time_add2=%d^^^^^^\n",all_time_add1,all_time_add2);	
	return all_time_add1 + all_time_add2;
}
//只在开始运行计算其中一架运行其他几架重新计算
int ct_reportcaculateprocetime(void)
{
	char netbuf_write[50] = {0};
	
//	int all_timeA = 0,all_timeB = 0,all_timeC = 0;
	int all_timeA_tmp = 0,all_timeB_tmp = 0,all_timeC_tmp = 0;
	memset(&work_timeA,0,sizeof(time_cal_t));
	memset(&work_timeB,0,sizeof(time_cal_t));
	memset(&work_timeC,0,sizeof(time_cal_t));
	
	pthread_mutex_lock(&head_lock);
	ct_patchtime(operate_head1);//
	ct_patchtime(operate_head2);//
	ct_patchtime(operate_head3);//
	if (ewkeventA == BUSY_WORK)
	work_timeA.all_time = all_timeA_tmp = ct_calateimeonehshelftime(operate_head1, last_reagentA, &work_timeA);
	if (ewkeventB == BUSY_WORK)
	work_timeB.all_time = all_timeB_tmp = ct_calateimeonehshelftime(operate_head2, last_reagentB, &work_timeB);
	if (ewkeventC == BUSY_WORK)
	work_timeC.all_time = all_timeC_tmp = ct_calateimeonehshelftime(operate_head3, last_reagentC, &work_timeC);
			//运行时全部架子的时间根据超过5min的步数进行移液时间的统计
/*
	if (ewkeventA == BUSY_WORK)
		work_timeA.all_time =all_timeA_tmp + ct_patchstptime(work_timeA,work_timeB,work_timeC,operate_head2,operate_head3);
		
	if (ewkeventB == BUSY_WORK)
		work_timeB.all_time =all_timeB_tmp +  ct_patchstptime(work_timeB,work_timeA,work_timeC,operate_head1,operate_head3);

	if (ewkeventC == BUSY_WORK)
		work_timeC.all_time =all_timeC_tmp +  ct_patchstptime(work_timeC,work_timeA,work_timeB,operate_head1,operate_head2);
*/
	if (pthread_mutex_unlock(&head_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");

	printf("all_timeA=%d,all_timeB=%d,all_timeC=%d***********************\n",
		work_timeA.all_time,work_timeB.all_time,work_timeC.all_time);

	memcpy(((unsigned char *)&netbuf_write[0]), (void*)&(work_timeA.all_time),4);
		memcpy(((unsigned char *)&netbuf_write[4]), (void*)&(work_timeB.all_time),4);
		memcpy(((unsigned char *)&netbuf_write[8]), (void*)&(work_timeC.all_time),4);
		
	nt_sendpacketdata(ESTIMATE_TIME,netbuf_write,12);
return 0;
}
/**************执行操作*****************/
void 	mb_procework(void)
{
	operate_head_list* operate_head_p = NULL;
	operate_head_list* last_head_p = NULL;			//当前操作玻片的上个玻片用于free
	operate_head_list* free_head_p = NULL;
	static	operate_head_list* operate_head = NULL;
//	operate_t* operate_p = NULL;
	operate_t* free_operate_p = NULL;
//	unsigned char position = 0;
	unsigned char isall_reagent_same = 0;
	dispense_t dispense[11]; 
	dispense_t dispense_temp;
	int i = 0, j = 0, g=0;
	static int count=0;
	struct timeval now;
	temper_control_t* temper_control = NULL;
	int is_alltemp_zero = 0;
	static BOOL is_VP1_0N = FALSE;
	static unsigned int Discharge_counter = 0;
	static BOOL IsStartLock1 = TRUE,IsStartLock2 = TRUE,IsStartLock3 = TRUE;//流程的第一次锁定
//	char reagent_code[20] = {0};
	BOOL start_Discharge_counter = FALSE;
	operate_head_list*  operate_head_table[3] = {NULL};
	char tcpdata = 0;
	//int operate_sel_res = 0;
	if (ewkevent == MAINTAIN_WORK)
		return;
//	printf("in mb_procework\n");
//	printf("!!!!!!!!!!!!!!!!!!!!!!!StartDispenseC=%d/n", StartDispenseC);
	memset(dispense, 0, sizeof(dispense_t) * 11);
//	printf("mini_finished3=%x\n",mini_finished3);
//	printf("operate_head_p %d operate_head %d", operate_head_p, operate_head);
/*		printf("data in operate_head1=%d\n", operate_head1);
	mb_printfoperatelist(operate_head1);
	printf("data in operate_head2=%d\n",operate_head2);
	mb_printfoperatelist(operate_head2);
	printf("data in operate_head3=%d\n",operate_head3);
	mb_printfoperatelist(operate_head3);
	*/

	do_work_hydration();
	if (operate_head1->operate.reagent == STOP_OPERATE && operate_head2->operate.reagent == STOP_OPERATE
		&& operate_head3->operate.reagent == STOP_OPERATE)
	{
	//	GPIO_OutSet(VP1);	//空闲关闭	//不能在这里关闭，还有水合操作
		is_VP1_0N = FALSE;
	}
	else if(is_VP1_0N == FALSE)
	{
	/*
		GPIO_OutClear(V4);	
		GPIO_OutClear(V22);	
		 GPIO_OutSet(V9);	
		 GPIO_OutSet(V10);//放气缸气才能启动
		 sleep(3);
	//	 GPIO_OutClear(VP1);	
		 is_VP1_0N = TRUE;
	*/
	}
/*		scanf("%d", &i);
		if (i == -1)
			return;
		else
			printf("Compatible = %d\n",mb_searchcomatiblereagent(&reagent_code[i]));
	*/	

		gettimeofday(&now, NULL);
		pthread_mutex_lock(&head_lock);	//轮询三组玻片架
		
		if (operate_head == operate_head1)		
		{	
		//	printf("**************in operate_head1**************\n");
			operate_head = operate_head2;
			temper_control = temper_control2;
		}
		else if (operate_head == operate_head2)
		{
		//	printf("**************in operate_head2**************\n");
			operate_head = operate_head3;
			temper_control = temper_control3;
		}
		else if (operate_head == operate_head3 || operate_head == NULL)
		{
		//	printf("**************in operate_head3**************\n");
			operate_head = operate_head1;
			temper_control = temper_control1;
		}
		if (pthread_mutex_unlock(&head_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_Lock");

	md_lockreagentshelf();//强制停止检测试剂架锁定
		
	if (operate_head == operate_head1 && !flg_opwork1ready)
		return;
	if (operate_head == operate_head2 && !flg_opwork2ready)
			return;
	if (operate_head == operate_head3 && !flg_opwork3ready)
			return;
	
	pthread_mutex_lock(&head_lock);
			ct_patchtime(operate_head);//确保每次都执行
	if (pthread_mutex_unlock(&head_lock) != 0)
		lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_Lock");

	
	

#ifndef BIG_VERSION

	{
		memset(operate_head_table,0,sizeof(operate_head_table));
		pthread_mutex_lock(&head_lock);
		  mb_opprocepriorit(operate_head_table);//operate_head_table中为NULL不运行，有就运行
		if (pthread_mutex_unlock(&head_lock) != 0)
			lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head-Lock");
		for(i = 0; i < 3; i++)
		{
			if ((operate_head == operate_head_table[i]) && (operate_head != NULL))//此架玻片为下次操作的目标架次
				break;
		}
		if (i == 3)
			return;

		
		if (operate_head == operate_head1)
		{
			temper_control = temper_control1;
			if (NEED_PRINTF)
				{
			printf("work operate_head = operate_head1\n");
		//	lprintf(log_my, INFO,"work operate_head = operate_head1\n");
				}
		}
		else if (operate_head == operate_head2)
		{
			temper_control = temper_control2;
			if (NEED_PRINTF)
				{
			printf("work operate_head = operate_head2\n");
		//	lprintf(log_my, INFO,"work operate_head = operate_head2\n");
				}
		}
		else if (operate_head == operate_head3)
		{
			temper_control = temper_control3;
			if (NEED_PRINTF)
				{
			printf("work operate_head = operate_head3\n");
		//	lprintf(log_my, INFO,"work operate_head = operate_head3\n");
				}
		}
	}
#endif 	

		if (md_lockreagentshelf() < 0)	//当主臂还没将操作完成必须锁住 
		{
			return;
		}
			
		mb_mixprogressintime(now.tv_sec - begin_time.tv_sec,operate_head);

	if (operate_head == operate_head1 && !flg_opwork1ready)
			return;
	if (operate_head == operate_head2 && !flg_opwork2ready)
			return;
	if (operate_head == operate_head3 && !flg_opwork3ready)
			return;
		
		/*******************当3架都在加热时不允许其他动作continue**********************/
		if ((operate_head == operate_head1) && (flg_temperheating1))	//当一架玻片还在加热过程中读其他架
			return;
		if ((operate_head == operate_head2) && (flg_temperheating2))
			return;
		if ((operate_head == operate_head3) && (flg_temperheating3))
			return;

	
		
		if (start_Discharge_counter)
		{
			Discharge_counter++;
			if (Discharge_counter > 360000)
				Discharge_counter = 36000;
		}

		
		//if (count > 0x0001ffff )
	//		if (count > 0x00000005 )
		if (NEED_PRINTF)
			{
			{count = 0;
			lprintf(log_my, INFO,"in_temper_control=%d %d %d\n",flg_temperheating1,flg_temperheating2,flg_temperheating3);
		printf("operate_head = %d flg_temperheating1=%din_temper_control2=%din_temper_control3=%d\n",operate_head,flg_temperheating1,flg_temperheating2,flg_temperheating3);
		printf("operate.time =%d (now.tv_sec - begin_time.tv_sec) = %d\n", operate_head->operate.time, (now.tv_sec - begin_time.tv_sec));
			lprintf(log_my, INFO,"operate.time =%d all = %d\n", operate_head->operate.time, (now.tv_sec - begin_time.tv_sec));
			}
		count++;
	
		
			printf("flg_mianarmstop_a = %d flg_mianarmstop_b=%d flg_mianarmstop_c=%d\n", flg_mianarmstop_a, flg_mianarmstop_b,flg_mianarmstop_c);
		}
#ifdef BIG_VERSION
{
		//判断各自玻片架的动作是否完成 
	//	mini_work_finished[2] = TRUE;
	printf("ArmCabinWork_finished[0]=%d\n", ArmCabinWork_finished[0]);
			if ((operate_head == operate_head1) && ((ArmCabinWork_finished[0] == FALSE) || !flg_mianarmstop_a))
				return;
			if ((operate_head == operate_head2) && ((ArmCabinWork_finished[1] == FALSE) || !flg_mianarmstop_b))
				return;
			if ((operate_head == operate_head3) && ((ArmCabinWork_finished[2] == FALSE) || !flg_mianarmstop_c))
				return;	
}
#else
{
			if (!flg_mianarmstop_a || !flg_mianarmstop_b || !flg_mianarmstop_c)//小仪器
				return;
}	
#endif
	
		if ((operate_head->operate.reagent == STOP_OPERATE))//判断是否是玻片的最后一个步骤且全部完成
		{
			if (flg_opwork1ready && (operate_head == operate_head1) && !flg_temperheating1)
				{
				
					hydrateA.start_time = now.tv_sec;
					hydrateA.flage = TRUE;  //水合标志
					if (Discharge_counter > 600)
					{
						NeedDischarge = TRUE;
						start_Discharge_counter = TRUE;
					}
					while (!HEAD1_STEP_SENDED) usleep(100000);
						Discharge_counter = 0;
					IsStartLock1 = TRUE;
					
					pthread_mutex_lock(&head_step_lock);
					workstep_state_a = 0X01110000;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
						mb_mainworkstop(1);	//通知自控臂1动作结束
				}
			if (flg_opwork2ready && (operate_head == operate_head2) && !flg_temperheating2)
				{
					
					hydrateB.start_time = now.tv_sec;
					hydrateB.flage= TRUE; 
					if (Discharge_counter > 600)
					{
						NeedDischarge = TRUE;
						start_Discharge_counter = TRUE;
					}
					while (!HEAD2_STEP_SENDED) usleep(100000);
						Discharge_counter = 0;
					IsStartLock2 = TRUE;
					
					pthread_mutex_lock(&head_step_lock);
					workstep_state_b = 0X01110000;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
					mb_mainworkstop(2);
				}
			if (flg_opwork3ready && (operate_head == operate_head3) && !flg_temperheating3)
				{
					
					hydrateC.start_time = now.tv_sec;
					hydrateC.flage= TRUE; 
					if (Discharge_counter > 600)
					{
						NeedDischarge = TRUE;
						start_Discharge_counter = TRUE;
					}
					Discharge_counter = 0;
					while (!HEAD3_STEP_SENDED) usleep(100000);
					IsStartLock3 = TRUE;
					
					pthread_mutex_lock(&head_step_lock);
					workstep_state_c = 0X01110000;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
					mb_mainworkstop(3);
				}
			
			return;
		}
		else if ((operate_head->operate.reagent == STOP_OPERATE) && (operate_head->next_head != NULL) 
					&& (operate_head->operate.time <= now.tv_sec - begin_time.tv_sec))//free余下表头
		{
			pthread_mutex_lock(&head_lock);
			while(operate_head->next_head != NULL)
			{
				last_head_p = operate_head;
				while(!flg_mainproexit)
				{
					free_head_p = last_head_p->next_head;
					if (free_head_p->next_head == NULL)
					{
						free(free_head_p);
						free_head_p = NULL;
						last_head_p->next_head = NULL;
						break;
					}

					last_head_p = last_head_p->next_head;
				}
			}
			memset(&(operate_head->operate), 0, sizeof(operate_head->operate));
			operate_head->operate_work_time = 0;
			operate_head->operate.reagent = STOP_OPERATE;
			if (pthread_mutex_unlock(&head_lock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_Lock");
			return;
		}

		/****************流程中有步骤*****************/
	/*	if (operate_head == operate_head1)
		{
			md_lockreagentshelf();
				if (IsStartLock1)
					IsStartLock1 = FALSE;
		}
	*/
		operate_head_p = operate_head;
					gettimeofday(&now, NULL);//patchtime后必须在获取一次
		if (operate_head_p->operate.time <= (now.tv_sec - begin_time.tv_sec))
		{
			{
				
			}
			
		//	if (!ct_patchtime(operate_head))//	还没到运行时间
		//		return;	
				
			if (operate_head == operate_head1)
			{
				if ((operate_head->operate.reagent == REAGENT_DAB) && (isDAB_mixedA == FALSE))
					return;
				if ((operate_head->operate.reagent == REAGENT_SECEND) && (isDAB_mixedA_next == FALSE))
					return;
					while (!HEAD1_STEP_SENDED) usleep(100000);
					pthread_mutex_lock(&head_step_lock);
					workstep_state_a++;
					workstep_state_a &= 0X0000FFFF; 
					HEAD1_STEP_SENDED = FALSE;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
				//	head1_start_time = now.tv_sec - begin_time.tv_sec;
			}
			if (operate_head == operate_head2)
			{
				if ((operate_head->operate.reagent == REAGENT_DAB) && (isDAB_mixedB == FALSE))
					return;
				if ((operate_head->operate.reagent == REAGENT_SECEND) && (isDAB_mixedB_next == FALSE))
					return;
				while (!HEAD2_STEP_SENDED) usleep(100000);
				
					pthread_mutex_lock(&head_step_lock);
					workstep_state_b++;
					workstep_state_b &= 0X0000FFFF; 	
					HEAD2_STEP_SENDED = FALSE;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
				//	head2_start_time = now.tv_sec - begin_time.tv_sec;
			}
			if (operate_head == operate_head3)
			{
				if ((operate_head->operate.reagent == REAGENT_DAB) && (isDAB_mixedC == FALSE))
					return;
				if ((operate_head->operate.reagent == REAGENT_SECEND) && (isDAB_mixedC_next == FALSE))
					return;
					while (!HEAD3_STEP_SENDED) usleep(100000);
				{
					pthread_mutex_lock(&head_step_lock);
					workstep_state_c++;
					workstep_state_c &= 0X0000FFFF; 
					HEAD3_STEP_SENDED = FALSE;
					if (pthread_mutex_unlock(&head_step_lock) != 0)
						lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
				//	head3_start_time = now.tv_sec - begin_time.tv_sec;
				}
			}
			i = 0;
			memset(dispense, 0, sizeof(dispense));
			memset(temper_control, 0, sizeof(temper_control_t) * 10);

printf("begin tooooo set\n");
			pthread_mutex_lock(&head_lock);
			while(!flg_mainproexit )	//轮询一架玻片
			{
					if (operate_head_p->operate.reagent == STOP_OPERATE)
					{
						operate_head_p = operate_head_p->next_head;
						if (operate_head_p == NULL)
							break;
						continue;
					}
					//将试剂信息和坐标信息记入dispense，
					//**********************************
				
					dispense[i].reagent = operate_head_p->operate.reagent;
					dispense[i].plate_num = operate_head_p->operate.plate_num;
					memcpy(&dispense[i].reagent_info, &operate_head_p->operate.reagent_info, sizeof(reagent_t));
					//将温度信息和坐标信息记入temper_control，
					temper_control[i].plate_num = operate_head_p->operate.plate_num;
					temper_control[i].time = operate_head_p->operate.next->time - operate_head_p->operate.time; //加热的时间
					temper_control[i].temp = operate_head_p->operate.temp;
					if (temper_control[i].temp == 0)
						temper_control[i].temp = TMP_ZERO;//无需加热需要计算时间
		/****/		operate_head_p->operate_work_time = temper_control[i].time;
						
					free_operate_p = operate_head_p->operate.next;
					operate_head_p->operate = *(operate_head_p->operate.next);
					free(free_operate_p);
					free_operate_p = NULL;

	
				operate_head_p = operate_head_p->next_head;
			if (operate_head_p == NULL)
				break;
			i++;
			}	//一轮查询结束
			if (pthread_mutex_unlock(&head_lock) != 0)
				lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_lock");
		//		reagent_flag = dispense[i].reagent;//test 步骤优化测试时使用

		if (operate_head == operate_head1 && workstep_state_a == 1)
		{
				tcpdata = 1;
				nt_sendpacketdata(WORK_START,&tcpdata,1);
		}
		else if (operate_head == operate_head2 && workstep_state_b == 1)
		{
				tcpdata = 2;
				nt_sendpacketdata(WORK_START,&tcpdata,1);
		}
		else if (operate_head == operate_head3 && workstep_state_c == 1)
		{
				tcpdata = 3;
				nt_sendpacketdata(WORK_START,&tcpdata,1);
		}
			

		printf("一架查询结束 out\n");
			lprintf(log_my, INFO,"一架查询结束 out\n");
		printf("operate_head = %d flg_temperheating1=%din_temper_control2=%din_temper_control3=%d\n",(int)operate_head,flg_temperheating1,flg_temperheating2,flg_temperheating3);
		printf("\n");
		dispense[i + 1].reagent = STOP_OPERATE;	
		//排序
		printf("dispense[i + 1].reagent=%d i = %d\n", dispense[i + 1].reagent, i);
		isall_reagent_same = dispense[0].reagent;
		j=0;
		while(j < 11 && dispense[j].reagent != STOP_OPERATE)
		{
		//	lprintf(log_my, INFO," reagent=%d plate=%d", dispense[j].reagent,dispense[j].plate_num);
			printf(" reagent=%d plate=%d", dispense[j].reagent,dispense[j].plate_num);
			if (isall_reagent_same != dispense[j].reagent)
				isall_reagent_same = 0XFF;
			j++;
		}
		printf("\n");
		if (isall_reagent_same == 0XFF)
		{

	j = 0;
	while(j < 11 && dispense[j].reagent != STOP_OPERATE)
		{
			printf(" %d %d *", dispense[j].reagent,dispense[j].plate_num);
			if (isall_reagent_same != dispense[j].reagent)
				isall_reagent_same = 0XFF;
			j++;
		}
		printf("\n");
		printf("after\n");
			while(i > 0)
			{
				j = i - 1;
				while(j >= 0)
				{
					if (dispense[j].reagent == dispense[i].reagent)
					{
						if (i != j+1)//  相同试剂之间数据移动一位
						{
							dispense_temp = dispense[j];
							
							g = 0;
							do
							{
							dispense[j+g] = dispense[j+g+1];
							g++;
							}while( (j+g+1) <= (i - 1));
							dispense[i - 1] = dispense_temp;
		g = 0;
		while(g < 11 && dispense[g].reagent != STOP_OPERATE)
		{
			printf(" %d %d *", dispense[g].reagent,dispense[g].plate_num);
			g++;
		}
		printf("\n");
						}
						i--;
		
					}

					
						j--;
				}
	

				i--;
			}

			

			i = 0;
			while(i < 11 && dispense[i].reagent != STOP_OPERATE)
			{
				printf(" %d %d*", dispense[i].reagent,dispense[i].plate_num);
				i++;
			}
			printf("\n");
					printf("end\n");
		}
			/*
		{
			while(i > 0)
			{
				j = i - 1;
				while(j >= 0)
				{
					if (dispense[j].reagent == dispense[i].reagent)
					{
						dispense_temp = dispense[i - 1];
						dispense[i - 1] = dispense[j];
						dispense[j] = dispense_temp;
					}

					
						j--;
				}
				i--;
			}
		}
*/
		//试剂架试剂 DAB 修复液为关键试剂
		if (operate_head == operate_head1)
		{	
			if (last_reagentA < REAGENT_CASE || last_reagentA >= REAGENT_DAB
				|| last_reagentA == REAGENT_ER1 || last_reagentA == REAGENT_ER2 
				)
			{
				pthread_mutex_lock(&mutex_critialworklock);
				CriticalWork |= 0X80;
				if (pthread_mutex_unlock(&mutex_critialworklock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_critialworklock");
			}
			//mb_dischargeshelfwateliquid(1);
		}
		else if (operate_head == operate_head2)
		{		
			if (last_reagentB < REAGENT_CASE || last_reagentB >= REAGENT_DAB
				|| last_reagentB == REAGENT_ER1 || last_reagentB == REAGENT_ER2 
				)
			{
				pthread_mutex_lock(&mutex_critialworklock);
				CriticalWork |= 0X40;
				if (pthread_mutex_unlock(&mutex_critialworklock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_critialworklock");
			}
			//mb_dischargeshelfwateliquid(2);
		}
		else if (operate_head == operate_head3)
		{	
			if (last_reagentC < REAGENT_CASE || last_reagentC >= REAGENT_DAB
				|| last_reagentC == REAGENT_ER1 || last_reagentC == REAGENT_ER2
				)
			{
				pthread_mutex_lock(&mutex_critialworklock);
				CriticalWork |= 0X20;
				if (pthread_mutex_unlock(&mutex_critialworklock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error mutex_critialworklock");
			}
			//mb_dischargeshelfwateliquid(3);
		}
		printf("CriticalWork=%x last_reagentA=%d last_reagentB=%d last_reagentC=%d\n",CriticalWork,last_reagentA,last_reagentB,last_reagentC);
	
		/************先滴加试剂再加热**************/
		//发送滴加试剂命令
	//	sleep(2);
//	printf("\ntemper_control=%x\n",temper_control);
		printf("*************************do mb_aspiratedispensework******************\n");
		if (mb_aspiratedispensework(dispense) < 0)
			return;

		//temper_control 指针无故变动 改回来
		if (operate_head == operate_head1)
			temper_control = temper_control1;
		else if (operate_head == operate_head2)
			temper_control = temper_control2;
		else if (operate_head == operate_head3)
			temper_control = temper_control3;
		
#if 0
	if (dispense[0].reagent == NO_REAGENT || dispense[0].plate_num > 30)//不需要minb动作
	{
	}
	else	//否则等待minib动作完成再加热
	{
		if (operate_head_p == operate_head1)
			while(!mini_finished)
				sleep(1);

		if (operate_head_p == operate_head2)
			while(!mini_finished2)
				sleep(1);

		if (operate_head_p == operate_head3)
			while(!mini_finished3)
				sleep(1);
	}
		
#endif
	//	sleep(5);
		//发送加热命令
#if 1
	
		for (i = 0; i < 10; i++)
		{
//		printf("\ntemper_control=%x\n",temper_control);
			if (temper_control[i].temp > is_alltemp_zero)
				is_alltemp_zero = temper_control[i].temp;

			if (temper_control[i].temp >= 20 && temper_control[i].temp != TMP_ZERO)
			{
				if(new_temper)
					temper_control[i].temp = temper_control[i].temp*10 + temp_Dvalmy[temper_control[i].plate_num % 30][temper_control[i].temp] ;//加速温度差值	
				else
					temper_control[i].temp +=  temp_goalval[temper_control[i].temp] / 10;//加速温度差值  
			}
		}
		
	//	if (is_alltemp_zero > 35)
#ifdef EMCTST
if(FALSE)
#else
		if (TRUE)//将持续的时间计入加热为0的时间
	#endif
		{
			printf("*************************do TempContorl******************\n");
			if (temper_control == temper_control1 && ewkeventA != STOP_WORK)
			{
				printf("in flg_temperheating1\n");
				lprintf(log_my, INFO,"in flg_temperheating1\n");
				flg_temperheating1 = TRUE;
				tc_packettempcmd(START_CONTROL1);		
				printf("temp.palte=");
				lprintf(log_my, INFO,"temp.palte=");
				for (i=0;i<10;i++)
					{
					printf(" %d ",temper_control[i].plate_num);
					lprintf(log_my, INFO," %d ",temper_control[i].plate_num);
					}
			}
			else if (temper_control == temper_control2 && ewkeventB != STOP_WORK)
			{
				printf("in flg_temperheating2\n");
				lprintf(log_my, INFO,"in flg_temperheating2\n");
				flg_temperheating2 = TRUE;
				tc_packettempcmd(START_CONTROL2);
				printf("temp.palte=");
				lprintf(log_my, INFO,"temp.palte=");
				for (i=0;i<10;i++)
					{
					printf(" %d ",temper_control[i].plate_num);
					lprintf(log_my, INFO," %d ",temper_control[i].plate_num);
					}
			}
			else if (temper_control == temper_control3 && ewkeventC != STOP_WORK)
			{
				printf("in flg_temperheating3\n");
				lprintf(log_my, INFO,"in in_temper_contro3\n");
				flg_temperheating3 = TRUE;
				tc_packettempcmd(START_CONTROL3);
				printf("temp.palte=");
				lprintf(log_my, INFO,"temp.palte=");
				for (i=0;i<10;i++)
					{
					printf(" %d ",temper_control[i].plate_num);
					lprintf(log_my, INFO," %d ",temper_control[i].plate_num);
					}
			}
		}
		else	//不需加热最高字节置1
		{
			if (temper_control == temper_control1)
			{
				pthread_mutex_lock(&head_step_lock);
				workstep_state_a = workstep_state_a | 0X01010000;
				if (pthread_mutex_unlock(&head_step_lock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
			}
			else if (temper_control == temper_control2)
			{
				pthread_mutex_lock(&head_step_lock);
				workstep_state_b = workstep_state_b | 0X01010000;
				if (pthread_mutex_unlock(&head_step_lock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
			}
			else if (temper_control == temper_control3)
			{
				pthread_mutex_lock(&head_step_lock);
				workstep_state_c = workstep_state_c | 0X01010000;
				if (pthread_mutex_unlock(&head_step_lock) != 0)
					lprintf(log_my, ERROR,"%s","pthread_mutex_unlock error head_step_lock");
			}
		}
#endif	
	

	
	}
		

	

}
char cal_XOR(const char* frame,char num)
{
	char buff = frame[0],i = 0;

	for (i = 1; i < num; i++)
	{
		buff = buff ^ frame[i];

	}
	return buff;
}


/******************************************************************************
*
* Function Name  : Tp_thread_recvserail
* Description	 : The string according to the RSP9000 OME communication protocol format function.
*					   
* Input 		 : None
* Output	 : None
* Return		 : None
*******************************************************************************/
int Tp_thread_recvserail(void* arg)	//	不允许有等待操作
{
	int 	rel, i, j,len,e=0;
	fd_set 	DeviceRead;   //设备读准备就绪;
	fd_set 	DeviceError; // 设备出现错误
	int    	DeviceMax = 0;

	BOOL cabin_portreceiveed_flag = FALSE;
	unsigned char cabin_portcounter = 0;
	unsigned short crc=0; 
	BOOL VRC_flage = FALSE;
	char check_c = 0;
 
	char Ackbuffer[6] ={'M', 2, 0, 0X40, 0XB7, 0X78};
	char Ackbuffer2[6] ={'W', 2, 0, 0X40, 0XB0, 0X60};
	
//	if ((scan_fp = fopen("/mnt/nandflash/bin/scaner.txt", "w+")) == NULL)
//		perror("open scaner\n");

	struct timeval  timecur,timelast;
	struct timeval timeout;

	//pthread_mutex_init(&mutex, NULL);
	//pthread_cond_init(&cond, NULL);
	
	memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
	memset(WriteBuffer, 0x00, sizeof(WriteBuffer));
	
	// init serials
	printf("==========[Tp_thread_recvserail]: Begin to listening all serial data.=======\n ");	
	tcflush(serail_hand[COM2],TCIFLUSH);
	tcflush(serail_hand[port_arm],TCIFLUSH);
	tcflush(serail_hand[port_arm],TCIFLUSH);
	tcflush(serail_hand[port_pump],TCIFLUSH);
	tcflush(serail_hand[cabin_port],TCIFLUSH);
	#ifdef BIG_VERSION
	tcflush(serail_hand[mix_port],TCIFLUSH);
	#endif
//	tcflush(serail_hand[COM5],TCIFLUSH);
	while(!flg_mainproexit)
	{
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		
		FD_ZERO(&DeviceRead);
		FD_ZERO(&DeviceError);
		DeviceMax = serail_hand[COM2] > DeviceMax ? serail_hand[COM2] : DeviceMax;
		DeviceMax = serail_hand[port_arm] > DeviceMax ? serail_hand[port_arm] : DeviceMax;
//DeviceMax = serail_hand[COM5] > DeviceMax ? serail_hand[COM5] : DeviceMax;
		DeviceMax = serail_hand[cabin_port] > DeviceMax ? serail_hand[cabin_port] : DeviceMax;
		DeviceMax = serail_hand[port_pump] > DeviceMax ? serail_hand[port_pump] : DeviceMax;
		#ifdef BIG_VERSION
			DeviceMax = serail_hand[mix_port] > DeviceMax ? serail_hand[mix_port] : DeviceMax;
		#endif
		FD_SET(serail_hand[COM2], &DeviceRead);
//FD_SET(serail_hand[COM5], &DeviceRead);
		FD_SET(serail_hand[port_arm], &DeviceRead);
		FD_SET(serail_hand[port_arm], &DeviceRead);
		FD_SET(serail_hand[cabin_port], &DeviceRead);
		FD_SET(serail_hand[port_pump], &DeviceRead);
	//	FD_SET(serail_hand[COM5], &DeviceRead);
		#ifdef BIG_VERSION
		FD_SET(serail_hand[mix_port], &DeviceRead);
		#endif
		
		rel = select(DeviceMax+1, &DeviceRead, NULL, NULL, &timeout);
		if(rel < 0) {
			perror("select error");
			return -1;
		}
		else
		{
#if 0
		if(FD_ISSET(serail_hand[COM5],&DeviceRead))
		{
		if ((len = read(serail_hand[COM5], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
			{
		printf("COM5 Request read len = %d.: \n", len);
						for (i = 0; i < len; i++)
						printf(" %02x ", serail_recvbuf[i]);
						tcflush(serail_hand[COM5],TCIFLUSH);
			}
		}

	#endif	
		//自控臂可使用单独线程接收保证数据正确响应
			if(FD_ISSET(serail_hand[port_pump],&DeviceRead))
			{
				if ((len = read(serail_hand[port_pump], Readpump, sizeof(Readpump))) > 0)
				{
				
			//		printf("port_pump Request read len = %d.: \n", len);
				//		for (i = 0; i < len; i++)
				//		printf(" %02x ", Readpump[i]);
						
						for (i = 0; i < len; i++)
						{
						 if(flg_startrecvpump)
								pump_readbuf[readindexpump] = Readpump[i];
							
							 if (VRC_flage)//最后一个校验位
							 {
							 	VRC_flage = FALSE;
								 check_c = cal_XOR(pump_readbuf,readindexpump);
								if(check_c == pump_readbuf[readindexpump])
									{
									flg_recvpump = TRUE;
									
									flg_startrecvpump = FALSE;

									/*
									printf("pump finish check_c=%x\n",check_c);
									for (i = 0; i < readindexpump+1;i++)
										printf(" %x ", pump_readbuf[i]);
										*/
									}
								
								readindexpump = 0;
							 }

							
							 
							if (Readpump[i] == 0X03 && flg_startrecvpump)
							{
							VRC_flage = TRUE;
							
							
							}
							readindexpump++;
							if(readindexpump > 20)
							{
								readindexpump = 0;
								memset(pump_readbuf,0,sizeof(pump_readbuf));
								VRC_flage = FALSE;
								flg_startrecvpump = FALSE;
								break;
							}
							if (Readpump[i] == 0X02)
							{
								flg_startrecvpump = TRUE;
								readindexpump = 1;
								pump_readbuf[0] = Readpump[i];
								VRC_flage = FALSE;
							}
						}
						if(i < len)
						{
					
						memset(Readpump,0,sizeof(Readpump));
						}
						
				
					
					
				}
			//	tcflush(serail_hand[port_pump],TCIFLUSH);
				
			
				
				
				memset(Readpump, 0x00, sizeof(Readpump));
				
			} 

			 
			if(FD_ISSET(serail_hand[COM2],&DeviceRead) && !big_version)
			{
				if ((len = read(serail_hand[COM2], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
				{
			//		tcflush(serail_hand[COM2],TCIFLUSH);
				if (PRINTF)
					{
					printf("COM2 Request read len = %d.: \n", len);
					lprintf(log_my, INFO,"COM2 read len = %d.: \n", len);
					for (i = 0; i < len; i++)
						{
						printf(" %02x ", serail_recvbuf[i]);
						lprintf(log_my, INFO," %02x ", serail_recvbuf[i]);
						}
					printf("\n\n");
					}
		
				sm_parseminibdframe(COM2, len);
					
				}
				
				
			
				
				
				memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
				
			} 
#ifdef BIG_VERSION
			if(FD_ISSET(serail_hand[mix_port],&DeviceRead))
		   {
			   if ((len = read(serail_hand[mix_port], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
			   {
			   /*
				   printf("mix_port Request read len = %d.: \n", len);
				   
				   for (i = 0; i < len; i++)
					   printf(" %02x ", serail_recvbuf[i]);
				   printf("\n\n");
					*/				   
			   tcflush(serail_hand[mix_port],TCIFLUSH); 

			   crc = usMBCRC16(&serail_recvbuf[0], len -2);
			   printf(" crc =%x",crc);
			   if (((crc & 0x00ff) != serail_recvbuf[len-2]) || ((crc >> 8) != serail_recvbuf[len - 1]))
			   	{
					printf("CRC ERROR MIX\n");
			   } 
			  else if (serail_recvbuf[3] != 0X40)
			   {
				   printf("anser recieve\n");
				   //crc = usMBCRC16(Ackbuffer, 4);
			   //  memcpy(&Ackbuffer[4],&crc,2);
			   if(serail_recvbuf[3] != 0X22)//从机主动回复不发送ACK，防止其他线程发送
					write(serail_hand[mix_port],Ackbuffer,4 + 2);

					ExtractMix(serail_recvbuf[3], &serail_recvbuf[4], len - 4);
				   Mix_Res = TRUE;
				   
			   }
			   else
			   {
				   printf("ACK recieve\n");
				   MixACK = TRUE;
			   }
				   
			   memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
			   }
		   }

#endif

			 
			if(FD_ISSET(serail_hand[port_arm],&DeviceRead))
			{
				
				if ((len = read(serail_hand[port_arm], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
				{
					tcflush(serail_hand[port_arm],TCIFLUSH);

				if (PRINTF)
					{
					printf("port_arm Request read len = %d.: \n", len);
					lprintf(log_my, INFO,"port_arm = %d.: \n", len);
					for (i = 0; i < len; i++)
						{
						lprintf(log_my, INFO," %02x ", serail_recvbuf[i]);
						printf(" %02x ", serail_recvbuf[i]);
						}
					printf("\n\n");
					} 
				}
			//	usleep(10000);
				
				
				sb_parseframe(RSP9000_FRAME, len);
			//	tcflush(serail_hand[port_arm],TCIFLUSH);
				
				memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
				
			} 
		#ifdef BIG_VERSION	
			if(FD_ISSET(serail_hand[cabin_port],&DeviceRead) )
			{
			   if ((len = read(serail_hand[cabin_port], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
			   {
			   /*
				   printf("WG_port Request read len = %d.: \n", len);
				   
				   for (i = 0; i < len; i++)
					   printf(" %02x ", serail_recvbuf[i]);
				   printf("\n\n");
				*/
			   tcflush(serail_hand[cabin_port],TCIFLUSH); 
			     crc = usMBCRC16(&serail_recvbuf[0], len -2);
			   if (((crc & 0x00ff) != serail_recvbuf[len-2]) || ((crc >> 8) != serail_recvbuf[len - 1]))
			   	{
					printf("CRC ERROR CABIN\n");
			   } 
			  else if (serail_recvbuf[3] != 0X40)
			   {
			//	   printf("WGanser recieve\n");
				   //crc = usMBCRC16(Ackbuffer, 4);
			   //  memcpy(&Ackbuffer[4],&crc,2);
			   
					write(serail_hand[cabin_port],Ackbuffer2,4 + 2);
				   
					ExtractWG(serail_recvbuf[3], &serail_recvbuf[4], len - 6);
				   WG_Res = TRUE;
				   
			   }
			   else
			   {
				   printf("WGACK recieve\n");
				   WGACK = TRUE;
			   }
				   
			   memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
			   }
		   }

		#else
		if(FD_ISSET(serail_hand[cabin_port],&DeviceRead) && !readfinished485)
			{											//防止两线程同时写操作

				
				if ((len = read(serail_hand[cabin_port], serail_recvbuf, sizeof(serail_recvbuf))) > 0)
				{
					/*
					for (i = 0; i < len; i++)
					{
						printf(" %02x ", serail_recvbuf[i]);
					}
					*/	
					{
						for (i = 0; i < len;i++)
						{
							if (serail_recvbuf[i] != 0xfe)	
							{
								if (readindex485 > 22)
								{
									memset(ReadBuffer485,0,sizeof(ReadBuffer485));
									readindex485 = 0;
								}
								ReadBuffer485[readindex485] = serail_recvbuf[i];
								readindex485++;
								
							}
							else
							{
							//	printf("readindex485=%d\n",readindex485);
								 if (readindex485 != 22 && readindex485 != 5)
								{
									ReadBuffer485[readindex485] = serail_recvbuf[i];
									readindex485++;
								}
								else
								{
								/*
									printf("receiving data  was finished cabin_port,len=%d\n", readindex485);
									for(j = 0; j < readindex485;j++)
										printf(" %x ",ReadBuffer485[j]);
									printf("\n");
									*/
									readindex485--;	
									crc = crc16_ccitt(&ReadBuffer485[1], readindex485 - 2);
								//	printf("crc >> 8=%x crc &0x00ff=%x ReadBuffer485[readindex485-1]=%x ReadBuffer485[readindex485]=%x\n",
								//		crc >> 8,crc &0x00ff,ReadBuffer485[readindex485-1],ReadBuffer485[readindex485 ]);
									if (((crc & 0x00ff) != ReadBuffer485[readindex485]) || ((crc >> 8) != ReadBuffer485[readindex485 - 1]))
									{
										printf("cabin_port crc error\n");
										memset(ReadBuffer485,0,sizeof(ReadBuffer485));
										readindex485 = 0;
										tcflush(serail_hand[cabin_port],TCIFLUSH);	
									//	break;
									}
									else
									{
										pthread_mutex_lock(&mutex_cabinlock);
										
										memcpy(ReadBufferweight,&ReadBuffer485[1],readindex485);
										readindexweight = readindex485;
										readindex485 = 0;
										readfinished485 = TRUE;
										pthread_mutex_unlock(&mutex_cabinlock);
										tcflush(serail_hand[cabin_port],TCIFLUSH);	
										
									}
								}
							}
						}
						
					}
					
			memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
				
			}
#if 0
				{
			//		printf("cabin_port Request read len = %d.: \n", len);
			//		for (i = 0; i < len; i++)
			//			printf(" %02x ", serail_recvbuf[i]);
			//		printf("\n");
					
					if (serail_recvbuf[0] == 0xff)//数据刚到达时
					{
						readindex485 = 0;
						
						for (i = 1; i < len;i++)
						{
							
							if (serail_recvbuf[i] != 0xfe)	
							{
								if (readindex485 > 20)
								{
									memset(ReadBuffer485,0,sizeof(ReadBuffer485));
									readindex485 = 0;
								}
								ReadBuffer485[readindex485] = serail_recvbuf[i];
								readindex485++;
								
							}
							else
							{
							//	readindex485--;
						/*		printf("receiving data  was finished cabin_port,len=%d\n", readindex485);
								for(i = 0; i < readindex485;i++)
									printf(" %x ",ReadBuffer485[i]);
								printf("\n");
								*/
								crc = crc16_ccitt(ReadBuffer485, readindex485 - 2);
						//		printf("crc >> 8=%x crc &0x00ff=%x ReadBuffer485[readindex485-1]=%x ReadBuffer485[readindex485]=%x\n",
						//			crc >> 8,crc &0x00ff,ReadBuffer485[readindex485-2],ReadBuffer485[readindex485 - 1]);
								if (((crc & 0x00ff) != ReadBuffer485[readindex485-1]) || ((crc >> 8) != ReadBuffer485[readindex485 - 2]))
								{
									printf("cabin_port crc error\n");
									memset(ReadBuffer485,0,sizeof(ReadBuffer485));
									readindex485 = 0;
								//	break;
								}
								else
									readfinished485 = TRUE;
							}
						}
						
					}
					else
					{
						for (i = 0; i < len;i++)
						{
							if (serail_recvbuf[i] != 0xfe)	
							{
								if (readindex485 > 20)
								{
									memset(ReadBuffer485,0,sizeof(ReadBuffer485));
									readindex485 = 0;
								}
								ReadBuffer485[readindex485] = serail_recvbuf[i];
								readindex485++;
								
							}
							else
							{
							//	readindex485--;
						/*		printf("receiving data  was finished cabin_port,len=%d\n", readindex485);
								for(i = 0; i < readindex485;i++)
									printf(" %x ",ReadBuffer485[i]);
								printf("\n");
								*/
								crc = crc16_ccitt(ReadBuffer485, readindex485 - 2);
						//		printf("crc >> 8=%x crc &0x00ff=%x ReadBuffer485[readindex485-1]=%x ReadBuffer485[readindex485]=%x\n",
						//			crc >> 8,crc &0x00ff,ReadBuffer485[readindex485-2],ReadBuffer485[readindex485 - 1]);
								if (((crc & 0x00ff) != ReadBuffer485[readindex485-1]) || ((crc >> 8) != ReadBuffer485[readindex485 - 2]))
								{
									printf("cabin_port crc error\n");
									memset(ReadBuffer485,0,sizeof(ReadBuffer485));
									readindex485 = 0;
								//	break;
								}
								else
									readfinished485 = TRUE;
							}
						}
						
					}
					
			memset(serail_recvbuf, 0x00, sizeof(serail_recvbuf));
				
			}
#endif
		}
	#endif
	};
	}
//	close(serail_hand[1]);
	return 1;
}
sc_listenscanhoney()
{
	fd_set	DeviceRead;
	struct timeval timeout;
	int rel,len,i=0;
	unsigned int image_len = 1028;
static unsigned short last_cabin_state[6] = {1,1,1,1,1,1};//0表示被拔17?1表示装入状17?
	stminibd_sendpacket cmd;
	char cmdbuffer[4];
	char scan_ack[20] = {0}; 
	
	printf("[Tp_thread_recvscanner]: Begin to listening Scaner.\n ");	
	



	tcflush(serail_hand[port_scanner],TCIFLUSH);

	while(!flg_mainproexit)
	{
	
	timeout.tv_sec = 0;
	timeout.tv_usec = 100000;

	FD_ZERO(&DeviceRead);
	FD_SET(serail_hand[port_scanner], &DeviceRead);
	
	
	rel = select(serail_hand[port_scanner]+1, &DeviceRead, NULL, NULL, &timeout);
		if(rel < 0) {
			perror("select error");
			return ;
		}
		else
		{
	
			if (FD_ISSET(serail_hand[port_scanner], &DeviceRead))
			{	
				if ((len = read(serail_hand[port_scanner], ScanBuffer, sizeof(ScanBuffer))) > 0)
						{
							
							printf("port_scanner Request read len = %d.: \n", len);
							for (i = 0; i < len; i++)
								printf(" %x ", ScanBuffer[i]);
							printf("\n\n");
							
						};
						
					//	memcpy(scan_ack, ScanBuffer, 6);
					//	if (ScanBuffer[0] == 0x16)	//进行图片数据传输
						if(IsGetImage)
							{
							printf("ingetscan\n");
							
							IsGetImage = 0;
								
								 
							//	 xmodemReceive(serail_hand[port_scanner],ScanBuffer,image_len);//获取图片数据
								
							i=0;
							while(ScanBuffer[++i] != 0XFF);

							printf("i=%d image_cmd_len=%d\n",i, image_cmd_len);
							scan_data_len = len - (i + 1) - (image_cmd_len);	
								printf("scan_data_len=%d\n",scan_data_len);
							memcpy(&scan_data[0], &ScanBuffer[i], scan_data_len);
								for(i=0;i<scan_data_len;i++)
									printf("%x",scan_data[i]);
								IMGSNP_ACK =FALSE;
							  flg_scanerworking = 1;	 
							}
						else if(strcmp(scan_ack, "IMGSNP") == 0)
						{
						//	for(i=0;i<len;i++)
						//			printf("%c",ScanBuffer[i]);
							IMGSNP_ACK = TRUE;
						}
						else if (len > 20)
						{
						//	for(i=0;i<len;i++)
						//			printf("%c",ScanBuffer[i]);
						}
						else	//OCR17?
						{
							tcflush(serail_hand[port_scanner],TCIFLUSH);
							printf("OCR recieved，scan_OCR_len=%d\n", scan_OCR_len);
							memcpy(scan_OCR_data,ScanBuffer,len - 2);//多两个字符
							scan_OCR_len = len - 2;
							printf("OCR recieved，scan_OCR_len=%d\n", scan_OCR_len);
							flg_scanerworking = 1;	 
						}
						
				
							tcflush(serail_hand[port_scanner],TCIFLUSH);
						memset(ScanBuffer, 0x00, sizeof(ScanBuffer));
			
				}
			}
		}
	return ;
}


void Tp_thread_recvscanner(void *arg)
{
	if (honey_scaner)
			 sc_listenscanhoney();

if (new_scaner)
{
	

	fd_set 	DeviceRead;
	struct timeval timeout;
	int rel,len,i;
	unsigned int image_len = 1028;
		char ACKBUF[6]={4,0XD0,4,0,0XFF,0X28};
		const char	  Buf1[6]={4,0xE4,4,0,0xFF,0x14};//4 //4 E4 4 0 FF 14
static unsigned short last_cabin_state[6] = {1,1,1,1,1,1};//0表示被拔出 1表示装入状态
	stminibd_sendpacket cmd;
 	char cmdbuffer[4];
	char scan_ack[20] = {0}; 
	
//	int port_scanner = COM4;
	
	int fd	= serail_hand[port_scanner];
	printf("[Tp_thread_recvscanner]: Begin to listening Scaner.\n ");	
	
	

	tcflush(serail_hand[port_scanner],TCIFLUSH);

	while(!flg_mainproexit)
	{
	
	timeout.tv_sec = 0;
	timeout.tv_usec = 1000;

	FD_ZERO(&DeviceRead);
	FD_SET(serail_hand[port_scanner], &DeviceRead);
	
	
	rel = select(serail_hand[port_scanner]+1, &DeviceRead, NULL, NULL, &timeout);
		if(rel < 0) {
			perror("select error");
			return ;
		}
		else
		{
	
			if (FD_ISSET(serail_hand[port_scanner], &DeviceRead))
			{	
				if ((len = read(serail_hand[port_scanner], ScanBuffer, sizeof(ScanBuffer))) > 0)
						{
							
							printf("port_scanner Request read len = %d.: \n", len);
							for (i = 0; i < len; i++)
								printf(" %x ", ScanBuffer[i]);
							printf("\n\n");
							
						};
				if (ScanBuffer[1] == 0XD0)
					scanner_acknum = 1;
				else if (ScanBuffer[1] == 0XD1)
					scanner_acknum = 2;	
				else if (IsGetCode)
				{
							printf("OCR recieved IsGetImage=%d\n",IsGetImage);
							memcpy(scan_OCR_data,ScanBuffer,len);
							scan_OCR_len = len;
							flg_scanerworking = 1;	 
				}
				
				if (IsGetImage && ScanBuffer[1] == 0XD0)
					{
						IsGetImage = FALSE;
					InGetImage = TRUE;
					/*
					usleep(10000);
						if (write(fd, Buf1, sizeof(Buf1)) < 0)
					   printf("send scaner activate trigger failed fd= %d\n", fd);
					else
					   printf("send scaner activate trigger success fd= %d\n", fd);
					printf("BUF=\n");
						for (i = 0; i < sizeof(Buf1); i++)
						{
							printf(" %x ",Buf1[i]);
						}
					printf("\n");
					*/
					}
				
				if (ScanBuffer[1] == 0XB1)
					{
						

						
						if (write(fd, ACKBUF, sizeof(ACKBUF)) < 0)
					   printf("send scaner ACK failed fd= %d\n", fd);
						
					printf("send scaner activate trigger success fd= %d\n", fd);
					printf("BUF=\n");
						for (i = 0; i < sizeof(Buf1); i++)
						{
							printf(" %x ",ACKBUF[i]);
						}
					printf("\n");

						if (InGetImage)
						{
							memcpy(&scan_data[scan_data_len],&ScanBuffer[4],ScanBuffer[0] - 4);
							scan_data_len += ScanBuffer[0] - 4;
						
							{
								flg_scannerrecivimage = 1;	
						//S		InGetImage = FALSE;
							}

								if ( (ScanBuffer[3] & 0x2) == 0)
									flg_scannerlastimage = TRUE;
						}
						
					}
							
						
					
							tcflush(serail_hand[port_scanner],TCIFLUSH);
						memset(ScanBuffer, 0x00, sizeof(ScanBuffer));
			
				}
			}
		}
	return ;
}
else
{
	fd_set 	DeviceRead;
	struct timeval timeout;
	int rel,len,i;
	unsigned int image_len = 1028;
static unsigned short last_cabin_state[6] = {1,1,1,1,1,1};//0表示被拔出 1表示装入状态
	stminibd_sendpacket cmd;
 	char cmdbuffer[4];
	char scan_ack[20] = {0}; 
	
	printf("[Tp_thread_recvscanner]: Begin to listening Scaner.\n ");	
	



	tcflush(serail_hand[port_scanner],TCIFLUSH);

	while(!flg_mainproexit)
	{
	
	timeout.tv_sec = 0;
	timeout.tv_usec = 100000;

	FD_ZERO(&DeviceRead);
	FD_SET(serail_hand[port_scanner], &DeviceRead);
	
	
	rel = select(serail_hand[port_scanner]+1, &DeviceRead, NULL, NULL, &timeout);
		if(rel < 0) {
			perror("select error");
			return ;
		}
		else
		{
	
			if (FD_ISSET(serail_hand[port_scanner], &DeviceRead))
			{	
				if ((len = read(serail_hand[port_scanner], ScanBuffer, sizeof(ScanBuffer))) > 0)
						{
							/*
							printf("port_scanner Request read len = %d.: \n", len);
							for (i = 0; i < len; i++)
								printf(" %c ", ScanBuffer[i]);
							printf("\n\n");
							*/
						};
						
						memcpy(scan_ack, ScanBuffer, 6);
						if (ScanBuffer[0] == 0x16)	//进行图片数据传输
							{
								tcflush(serail_hand[port_scanner],TCIFLUSH);
								memset(ScanBuffer, 0x00, sizeof(ScanBuffer));			
								 
								 xmodemReceive(serail_hand[port_scanner],ScanBuffer,image_len);//获取图片数据
								
							//	printf("scan_data_len=%d\n",scan_data_len);
							//	for(i=0;i<scan_data_len;i++)
							//		printf("%c",scan_data[i]);
								IMGSNP_ACK =FALSE;
							  flg_scanerworking = 1;	 
							}
						else if(strcmp(scan_ack, "IMGSNP") == 0)
						{
						//	for(i=0;i<len;i++)
						//			printf("%c",ScanBuffer[i]);
							IMGSNP_ACK = TRUE;
						}
						else if (len > 20)
						{
						//	for(i=0;i<len;i++)
						//			printf("%c",ScanBuffer[i]);
						}
						else	//OCR码
						{
							tcflush(serail_hand[port_scanner],TCIFLUSH);
							printf("OCR recieved\n");
							memcpy(scan_OCR_data,ScanBuffer,len);
							scan_OCR_len = len;
							flg_scanerworking = 1;	 
						}
						
				
							tcflush(serail_hand[port_scanner],TCIFLUSH);
						memset(ScanBuffer, 0x00, sizeof(ScanBuffer));
			
				}
			}
		}
	return ;
}

}


void MainArmTest(unsigned int Ary[],int x,int y,unsigned int z)
{
	sr_cmdstruct_t CommandElemt;
 
	CommandElemt.srdevaddr = ARM_ADDR;
	sprintf(CommandElemt.cmdbuf, "PA %d %d %d", Ary[0] + x,Ary[1] + y,z);	//缓慢抽吸空气
	if (sb_armpumpsend(port_arm, (unsigned char 	*)CommandElemt.cmdbuf, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[MainArmTest]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[MainArmTest]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
}

void WriteArmTest(char* string)
{
	sr_cmdstruct_t CommandElemt;
 
	CommandElemt.srdevaddr = ARM_ADDR;
	if (sb_armpumpsend(port_arm, string, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[WriteArmTest]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[WriteArmTest]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
}

void WritePumpTest(char* string)
{
	sr_cmdstruct_t CommandElemt;
 
	CommandElemt.srdevaddr = PUMP_ADDR;
	if (sb_armpumpsend(port_arm, string, 
			CommandElemt.srdevaddr , 1, 0, 1) > 0)
			printf("[WriteArmTest]: Send message  to tecan device [%x]successful.\n" ,CommandElemt.srdevaddr );
		else
			printf("[WriteArmTest]: Send message  to tecan device [%x]failed.\n" ,CommandElemt.srdevaddr );
		sb_waitingframeaswer(&CommandElemt);
}




